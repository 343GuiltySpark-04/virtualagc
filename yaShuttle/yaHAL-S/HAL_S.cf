{-
Copyright:  	Public Domain
Filename:   	HAL_S.cf
Purpose:    	LBNF description of the HAL/S language, in so far as compiler 
            	generation via the BNF Converter compiler-compiler-compiler is 
            	concerned.  This description requires the preprocessor's --full
            	command-line switch.
History:    	2022-11-19 RSB  Previously this file was autogenerated
                            	by the script bnf2lbnf.py from the files
                            	HAL-S.bnf and extraHAL-S.lbnf.  From
                            	this point onward, that will no longer
                            	be done, and this file should be 
                            	directly modified.
            	2022-11-20 RSB  Lots of debugging to fix shift/reduce,
                            	reduce/shift, reduce/reduce conflicts.
            	2022-11-21 RSB  Builds the compiler (including parser)
                            	without errors or warnings now.  But 
                            	some HAL/S files which formerly compiled
                            	no longer do.
        	2022-11-25 RSB	Altered various LBNF labels to ease analysis
        			of front-end results by the compiler back-end.
        	2022-11-30 RSB	Tried to account for bracketed variables in
        			assignments and expressions.

Originally derived from the BNF description of the HAL/S programming 
language, in Appendix G of the HAL/S Language specification
(https://www.ibiblio.org/apollo/Shuttle/
     HAL_S%20Language%20Specification%20Nov%202005.pdf#page=209),
and mostly duplicated in the program comments of SYNTHESI.xpl
(which is a module of the original HAL/S compiler HAL/S-FC).
However, while that original description was fine for loose
documentation of the syntax, it was not sufficiently bug-free and
complete for direct use in automation.  Thus this file contains
substantial revisions and additions.
-}

entrypoints COMPILATION ;
comment "//" ;
comment "/*" "*/" ;

token BitIdentifierToken {"b_"}["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"](["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"]*["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"])? ;
token BitFunctionIdentifierToken  {"bf_"}["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"](["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"]*["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"])? ;
token CharFunctionIdentifierToken {"cf_"}["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"](["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"]*["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"])? ;
token CharIdentifierToken {"c_"}["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"](["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"]*["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"])? ;
token StructIdentifierToken {"s_"}["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"](["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"]*["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"])? ;
token LabelToken {"l_"}["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"](["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"]*["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"])? ;
token EventToken {"e_"}["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"](["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"]*["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"])? ;
token IdentifierToken ["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"](["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"]*["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"])? ;
token StringToken ["'"]["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-]% $()[|*./&¬=<>#@,;:{}!?\""]+["'"] ;
token TextToken ["\""]["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-]% $()[|*./&¬=<>#@,;:{}!?'"]+["\""] ;
token LevelToken ( ["123456789"] | ["12"]["0123456789"] ) ;
token NumberToken ["0123456789"]+ ;
token CompoundToken ( ["0123456789"]+ ( ["."]["0123456789"]* )? | ["."]["0123456789"]+ ) ( ["EBH"]["-"]?["0123456789"]+ )? ;

--------------------------------------------------------------------------
-- Here are just the rules for ARITH_EXP, without reference to BIT_EXP,
-- CHAR_EXP, STRUCT_EXP, NAME_EXP, or SUBSCRIPT.  The reason that the
-- XXX_EXP's I've omitted may be needed is that they may be parameters
-- in call lists for functions that have numeric return values.
AAarith_exp . ARITH_EXP ::= TERM ;
ABarith_exp . ARITH_EXP ::= PLUS TERM ;
ACarith_exp . ARITH_EXP ::= MINUS TERM ;
ADarith_exp . ARITH_EXP ::= ARITH_EXP PLUS TERM ;
AEarith_exp . ARITH_EXP ::= ARITH_EXP MINUS TERM ;
AAtermNoDivide . TERM ::= PRODUCT ;
ABtermDivide . TERM ::= PRODUCT "/" TERM ;
AAplus . PLUS ::= "+" ;
AAminus . MINUS ::= "-" ;
AAproductSingle . PRODUCT ::= FACTOR ;
ABproductCross . PRODUCT ::= FACTOR "*" PRODUCT ;
ACproductDot . PRODUCT ::= FACTOR "." PRODUCT ;
ADproductMultiplication . PRODUCT ::= FACTOR PRODUCT ;
AAfactor . FACTOR ::= PRIMARY ;
ABfactorExponentiation . FACTOR ::= PRIMARY EXPONENTIATION FACTOR ;
AAexponentiation . EXPONENTIATION ::= "**" ;
AAprimary . PRIMARY ::= ARITH_VAR ;
AAarith_var . ARITH_VAR ::= ARITH_ID ;
ADprimary . PRIMARY ::= PRE_PRIMARY ;
AApre_primary . PRE_PRIMARY ::= "(" ARITH_EXP ")" ;
ABpre_primary . PRE_PRIMARY ::= NUMBER ;
ACpre_primary . PRE_PRIMARY ::= COMPOUND_NUMBER ;
AAnumber . NUMBER ::= SIMPLE_NUMBER ;
ABnumber . NUMBER ::= LEVEL ;
ZZlevel . LEVEL ::= LevelToken ;
CLcompound_number . COMPOUND_NUMBER ::= CompoundToken ;
CKsimple_number . SIMPLE_NUMBER ::= NumberToken ;
ABprimary . PRIMARY ::= MODIFIED_ARITH_FUNC ;
AAmodified_arith_func . MODIFIED_ARITH_FUNC ::= NO_ARG_ARITH_FUNC ;
ADpre_primary . PRE_PRIMARY ::= ARITH_FUNC_HEAD "(" CALL_LIST ")" ;
AAarith_func_head . ARITH_FUNC_HEAD ::= ARITH_FUNC ;
AAcall_list . CALL_LIST ::= LIST_EXP ;
ABcall_list . CALL_LIST ::= CALL_LIST "," LIST_EXP ;
AAlist_exp . LIST_EXP ::= EXPRESSION ;
ABlist_exp . LIST_EXP ::= ARITH_EXP "#" EXPRESSION ;
AAexpression . EXPRESSION ::= ARITH_EXP ;
FGarith_id . ARITH_ID ::= IDENTIFIER ;
FFidentifier . IDENTIFIER ::= IdentifierToken ;
ZZclocktime. NO_ARG_ARITH_FUNC ::= "CLOCKTIME" ;
ZZdate. NO_ARG_ARITH_FUNC ::= "DATE" ;
ZZerrgrp. NO_ARG_ARITH_FUNC ::= "ERRGRP" ;
ZZprio. NO_ARG_ARITH_FUNC ::= "PRIO" ;
ZZrandom. NO_ARG_ARITH_FUNC ::= "RANDOM" ;
ZZruntime. NO_ARG_ARITH_FUNC ::= "RUNTIME" ;
ZZnexttime. ARITH_FUNC ::= "NEXTTIME" ;
ZZabs. ARITH_FUNC ::= "ABS" ;
ZZceiling. ARITH_FUNC ::= "CEILING" ;
ZZdiv. ARITH_FUNC ::= "DIV" ;
ZZfloor. ARITH_FUNC ::= "FLOOR" ;
ZZmidval. ARITH_FUNC ::= "MIDVAL" ;
ZZmod. ARITH_FUNC ::= "MOD" ;
ZZodd. ARITH_FUNC ::= "ODD" ;
ZZremainder. ARITH_FUNC ::= "REMAINDER" ;
ZZround. ARITH_FUNC ::= "ROUND" ;
ZZsign. ARITH_FUNC ::= "SIGN" ;
ZZsignum. ARITH_FUNC ::= "SIGNUM" ;
ZZtruncate. ARITH_FUNC ::= "TRUNCATE" ;
ZZarccos. ARITH_FUNC ::= "ARCCOS" ;
ZZarccosh. ARITH_FUNC ::= "ARCCOSH" ;
ZZarcsin. ARITH_FUNC ::= "ARCSIN" ;
ZZarcsinh. ARITH_FUNC ::= "ARCSINH" ;
ZZarctan2. ARITH_FUNC ::= "ARCTAN2" ;
ZZarctan. ARITH_FUNC ::= "ARCTAN" ;
ZZarctanh. ARITH_FUNC ::= "ARCTANH" ;
ZZcos. ARITH_FUNC ::= "COS" ;
ZZcosh. ARITH_FUNC ::= "COSH" ;
ZZexp. ARITH_FUNC ::= "EXP" ;
ZZlog. ARITH_FUNC ::= "LOG" ;
ZZsin. ARITH_FUNC ::= "SIN" ;
ZZsinh. ARITH_FUNC ::= "SINH" ;
ZZsqrt. ARITH_FUNC ::= "SQRT" ;
ZZtan. ARITH_FUNC ::= "TAN" ;
ZZtanh. ARITH_FUNC ::= "TANH" ;
ZZshl. ARITH_FUNC ::= "SHL" ;
ZZshr. ARITH_FUNC ::= "SHR" ;
ZZabval. ARITH_FUNC ::= "ABVAL" ;
ZZdet. ARITH_FUNC ::= "DET" ;
ZZtrace. ARITH_FUNC ::= "TRACE" ;
ZZunit. ARITH_FUNC ::= "UNIT" ;
ZZmatrix. ARITH_FUNC ::= "MATRIX" ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for SUBSCRIPT.
ACarith_var . ARITH_VAR ::= ARITH_ID SUBSCRIPT ;

AAarithVarBracketed . ARITH_VAR ::= "[" ARITH_ID "]" ;
ABarithVarBracketed . ARITH_VAR ::= "[" ARITH_ID "]" SUBSCRIPT ;

ACmodified_arith_func . MODIFIED_ARITH_FUNC ::= NO_ARG_ARITH_FUNC SUBSCRIPT ;
AAsubscript . SUBSCRIPT ::= SUB_HEAD ")" ;
ABsubscript . SUBSCRIPT ::= QUALIFIER ;
ACsubscript . SUBSCRIPT ::= "$" NUMBER ;
ADsubscript . SUBSCRIPT ::= "$" ARITH_VAR ;
AAqualifier . QUALIFIER ::= "$" "(" "@" PREC_SPEC ")" ;
ABqualifier . QUALIFIER ::= "$" "(" SCALE_HEAD ARITH_EXP ")" ;
ACqualifier . QUALIFIER ::= "$" "(" "@" PREC_SPEC "," SCALE_HEAD ARITH_EXP ")" ;
AAscale_head . SCALE_HEAD ::= "@" ;
ABscale_head . SCALE_HEAD ::= "@" "@" ;
AAprecSpecSingle . PREC_SPEC ::= "SINGLE" ;
ABprecSpecDouble . PREC_SPEC ::= "DOUBLE" ;
AAsub_start . SUB_START ::= "$" "(" ;
ABsub_start . SUB_START ::= "$" "(" "@" PREC_SPEC "," ;
ACsub_start . SUB_START ::= SUB_HEAD ";" ;
ADsub_start . SUB_START ::= SUB_HEAD ":" ;
AEsub_start . SUB_START ::= SUB_HEAD "," ;
AAsub_head . SUB_HEAD ::= SUB_START ;
ABsub_head . SUB_HEAD ::= SUB_START SUB ;
AAsub . SUB ::= SUB_EXP ;
ABsubStar . SUB ::= "*" ;
ACsubExp . SUB ::= SUB_RUN_HEAD SUB_EXP ;
ADsubAt . SUB ::= ARITH_EXP "AT" SUB_EXP ;
AAsubRunHeadTo . SUB_RUN_HEAD ::= SUB_EXP "TO" ;
AAsub_exp . SUB_EXP ::= ARITH_EXP ;
ABsub_exp . SUB_EXP ::= POUND_EXPRESSION ;
AApound_expression . POUND_EXPRESSION ::= "#" ;
ABpound_expression . POUND_EXPRESSION ::= POUND_EXPRESSION PLUS TERM ;
ACpound_expression . POUND_EXPRESSION ::= POUND_EXPRESSION MINUS TERM ;
AAarithConvInteger . ARITH_CONV ::= "INTEGER" ;
ABarithConvScalar . ARITH_CONV ::= "SCALAR" ;
ACarithConvVector . ARITH_CONV ::= "VECTOR" ;
ADarithConvMatrix . ARITH_CONV ::= "MATRIX" ;
ABarith_func_head . ARITH_FUNC_HEAD ::= ARITH_CONV SUBSCRIPT ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for BIT_EXP.
ABexpression . EXPRESSION ::= BIT_EXP ;
AAbit_exp . BIT_EXP ::= BIT_FACTOR ;
ABbit_exp . BIT_EXP ::= BIT_EXP OR BIT_FACTOR ;
AAbit_factor . BIT_FACTOR ::= BIT_CAT ;
ABbit_factor . BIT_FACTOR ::= BIT_FACTOR AND BIT_CAT ;
AAbit_cat . BIT_CAT ::= BIT_PRIM ;
ABbit_cat . BIT_CAT ::= BIT_CAT CAT BIT_PRIM ;
ACbit_cat . BIT_CAT ::= NOT BIT_PRIM ;
ADbit_cat . BIT_CAT ::= BIT_CAT CAT NOT BIT_PRIM ;
AAor . OR ::= CHAR_VERTICAL_BAR ;
ABor . OR ::= "OR" ;
CFchar_vertical_bar . CHAR_VERTICAL_BAR ::= "|" ;
AAand . AND ::= "&" ;
ABand . AND ::= "AND" ;
AAbitPrimBitVar . BIT_PRIM ::= BIT_VAR ;
ABbitPrimLabelVar . BIT_PRIM ::= LABEL_VAR ;
ACbitPrimEventVar . BIT_PRIM ::= EVENT_VAR ;
ADbitBitConst . BIT_PRIM ::= BIT_CONST ;
AEbitPrimBitExp . BIT_PRIM ::= "(" BIT_EXP ")" ;
AHbitPrimSubbit . BIT_PRIM ::= SUBBIT_HEAD EXPRESSION ")" ;
AIbitPrimFunc . BIT_PRIM ::= BIT_FUNC_HEAD "(" CALL_LIST ")" ;
AAcat . CAT ::= "||" ;
ABcat . CAT ::= "CAT" ;
AAnot . NOT ::= "¬" ;
ABnot . NOT ::= "NOT" ;
AAbit_var . BIT_VAR ::= BIT_ID ;
ACbit_var . BIT_VAR ::= BIT_ID SUBSCRIPT ;
AAlabel_var . LABEL_VAR ::= LABEL ;
ABlabel_var . LABEL_VAR ::= LABEL SUBSCRIPT ;
AAevent_var . EVENT_VAR ::= EVENT ;
ACevent_var . EVENT_VAR ::= EVENT SUBSCRIPT ;
AAbit_const_head . BIT_CONST_HEAD ::= RADIX ;
ABbit_const_head . BIT_CONST_HEAD ::= RADIX "(" NUMBER ")" ;
AAbitConstString . BIT_CONST ::= BIT_CONST_HEAD CHAR_STRING ;
ABbitConstTrue . BIT_CONST ::= "TRUE" ;
ACbitConstFalse . BIT_CONST ::= "FALSE" ;
ADbitConstOn . BIT_CONST ::= "ON" ;
AEbitConstOff . BIT_CONST ::= "OFF" ;
AAradixHEX . RADIX ::= "HEX" ;
ABradixOCT . RADIX ::= "OCT" ;
ACradixBIN . RADIX ::= "BIN" ;
ADradixDEC . RADIX ::= "DEC" ;
FPchar_string . CHAR_STRING ::= StringToken ;
AAsubbit_head . SUBBIT_HEAD ::= SUBBIT_KEY "(" ;
ABsubbit_head . SUBBIT_HEAD ::= SUBBIT_KEY SUBSCRIPT "(" ;
AAsubbit_key . SUBBIT_KEY ::= "SUBBIT" ;
AAbit_func_head . BIT_FUNC_HEAD ::= BIT_FUNC ;
ABbit_func_head . BIT_FUNC_HEAD ::= "BIT" ;
ACbit_func_head . BIT_FUNC_HEAD ::= "BIT" SUB_OR_QUALIFIER ;
FHbit_id . BIT_ID ::= BitIdentifierToken ;
FKlabel . LABEL ::= LabelToken ;
FLlabel . LABEL ::= BitFunctionIdentifierToken ;
FMlabel . LABEL ::= CharFunctionIdentifierToken ;
ZZxor. BIT_FUNC ::= "XOR" ;
ZZuserBitFunction. BIT_FUNC ::= BitFunctionIdentifierToken ;
FLevent . EVENT ::= EventToken ;
AAsub_or_qualifier . SUB_OR_QUALIFIER ::= SUBSCRIPT ;
ABsub_or_qualifier . SUB_OR_QUALIFIER ::= BIT_QUALIFIER ;
AAbit_qualifier . BIT_QUALIFIER ::= "<" "$" "(" "@" RADIX ")" ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for CHAR_EXP.
ACexpression . EXPRESSION ::= CHAR_EXP ;
AAchar_exp . CHAR_EXP ::= CHAR_PRIM ;
ABchar_exp . CHAR_EXP ::= CHAR_EXP CAT CHAR_PRIM ;
ACchar_exp . CHAR_EXP ::= CHAR_EXP CAT ARITH_EXP ;
ADchar_exp . CHAR_EXP ::= ARITH_EXP CAT ARITH_EXP ;
AEchar_exp . CHAR_EXP ::= ARITH_EXP CAT CHAR_PRIM ;
AAchar_prim . CHAR_PRIM ::= CHAR_VAR ;
ABchar_prim . CHAR_PRIM ::= CHAR_CONST ;
AEchar_prim . CHAR_PRIM ::= CHAR_FUNC_HEAD "(" CALL_LIST ")" ;
AFchar_prim . CHAR_PRIM ::= "(" CHAR_EXP ")" ;
AAchar_func_head . CHAR_FUNC_HEAD ::= CHAR_FUNC ;
ABchar_func_head . CHAR_FUNC_HEAD ::= "CHARACTER" SUB_OR_QUALIFIER ;
AAchar_var . CHAR_VAR ::= CHAR_ID ;
ACchar_var . CHAR_VAR ::= CHAR_ID SUBSCRIPT ;
AAchar_const . CHAR_CONST ::= CHAR_STRING ;
ABchar_const . CHAR_CONST ::= "CHAR" "(" NUMBER ")" CHAR_STRING ;
ZZindex. CHAR_FUNC ::= "INDEX" ;
ZZlength. CHAR_FUNC ::= "LENGTH" ;
ZZljust. CHAR_FUNC ::= "LJUST" ;
ZZrjust. CHAR_FUNC ::= "RJUST" ;
ZZtrim. CHAR_FUNC ::= "TRIM" ;
FIchar_id . CHAR_ID ::= CharIdentifierToken ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for NAME_EXP.
AEexpression . EXPRESSION ::= NAME_EXP ;
AAname_exp . NAME_EXP ::= NAME_KEY "(" NAME_VAR ")" ;
ABname_exp . NAME_EXP ::= "NULL" ;
ACname_exp . NAME_EXP ::= NAME_KEY "(" "NULL" ")" ;
AAname_key . NAME_KEY ::= "NAME" ;
AAname_var . NAME_VAR ::= VARIABLE ;
ACname_var . NAME_VAR ::= MODIFIED_ARITH_FUNC ;
AAvariable . VARIABLE ::= ARITH_VAR ;
ACvariable . VARIABLE ::= BIT_VAR ;
AEvariable . VARIABLE ::= SUBBIT_HEAD VARIABLE ")" ;
AFvariable . VARIABLE ::= CHAR_VAR ;
AGvariable . VARIABLE ::= NAME_KEY "(" NAME_VAR ")" ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for STRUCTURE_EXP and QUAL_STRUCT.
-- I believe this completes all rules for EXPRESSION.
ADexpression . EXPRESSION ::= STRUCTURE_EXP ;
AAstructure_exp . STRUCTURE_EXP ::= STRUCTURE_VAR ;
ADstructure_exp . STRUCTURE_EXP ::= STRUCT_FUNC_HEAD "(" CALL_LIST ")" ;
AAstruct_func_head . STRUCT_FUNC_HEAD ::= STRUCT_FUNC ;
AAstructure_var . STRUCTURE_VAR ::= QUAL_STRUCT SUBSCRIPT ;
ZZinverse. STRUCT_FUNC ::= "INVERSE" ;
ZZtranspose. STRUCT_FUNC ::= "TRANSPOSE" ;
ZZprod. STRUCT_FUNC ::= "PROD" ;
ZZsum. STRUCT_FUNC ::= "SUM" ;
ZZsize. STRUCT_FUNC ::= "SIZE" ;
ZZmax. STRUCT_FUNC ::= "MAX" ;
ZZmin. STRUCT_FUNC ::= "MIN" ;
AAqual_struct . QUAL_STRUCT ::= STRUCTURE_ID ;
ABqual_struct . QUAL_STRUCT ::= QUAL_STRUCT "." STRUCTURE_ID ;
FJstructure_id . STRUCTURE_ID ::= StructIdentifierToken ;
AClabel_var . LABEL_VAR ::= QUAL_STRUCT "." LABEL ;
ADlabel_var . LABEL_VAR ::= QUAL_STRUCT "." LABEL SUBSCRIPT ;
ABbit_var . BIT_VAR ::= QUAL_STRUCT "." BIT_ID ;
ADbit_var . BIT_VAR ::= QUAL_STRUCT "." BIT_ID SUBSCRIPT ;
ABchar_var . CHAR_VAR ::= QUAL_STRUCT "." CHAR_ID ;
ADchar_var . CHAR_VAR ::= QUAL_STRUCT "." CHAR_ID SUBSCRIPT ;
ABevent_var . EVENT_VAR ::= QUAL_STRUCT "." EVENT ;
ADevent_var . EVENT_VAR ::= QUAL_STRUCT "." EVENT SUBSCRIPT ;
ADmodified_arith_func . MODIFIED_ARITH_FUNC ::= QUAL_STRUCT "." NO_ARG_ARITH_FUNC ;
AEmodified_arith_func . MODIFIED_ARITH_FUNC ::= QUAL_STRUCT "." NO_ARG_ARITH_FUNC SUBSCRIPT ;
ABarith_var . ARITH_VAR ::= QUAL_STRUCT "." ARITH_ID ;
ADarith_var . ARITH_VAR ::= QUAL_STRUCT "."  ARITH_ID SUBSCRIPT ;
ADvariable . VARIABLE ::= EVENT_VAR ;
ABvariable . VARIABLE ::= STRUCTURE_VAR ;
ABname_var . NAME_VAR ::= LABEL_VAR ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for ASSIGNMENT.  Well, that's 
-- easy!
AAassignment . ASSIGNMENT ::= VARIABLE EQUALS EXPRESSION ;
ABassignment . ASSIGNMENT ::= VARIABLE "," ASSIGNMENT ;
AAequals . EQUALS ::= "=" ;

--------------------------------------------------------------------------
-- Here are the additional rules needed for IF_STATEMENT. 
AAif_statement . IF_STATEMENT ::= IF_CLAUSE STATEMENT ;
ABif_statement . IF_STATEMENT ::= TRUE_PART STATEMENT ;
AAif_clause . IF_CLAUSE ::= IF RELATIONAL_EXP "THEN" ;
ABif_clause . IF_CLAUSE ::= IF BIT_EXP "THEN" ;
AAtrue_part . TRUE_PART ::= IF_CLAUSE BASIC_STATEMENT "ELSE" ;
AAif . IF ::= "IF" ;
AArelational_exp . RELATIONAL_EXP ::= RELATIONAL_FACTOR ;
ABrelational_exp . RELATIONAL_EXP ::= RELATIONAL_EXP OR RELATIONAL_FACTOR ;
AArelational_factor . RELATIONAL_FACTOR ::= REL_PRIM ;
ABrelational_factor . RELATIONAL_FACTOR ::= RELATIONAL_FACTOR AND REL_PRIM ;
-- The following two lines originally had "1" RELATIONAL_EXP rather than just
-- RELATIONAL_EXP on the right.  Both the language specification and
-- the comments in SYNTHESI agree.  I find no explanation in any documentation
-- or code accessible to me as to what this may mean, and the "1" causes the
-- parser no end of trouble.  Besides, it's ambiguous:  What if the 
-- RELATIONAL_EXP were "X > 1".  Then having the "1" here would be 
-- indistinguishable from "1 X > 1", which multiplies 1 and X.  For now, I'm
-- just eliminating the "1".
AArel_prim . REL_PRIM ::= "(" RELATIONAL_EXP ")" ;
ABrel_prim . REL_PRIM ::= NOT "(" RELATIONAL_EXP ")" ;
ACrel_prim . REL_PRIM ::= COMPARISON ;
AAcomparison . COMPARISON ::= ARITH_EXP RELATIONAL_OP ARITH_EXP ;
ABcomparison . COMPARISON ::= CHAR_EXP RELATIONAL_OP CHAR_EXP ;
ACcomparison . COMPARISON ::= BIT_CAT RELATIONAL_OP BIT_CAT ;
ADcomparison . COMPARISON ::= STRUCTURE_EXP RELATIONAL_OP STRUCTURE_EXP ;
AEcomparison . COMPARISON ::= NAME_EXP RELATIONAL_OP NAME_EXP ;
AArelationalOpEQ . RELATIONAL_OP ::= EQUALS ;
ABrelationalOpNEQ . RELATIONAL_OP ::= NOT EQUALS ;
ACrelationalOpLT . RELATIONAL_OP ::= "<" ;
ADrelationalOpGT . RELATIONAL_OP ::= ">" ;
AErelationalOpLE . RELATIONAL_OP ::= "<=" ;
AFrelationalOpGE . RELATIONAL_OP ::= ">=" ;
AGrelationalOpNLT . RELATIONAL_OP ::= NOT "<" ;
AHrelationalOpNGT . RELATIONAL_OP ::= NOT ">" ;
AAstatement . STATEMENT ::= BASIC_STATEMENT ;
ABstatement . STATEMENT ::= OTHER_STATEMENT ;
ABbasicStatementAssignment . BASIC_STATEMENT ::= ASSIGNMENT ";" ;
ABotherStatementIf . OTHER_STATEMENT ::= IF_STATEMENT ;

--------------------------------------------------------------------------
-- Additional rules for more types of STATEMENTs, except BLOCKs. 
AAotherStatementOn . OTHER_STATEMENT ::= ON_PHRASE STATEMENT ;
ACother_statement . OTHER_STATEMENT ::= LABEL_DEFINITION OTHER_STATEMENT ;
AAany_statement . ANY_STATEMENT ::= STATEMENT ;
AAbasic_statement . BASIC_STATEMENT ::= LABEL_DEFINITION BASIC_STATEMENT ;
ACbasicStatementExit . BASIC_STATEMENT ::= "EXIT" ";" ;
ADbasicStatementExit . BASIC_STATEMENT ::= "EXIT" LABEL ";" ;
AEbasicStatementRepeat . BASIC_STATEMENT ::= "REPEAT" ";" ;
AFbasicStatementRepeat . BASIC_STATEMENT ::= "REPEAT" LABEL ";" ;
AGbasicStatementGoTo . BASIC_STATEMENT ::= "GO" "TO" LABEL ";" ;
AHbasicStatementEmpty . BASIC_STATEMENT ::= ";" ;
AIbasicStatementCall . BASIC_STATEMENT ::= CALL_KEY ";" ;
AJbasicStatementCall . BASIC_STATEMENT ::= CALL_KEY "(" CALL_LIST ")" ";" ;
AKbasicStatementCall . BASIC_STATEMENT ::= CALL_KEY ASSIGN "(" CALL_ASSIGN_LIST ")" ";" ;
ALbasicStatementCall . BASIC_STATEMENT ::= CALL_KEY "(" CALL_LIST ")" ASSIGN "(" CALL_ASSIGN_LIST ")" ";" ;
AMbasicStatementReturn . BASIC_STATEMENT ::= "RETURN;" ;
ANbasicStatementReturn . BASIC_STATEMENT ::= "RETURN" EXPRESSION ";" ;
AObasicStatementDo . BASIC_STATEMENT ::= DO_GROUP_HEAD ENDING ";" ;
APbasicStatementReadKey . BASIC_STATEMENT ::= READ_KEY ";" ;
AQbasicStatementReadPhrase . BASIC_STATEMENT ::= READ_PHRASE ";" ;
ARbasicStatementWriteKey . BASIC_STATEMENT ::= WRITE_KEY ";" ;
ASbasicStatementWritePhrase . BASIC_STATEMENT ::= WRITE_PHRASE ";" ;
ATbasicStatementFileExp . BASIC_STATEMENT ::= FILE_EXP EQUALS EXPRESSION ";" ;
AUbasicStatementFileExp . BASIC_STATEMENT ::= VARIABLE EQUALS FILE_EXP ";" ;
AVbasicStatementWait . BASIC_STATEMENT ::= WAIT_KEY "FOR" "DEPENDENT" ";" ;
AWbasicStatementWait . BASIC_STATEMENT ::= WAIT_KEY ARITH_EXP ";" ;
AXbasicStatementWait . BASIC_STATEMENT ::= WAIT_KEY "UNTIL" ARITH_EXP ";" ;
AYbasicStatementWait . BASIC_STATEMENT ::= WAIT_KEY "FOR" BIT_EXP ";" ;
AZbasicStatementTerminator . BASIC_STATEMENT ::= TERMINATOR ";" ;
BAbasicStatementTerminator . BASIC_STATEMENT ::= TERMINATOR TERMINATE_LIST ";" ;
BBbasicStatementUpdate . BASIC_STATEMENT ::= "UPDATE" "PRIORITY" "TO" ARITH_EXP ";" ;
BCbasicStatementUpdate . BASIC_STATEMENT ::= "UPDATE" "PRIORITY" LABEL_VAR "TO" ARITH_EXP ";" ;
BDbasicStatementSchedule . BASIC_STATEMENT ::= SCHEDULE_PHRASE ";" ;
BEbasicStatementSchedule . BASIC_STATEMENT ::= SCHEDULE_PHRASE SCHEDULE_CONTROL ";" ;
BFbasicStatementSignal . BASIC_STATEMENT ::= SIGNAL_CLAUSE ";" ;
BGbasicStatementSend . BASIC_STATEMENT ::= "SEND" "ERROR" SUBSCRIPT ";" ;
BHbasicStatementOn . BASIC_STATEMENT ::= ON_CLAUSE ";" ;
BIbasicStatementOnAndSignal . BASIC_STATEMENT ::= ON_CLAUSE "AND" SIGNAL_CLAUSE ";" ;
BJbasicStatementOff . BASIC_STATEMENT ::= "OFF" "ERROR" SUBSCRIPT ";" ;
BKbasicStatementPercentMacro . BASIC_STATEMENT ::= PERCENT_MACRO_NAME ";" ;
BLbasicStatementPercentMacro . BASIC_STATEMENT ::= PERCENT_MACRO_HEAD PERCENT_MACRO_ARG ")" ";" ;
AAon_phrase . ON_PHRASE ::= "ON" "ERROR" SUBSCRIPT ;
AAon_clause . ON_CLAUSE ::= "ON" "ERROR" SUBSCRIPT "SYSTEM" ;
ABon_clause . ON_CLAUSE ::= "ON" "ERROR" SUBSCRIPT "IGNORE" ;
AAlabel_definition . LABEL_DEFINITION ::= LABEL ":" ;
AAcall_key . CALL_KEY ::= "CALL" LABEL_VAR ;
AAassign . ASSIGN ::= "ASSIGN" ;
AAcall_assign_list . CALL_ASSIGN_LIST ::= VARIABLE ;
ABcall_assign_list . CALL_ASSIGN_LIST ::= CALL_ASSIGN_LIST "," VARIABLE ;
AAdoGroupHead . DO_GROUP_HEAD ::= "DO" ";" ;
ABdoGroupHeadFor . DO_GROUP_HEAD ::= "DO" FOR_LIST ";" ;
ACdoGroupHeadForWhile . DO_GROUP_HEAD ::= "DO" FOR_LIST WHILE_CLAUSE ";" ;
ADdoGroupHeadWhile . DO_GROUP_HEAD ::= "DO" WHILE_CLAUSE ";" ;
AEdoGroupHeadCase . DO_GROUP_HEAD ::= "DO" "CASE" ARITH_EXP ";" ;
AFdoGroupHeadCaseElse . DO_GROUP_HEAD ::= CASE_ELSE STATEMENT ;
AGdoGroupHeadStatement . DO_GROUP_HEAD ::= DO_GROUP_HEAD ANY_STATEMENT ;
AHdoGroupHeadTemporaryStatement . DO_GROUP_HEAD ::= DO_GROUP_HEAD TEMPORARY_STMT ;
AAending . ENDING ::= "END" ;
ABending . ENDING ::= "END" LABEL ;
ACending . ENDING ::= LABEL_DEFINITION ENDING ;
AAread_key . READ_KEY ::= "READ" "(" NUMBER ")" ;
ABread_key . READ_KEY ::= "READALL" "(" NUMBER ")" ;
AAwrite_key . WRITE_KEY ::= "WRITE" "(" NUMBER ")" ;
AAread_phrase . READ_PHRASE ::= READ_KEY READ_ARG ;
ABread_phrase . READ_PHRASE ::= READ_PHRASE "," READ_ARG ;
AAwrite_phrase . WRITE_PHRASE ::= WRITE_KEY WRITE_ARG ;
ABwrite_phrase . WRITE_PHRASE ::= WRITE_PHRASE "," WRITE_ARG ;
AAread_arg . READ_ARG ::= VARIABLE ;
ABread_arg . READ_ARG ::= IO_CONTROL ;
AAwrite_arg . WRITE_ARG ::= EXPRESSION ;
ABwrite_arg . WRITE_ARG ::= IO_CONTROL ;
AAfile_exp . FILE_EXP ::= FILE_HEAD "," ARITH_EXP ")" ;
AAfile_head . FILE_HEAD ::= "FILE" "(" NUMBER ;
AAio_control . IO_CONTROL ::= "SKIP" "(" ARITH_EXP ")" ;
ABio_control . IO_CONTROL ::= "TAB" "(" ARITH_EXP ")" ;
ACio_control . IO_CONTROL ::= "COLUMN" "(" ARITH_EXP ")" ;
ADio_control . IO_CONTROL ::= "LINE" "(" ARITH_EXP ")" ;
AEio_control . IO_CONTROL ::= "PAGE" "(" ARITH_EXP ")" ;
AAwait_key . WAIT_KEY ::= "WAIT" ;
AAterminator . TERMINATOR ::= "TERMINATE" ;
ABterminator . TERMINATOR ::= "CANCEL" ;
AAterminate_list . TERMINATE_LIST ::= LABEL_VAR ;
ABterminate_list . TERMINATE_LIST ::= TERMINATE_LIST "," LABEL_VAR ;
AAschedule_head . SCHEDULE_HEAD ::= "SCHEDULE" LABEL_VAR ;
ABschedule_head . SCHEDULE_HEAD ::= SCHEDULE_HEAD "AT" ARITH_EXP ;
ACschedule_head . SCHEDULE_HEAD ::= SCHEDULE_HEAD "IN" ARITH_EXP ;
ADschedule_head . SCHEDULE_HEAD ::= SCHEDULE_HEAD "ON" BIT_EXP ;
AAschedule_phrase . SCHEDULE_PHRASE ::= SCHEDULE_HEAD ;
ABschedule_phrase . SCHEDULE_PHRASE ::= SCHEDULE_HEAD "PRIORITY" "(" ARITH_EXP ")" ;
ACschedule_phrase . SCHEDULE_PHRASE ::= SCHEDULE_PHRASE "DEPENDENT" ;
AAschedule_control . SCHEDULE_CONTROL ::= STOPPING ;
ABschedule_control . SCHEDULE_CONTROL ::= TIMING ;
ACschedule_control . SCHEDULE_CONTROL ::= TIMING STOPPING ;
AAtiming . TIMING ::= REPEAT "EVERY" ARITH_EXP ;
ABtiming . TIMING ::= REPEAT "AFTER" ARITH_EXP ;
ACtiming . TIMING ::= REPEAT ;
AArepeat . REPEAT ::= "," "REPEAT" ;
AAstopping . STOPPING ::= WHILE_KEY ARITH_EXP ;
ABstopping . STOPPING ::= WHILE_KEY BIT_EXP ;
AAsignal_clause . SIGNAL_CLAUSE ::= "SET" EVENT_VAR ;
ABsignal_clause . SIGNAL_CLAUSE ::= "RESET" EVENT_VAR ;
ACsignal_clause . SIGNAL_CLAUSE ::= "SIGNAL" EVENT_VAR ;
FNpercent_macro_name . PERCENT_MACRO_NAME ::= "%" IDENTIFIER ;
AApercent_macro_head . PERCENT_MACRO_HEAD ::= PERCENT_MACRO_NAME "(" ;
ABpercent_macro_head . PERCENT_MACRO_HEAD ::= PERCENT_MACRO_HEAD PERCENT_MACRO_ARG "," ;
AApercent_macro_arg . PERCENT_MACRO_ARG ::= NAME_VAR ;
ABpercent_macro_arg . PERCENT_MACRO_ARG ::= CONSTANT ;
AAcase_else . CASE_ELSE ::= "DO" "CASE" ARITH_EXP ";" "ELSE" ;
AAwhileKeyWhile . WHILE_KEY ::= "WHILE" ;
ABwhileKeyUntil . WHILE_KEY ::= "UNTIL" ;
AAwhile_clause . WHILE_CLAUSE ::= WHILE_KEY BIT_EXP ;
ABwhile_clause . WHILE_CLAUSE ::= WHILE_KEY RELATIONAL_EXP ;
AAfor_list . FOR_LIST ::= FOR_KEY ARITH_EXP ITERATION_CONTROL ;
ABfor_list . FOR_LIST ::= FOR_KEY ITERATION_BODY ;
AAiteration_body . ITERATION_BODY ::= ARITH_EXP ;
ABiteration_body . ITERATION_BODY ::= ITERATION_BODY "," ARITH_EXP ;
AAiteration_controlTo . ITERATION_CONTROL ::= "TO" ARITH_EXP ;
ABiteration_controlToBy . ITERATION_CONTROL ::= "TO" ARITH_EXP "BY" ARITH_EXP ;
AAforKey . FOR_KEY ::= "FOR" ARITH_VAR EQUALS ;
ABforKeyTemporary . FOR_KEY ::= "FOR" "TEMPORARY" IDENTIFIER "=" ;
AAtemporary_stmt . TEMPORARY_STMT ::= "TEMPORARY" DECLARE_BODY ";" ;
AAdeclare_body . DECLARE_BODY ::= DECLARATION_LIST ;
ABdeclare_body . DECLARE_BODY ::= ATTRIBUTES "," DECLARATION_LIST ;
AAdeclaration_list . DECLARATION_LIST ::= DECLARATION ;
ABdeclaration_list . DECLARATION_LIST ::= DCL_LIST_COMMA DECLARATION ;
AAconstant . CONSTANT ::= NUMBER ;
ABconstant . CONSTANT ::= COMPOUND_NUMBER ;
ACconstant . CONSTANT ::= BIT_CONST ;
ADconstant . CONSTANT ::= CHAR_CONST ;
AAattributes . ATTRIBUTES ::= ARRAY_SPEC TYPE_AND_MINOR_ATTR ;
ABattributes . ATTRIBUTES ::= ARRAY_SPEC ;
ACattributes . ATTRIBUTES ::= TYPE_AND_MINOR_ATTR ;
AAarray_spec . ARRAY_SPEC ::= ARRAY_HEAD LITERAL_EXP_OR_STAR ")" ;
ABarray_spec . ARRAY_SPEC ::= "FUNCTION" ;
ACarray_spec . ARRAY_SPEC ::= "PROCEDURE" ;
ADarray_spec . ARRAY_SPEC ::= "PROGRAM" ;
AEarray_spec . ARRAY_SPEC ::= "TASK" ;
AAarray_head . ARRAY_HEAD ::= "ARRAY" "(" ;
ABarray_head . ARRAY_HEAD ::= ARRAY_HEAD LITERAL_EXP_OR_STAR "," ;
AAtype_and_minor_attr . TYPE_AND_MINOR_ATTR ::= TYPE_SPEC ;
ABtype_and_minor_attr . TYPE_AND_MINOR_ATTR ::= TYPE_SPEC MINOR_ATTR_LIST ;
ACtype_and_minor_attr . TYPE_AND_MINOR_ATTR ::= MINOR_ATTR_LIST ;
AAminor_attr_list . MINOR_ATTR_LIST ::= MINOR_ATTRIBUTE ;
ABminor_attr_list . MINOR_ATTR_LIST ::= MINOR_ATTR_LIST MINOR_ATTRIBUTE ;
AAminor_attribute . MINOR_ATTRIBUTE ::= "STATIC" ;
ABminor_attribute . MINOR_ATTRIBUTE ::= "AUTOMATIC" ;
ACminor_attribute . MINOR_ATTRIBUTE ::= "DENSE" ;
ADminor_attribute . MINOR_ATTRIBUTE ::= "ALIGNED" ;
AEminor_attribute . MINOR_ATTRIBUTE ::= "ACCESS" ;
AFminor_attribute . MINOR_ATTRIBUTE ::= "LOCK" "(" LITERAL_EXP_OR_STAR ")" ;
AGminor_attribute . MINOR_ATTRIBUTE ::= "REMOTE" ;
AHminor_attribute . MINOR_ATTRIBUTE ::= "RIGID" ;
AIminor_attribute . MINOR_ATTRIBUTE ::= INIT_OR_CONST_HEAD REPEATED_CONSTANT ")" ;
AJminor_attribute . MINOR_ATTRIBUTE ::= INIT_OR_CONST_HEAD "*" ")" ;
AKminor_attribute . MINOR_ATTRIBUTE ::= "LATCHED" ;
ALminor_attribute . MINOR_ATTRIBUTE ::= "NONHAL" "(" LEVEL ")" ;
AAinit_or_const_headInitial . INIT_OR_CONST_HEAD ::= "INITIAL" "(" ;
ABinit_or_const_headConstant . INIT_OR_CONST_HEAD ::= "CONSTANT" "(" ;
ACinit_or_const_headRepeatedConstant . INIT_OR_CONST_HEAD ::= INIT_OR_CONST_HEAD REPEATED_CONSTANT "," ;
AArepeated_constant . REPEATED_CONSTANT ::= EXPRESSION ;
ABrepeated_constant . REPEATED_CONSTANT ::= REPEAT_HEAD VARIABLE ;
ACrepeated_constant . REPEATED_CONSTANT ::= REPEAT_HEAD CONSTANT ;
ADrepeated_constant . REPEATED_CONSTANT ::= NESTED_REPEAT_HEAD REPEATED_CONSTANT ")" ;
AErepeated_constant . REPEATED_CONSTANT ::= REPEAT_HEAD ;
AArepeat_head . REPEAT_HEAD ::= ARITH_EXP "#" SIMPLE_NUMBER ;
AAnested_repeat_head . NESTED_REPEAT_HEAD ::= REPEAT_HEAD "(" ;
ABnested_repeat_head . NESTED_REPEAT_HEAD ::= NESTED_REPEAT_HEAD REPEATED_CONSTANT "," ;
AAdeclaration . DECLARATION ::= NAME_ID ;
ABdeclaration . DECLARATION ::= NAME_ID ATTRIBUTES ;
AAname_id . NAME_ID ::= IDENTIFIER ;
ABnameIdName . NAME_ID ::= IDENTIFIER "NAME" ;
ACnameIdBit . NAME_ID ::= BIT_ID ;
ADnameIdChar . NAME_ID ::= CHAR_ID ;
AAdcl_list_comma . DCL_LIST_COMMA ::= DECLARATION_LIST "," ;
AAliteralExp . LITERAL_EXP_OR_STAR ::= ARITH_EXP ;
ABliteralStar . LITERAL_EXP_OR_STAR ::= "*" ;
AAtypeSpecStruct . TYPE_SPEC ::= STRUCT_SPEC ;
ABtypeSpecBit . TYPE_SPEC ::= BIT_SPEC ;
ACtypeSpecChar . TYPE_SPEC ::= CHAR_SPEC ;
ADtypeSpecArith . TYPE_SPEC ::= ARITH_SPEC ;
AEtypeSpecEvent . TYPE_SPEC ::= "EVENT" ;
AAbitSpecBoolean . BIT_SPEC ::= "BOOLEAN" ;
ABbitSpecBoolean . BIT_SPEC ::= "BIT" "(" LITERAL_EXP_OR_STAR ")" ;
AAchar_spec . CHAR_SPEC ::= "CHARACTER" "(" LITERAL_EXP_OR_STAR ")" ;
AAstruct_spec . STRUCT_SPEC ::= STRUCT_TEMPLATE STRUCT_SPEC_BODY ;
AAstruct_spec_body . STRUCT_SPEC_BODY ::= "-" "STRUCTURE" ;
ABstruct_spec_body . STRUCT_SPEC_BODY ::= STRUCT_SPEC_HEAD LITERAL_EXP_OR_STAR ")" ;
FMstruct_template . STRUCT_TEMPLATE ::= STRUCTURE_ID ;
AAstruct_spec_head . STRUCT_SPEC_HEAD ::= "-" "STRUCTURE" "(" ;
AAarith_spec . ARITH_SPEC ::= PREC_SPEC ;
ABarith_spec . ARITH_SPEC ::= SQ_DQ_NAME ;
ACarith_spec . ARITH_SPEC ::= SQ_DQ_NAME PREC_SPEC ;
AAsq_dq_name . SQ_DQ_NAME ::= DOUBLY_QUAL_NAME_HEAD LITERAL_EXP_OR_STAR ")" ;
{-
ABsq_dq_name . SQ_DQ_NAME ::= "INTEGER" ;
ACsq_dq_name . SQ_DQ_NAME ::= "SCALAR" ;
ADsq_dq_name . SQ_DQ_NAME ::= "VECTOR" ;
AEsq_dq_name . SQ_DQ_NAME ::= "MATRIX" ;
-}
ABsq_dq_name . SQ_DQ_NAME ::= ARITH_CONV ;
AAdoublyQualNameHeadVector . DOUBLY_QUAL_NAME_HEAD ::= "VECTOR" "(" ;
ABdoublyQualNameHeadMatrix . DOUBLY_QUAL_NAME_HEAD ::= "MATRIX" "(" LITERAL_EXP_OR_STAR "," ;

--------------------------------------------------------------------------
-- Here are additional rules needed for top-level block types (like 
-- program, procedure, and function).
AAcompilation . COMPILATION ::= COMPILE_LIST ;
AAcompile_list . COMPILE_LIST ::= BLOCK_DEFINITION ;
ABcompile_list . COMPILE_LIST ::= COMPILE_LIST BLOCK_DEFINITION ;
AAblock_definition . BLOCK_DEFINITION ::= BLOCK_STMT CLOSING ";" ;
ABblock_definition . BLOCK_DEFINITION ::= BLOCK_STMT BLOCK_BODY CLOSING ";" ;
AAblock_stmt . BLOCK_STMT ::= BLOCK_STMT_TOP ";" ;
AAblockTopAccess . BLOCK_STMT_TOP ::= BLOCK_STMT_TOP "ACCESS" ;
ABblockTopRigid . BLOCK_STMT_TOP ::= BLOCK_STMT_TOP "RIGID" ;
ACblockTopHead . BLOCK_STMT_TOP ::= BLOCK_STMT_HEAD ;
ADblockTopExclusive . BLOCK_STMT_TOP ::= BLOCK_STMT_HEAD "EXCLUSIVE" ;
AEblockTopReentrant . BLOCK_STMT_TOP ::= BLOCK_STMT_HEAD "REENTRANT" ;
AAblockHeadProgram . BLOCK_STMT_HEAD ::= LABEL_EXTERNAL "PROGRAM" ;
ABblockHeadCompool . BLOCK_STMT_HEAD ::= LABEL_EXTERNAL "COMPOOL" ;
ACblockHeadTask . BLOCK_STMT_HEAD ::= LABEL_DEFINITION "TASK" ;
ADblockHeadUpdate . BLOCK_STMT_HEAD ::= LABEL_DEFINITION "UPDATE" ;
AEblockHeadUpdatead . BLOCK_STMT_HEAD ::= "UPDATE" ;
AFblockHeadFunction . BLOCK_STMT_HEAD ::= FUNCTION_NAME ;
AGblockHeadFunction . BLOCK_STMT_HEAD ::= FUNCTION_NAME FUNC_STMT_BODY ;
AHblockHeadProcedure . BLOCK_STMT_HEAD ::= PROCEDURE_NAME ;
AIblockHeadProcedure . BLOCK_STMT_HEAD ::= PROCEDURE_NAME PROC_STMT_BODY ;
AAlabel_external . LABEL_EXTERNAL ::= LABEL_DEFINITION ;
ABlabel_external . LABEL_EXTERNAL ::= LABEL_DEFINITION "EXTERNAL" ;
AAclosing . CLOSING ::= "CLOSE" ;
ABclosing . CLOSING ::= "CLOSE" LABEL ;
ACclosing . CLOSING ::= LABEL_DEFINITION CLOSING ;
ABblock_body . BLOCK_BODY ::= DECLARE_GROUP ;
ADblock_body . BLOCK_BODY ::= ANY_STATEMENT ;
ACblock_body . BLOCK_BODY ::= BLOCK_BODY ANY_STATEMENT ;
AAfunction_name . FUNCTION_NAME ::= LABEL_EXTERNAL "FUNCTION" ;
AAprocedure_name . PROCEDURE_NAME ::= LABEL_EXTERNAL "PROCEDURE" ;
AAfunc_stmt_body . FUNC_STMT_BODY ::= PARAMETER_LIST ;
ABfunc_stmt_body . FUNC_STMT_BODY ::= TYPE_SPEC ;
ACfunc_stmt_body . FUNC_STMT_BODY ::= PARAMETER_LIST TYPE_SPEC ;
AAproc_stmt_body . PROC_STMT_BODY ::= PARAMETER_LIST ;
ABproc_stmt_body . PROC_STMT_BODY ::= ASSIGN_LIST ;
ACproc_stmt_body . PROC_STMT_BODY ::= PARAMETER_LIST ASSIGN_LIST ;
AAdeclare_group . DECLARE_GROUP ::= DECLARE_ELEMENT ;
ABdeclare_group . DECLARE_GROUP ::= DECLARE_GROUP DECLARE_ELEMENT ;
AAdeclare_element . DECLARE_ELEMENT ::= DECLARE_STATEMENT ;
ABdeclare_element . DECLARE_ELEMENT ::= REPLACE_STMT ";" ;
ACdeclare_element . DECLARE_ELEMENT ::= STRUCTURE_STMT ;
ADdeclare_element . DECLARE_ELEMENT ::= "EQUATE" "EXTERNAL" IDENTIFIER "TO" VARIABLE ";" ;
AAparameter_list . PARAMETER_LIST ::= PARAMETER_HEAD IDENTIFIER ")" ;
AAparameter_head . PARAMETER_HEAD ::= "(" ;
ABparameter_head . PARAMETER_HEAD ::= PARAMETER_HEAD IDENTIFIER "," ;
AAdeclare_statement . DECLARE_STATEMENT ::= "DECLARE" DECLARE_BODY ";" ;
AAassign_list . ASSIGN_LIST ::= ASSIGN PARAMETER_LIST ;
FQtext . TEXT ::= TextToken ;
AAreplace_stmt . REPLACE_STMT ::= "REPLACE" REPLACE_HEAD "BY" TEXT ;
AAreplace_head . REPLACE_HEAD ::= IDENTIFIER ;
ABreplace_head . REPLACE_HEAD ::= IDENTIFIER "(" ARG_LIST ")" ;
AAarg_list . ARG_LIST ::= IDENTIFIER ;
ABarg_list . ARG_LIST ::= ARG_LIST "," IDENTIFIER ;
AAstructure_stmt . STRUCTURE_STMT ::= "STRUCTURE" STRUCT_STMT_HEAD STRUCT_STMT_TAIL ;
AAstruct_stmt_head . STRUCT_STMT_HEAD ::= IDENTIFIER ":" LEVEL ;
ABstruct_stmt_head . STRUCT_STMT_HEAD ::= IDENTIFIER MINOR_ATTR_LIST ":" LEVEL ;
ACstruct_stmt_head . STRUCT_STMT_HEAD ::= STRUCT_STMT_HEAD DECLARATION "," LEVEL ;
AAstruct_stmt_tail . STRUCT_STMT_TAIL ::= DECLARATION ";" ;

--------------------------------------------------------------------------
-- Inline types (functions, procedures, ...).  I think that all of the 
-- rules relating to the parents of inline types in the original 
-- BNF were wrong.  In all cases, the inline definitions had been 
-- children of terms of expressions, whereas obviously they are types
-- of statements and not components of expressions.
AZstatement . STATEMENT ::= INLINE_DEFINITION ;
AAinline_definition . INLINE_DEFINITION ::= ARITH_INLINE ;
ABinline_definition . INLINE_DEFINITION ::= BIT_INLINE ;
ACinline_definition . INLINE_DEFINITION ::= CHAR_INLINE ;
ADinline_definition . INLINE_DEFINITION ::= STRUCTURE_EXP ;
-- Was PRIMARY rather rather than ARITH_INLINE.
ACprimary . ARITH_INLINE ::= ARITH_INLINE_DEF CLOSING ";" ;
AZprimary . ARITH_INLINE ::= ARITH_INLINE_DEF BLOCK_BODY CLOSING ";" ;
AAarith_inline_def . ARITH_INLINE_DEF ::= "FUNCTION" ARITH_SPEC ";" ;
ABarith_inline_def . ARITH_INLINE_DEF ::= "FUNCTION" ";" ;
-- Was BIT_PRIM rather than BIT_INLINE.
AGbit_prim . BIT_INLINE ::= BIT_INLINE_DEF CLOSING ";" ;
AZbit_prim . BIT_INLINE ::= BIT_INLINE_DEF BLOCK_BODY CLOSING ";" ;
AAbit_inline_def . BIT_INLINE_DEF ::= "FUNCTION" BIT_SPEC ";" ;
-- Was CHAR_PRIM rather than CHAR_INLINE.
ADchar_prim . CHAR_INLINE ::= CHAR_INLINE_DEF CLOSING ";" ;
AZchar_prim . CHAR_INLINE ::= CHAR_INLINE_DEF BLOCK_BODY CLOSING ";" ;
AAchar_inline_def . CHAR_INLINE_DEF ::= "FUNCTION" CHAR_SPEC ";" ;
ACstructure_exp . STRUCTURE_EXP ::= STRUC_INLINE_DEF CLOSING ";" ;
AEstructure_exp . STRUCTURE_EXP ::= STRUC_INLINE_DEF BLOCK_BODY CLOSING ";" ;
AAstruc_inline_def . STRUC_INLINE_DEF ::= "FUNCTION" STRUCT_SPEC ";" ;

--------------------------------------------------------------------------
-- Some leftovers.
AEprimary . PRIMARY ::= PRE_PRIMARY QUALIFIER ;
ABany_statement . ANY_STATEMENT ::= BLOCK_DEFINITION ;

--------------------------------------------------------------------------
-- The following rules are commented out "permanently" because they  
-- involve NO_ARG_xxxxx_FUNC types, which as far as I know don't exist.
-- But I'll keep them around in case I was wrong and some of these 
-- functions pop up later.
{-
ABstructure_exp . STRUCTURE_EXP ::= MODIFIED_STRUCT_FUNC ;
AAmodified_struct_func . MODIFIED_STRUCT_FUNC ::= NO_ARG_STRUCT_FUNC ;
ACmodified_struct_func . MODIFIED_STRUCT_FUNC ::= NO_ARG_STRUCT_FUNC SUBSCRIPT ;
ABmodified_struct_func . MODIFIED_STRUCT_FUNC ::= QUAL_STRUCT "." NO_ARG_STRUCT_FUNC ;
ADmodified_struct_func . MODIFIED_STRUCT_FUNC ::= QUAL_STRUCT "."  NO_ARG_STRUCT_FUNC SUBSCRIPT ;
ZZnoArgStructFunc. NO_ARG_STRUCT_FUNC ::= EMPTY ;

AFbit_prim . BIT_PRIM ::= MODIFIED_BIT_FUNC ;
AAmodified_bit_func . MODIFIED_BIT_FUNC ::= NO_ARG_BIT_FUNC ;
ACmodified_bit_func . MODIFIED_BIT_FUNC ::= NO_ARG_BIT_FUNC SUBSCRIPT ;
ABmodified_bit_func . MODIFIED_BIT_FUNC ::= QUAL_STRUCT "." NO_ARG_BIT_FUNC ;
ADmodified_bit_func . MODIFIED_BIT_FUNC ::= QUAL_STRUCT "." NO_ARG_BIT_FUNC SUBSCRIPT ;
ZZnoArgBitFunc. NO_ARG_BIT_FUNC ::= EMPTY ;

ACchar_prim . CHAR_PRIM ::= MODIFIED_CHAR_FUNC ;
AAmodified_char_func . MODIFIED_CHAR_FUNC ::= NO_ARG_CHAR_FUNC ;
AAmodified_char_func . MODIFIED_CHAR_FUNC ::= NO_ARG_CHAR_FUNC SUBSCRIPT ;
ABmodified_char_func . MODIFIED_CHAR_FUNC ::= QUAL_STRUCT "." NO_ARG_CHAR_FUNC ;
ABmodified_char_func . MODIFIED_CHAR_FUNC ::= QUAL_STRUCT "."  NO_ARG_CHAR_FUNC SUBSCRIPT ;
ZZnoArgCharFunc. NO_ARG_CHAR_FUNC ::= EMPTY ;

ADname_var . NAME_VAR ::= MODIFIED_BIT_FUNC ;
AEname_var . NAME_VAR ::= MODIFIED_CHAR_FUNC ;
AFname_var . NAME_VAR ::= MODIFIED_STRUCT_FUNC ;
-}

