# Introduction

The "modern" HAL/S compiler's first phase (preprocessing + tokenizating + parsing) concludes with the generation of code in a target-independent intermediate language I call *PALMAT*.  Subsquent compiler phases may then perform machine-independent optimizations on the generated PALMAT and/or convert it to some efficient form for execution (such as a C-language program), or an emulator in the form of a PALMAT virtual machine may directly execute it as-is.

The original HAL/S compilers of the Space Shuttle development effort, HAL/S-360 and HAL/S-FC, had this same overall structure, except with an intermediate language they called *HALMAT*.  I would be happy to be using HALMAT as the intermediate language for the modern assembler, except that (at this writing) there's simply not enough surviving detailed documentation of HALMAT to do so.  My attempt to reconstruct HALMAT from the surviving documentation ultimately failed, but you can read about it [here](HALMAT.md).

So unfortunately, I'm left to reinvent the wheel.  On a positive note, what I was able to learn about HALMAT didn't seem all that user-friendly, and perhaps *PAL*MAT will be slightly friendlier.

# Some Basic Principles

Because of the limitations of memory and CPU speed back in the day, HALMAT was designed with certain contraints aimed at efficiencies we no longer have to worry about as much.  All HALMAT instructions ("operand words") were exactly 32 bits wide, as were all HALMAT "operand words", and each of them consisted of an elaborate collection of bit-fields.  Data, except for certain small datatypes like 16-bit integers or 16-bit bit-arrays, were of necessity stored in tables which the operand words accessed via pointers.

Since the PALMAT-generation portion of the modern HAL/S compiler, which will include an optional interactive PALMAT interpreter, are in the Python language, PALMAT instructions can be considered instead as relatively-friendly Python objects ("dictionaries"), and data can be included directly within PALMAT instructions in many cases rather than being separated from them.  

But these abstract points will probably become clearer when details of PALMAT are discussed below.

# PALMAT File Format

A PALMAT dataset comprising the compiled form of a HAL/S program or portions of HAL/S programs is, as mentioned, stored in the modern compiler and/or interpreter, which are written in Python, as a Python "dictionary".  

For example, the dictionary might have the name `MyProgram`, and might be almost empty, perhaps:

    MyProgram = {
        "SymbolTable" : {},
        "Instructions" : []
    }

(This is just an illustration, written in advance of implementation to demonstrate file formatting, so I don't claim that this is *actually* what the structure would look like.  In fact, as you will see in the next section, it certainly is *not*.  But that doesn't affect the principles being discussed here.)

Since JSON is a common format for exchanging complex data of this nature, `MyProgram` would be saved to an external file (say, "MyProgram.palmat") by the simple expedient of converting it to JSON (which is a text string), and then saving the JSON to the file:

    import json
    f = open("MyProgram.palmat", "w")
    print(json.dumps(MyProgram), file=f)
    f.close()

The result of this operation would be a file MyProgram.palmat that (surprise!) looks like:

    {"SymbolTable": {}, "Instructions": []}

MyProgram.palmat could subsequently be read by some other Python program, and the associated dictionary (say `SavedProgram`) could be constructed by commands like:

    import json
    f = open("MyProgram.palmat", "r")
    SavedProgram = json.loads(f.readline())
    f.close()

While the steps for reading in this file would differ in detail in program languages other than Python, it would still be simplicity itself in any programming language having an available library for reading JSON.  Certainly that's true in C or JavaScript, but I suppose it's probably true of a great many programming languages.  On the other hand, the internal data structures one might wish to use in a C emulator are undoubtedly very different than those provided by whatever library reads the JSON description, whereas in Python the internal data structures and the as-saved data structures are identical.

# Structure of a PALMAT Dictionary

Throughout this section, I'll assume that the Python dictionary generated by compiling our HAL/S source code is simply called `PALMAT`.  All indexes into lists start from 0.

Here is the essential layout of a PALMAT dictionary:

    PALMAT = {
        "scopes" : [ ... ],
        ... less-essential items ...
    }

## The Scopes

The "scopes" array is the memory model, incompassing all identifiers used by the code, such as variables and user-defined function names, as well as the code itself. Each individual scope in the array is the memory model for a specific HAL/S block (such as PROGRAM, FUNCTION, PROCEDURE, ...).  The compiler assigns these blocks unique sequence numbers, starting from 0, as it encounters them, and then appends the scope for that block to `PALMAT["scopes"]`.  `PALMAT["scopes"][0]` is the top-level scope.

Each individual scope is itself a dictionary, and provides links to both the scope of its parent block and to any immediate child blocks.  The code within any HAL/S block has access to the objects declared within its own scope, including temporaries, as well as the objects of the parent, grandparent, and so on, but not the child blocks.

    anyIndividualScope = {
        "parent" : ...,             # The integer index of the parent scope within PALMAT["scopes"], or else None if top level.
        "self" : ...,               # The integer index of this scope within PALMAT["scopes"].
        "children" : [ ... ],       # List of integer indices of immediate child scopes within PALMAT["scopes"]
        "identifiers" : { ... },    # The identifiers declared in the current block, keyed by their names.
        "instructions" : [ ... ]    # The PALMAT instructions for the block.
    }

Note that the entire `PALMAT` object, including `PALMAT["scopes"]`, is formed at compile time.  The logical memory model is not dynamic.  Its structure does not change at runtime.  Only *values* stored in variables (in the "identifiers" dictionary) change at runtime, but the structure of the model is unalterable.

By the way, notice that because the code ("instructions") for a block such as a `DO FOR` are segregated in a different scope from that of the block containing it, the PALMAT code in the parent block treats the code in such a sub-block much like a procedure call, in that it has an instruction the "call" the sub-block, and the exit from the sub-block (if not a `GO TO`) is going to be a return to the parent block.  Yes, there's a slight inefficiency associated with this scheme.

Regarding the elements of the identifiers dictionary, i.e. the variables, constants, nested function definitions, and so on, their most important properties vary by type.  For variables, these are the descriptions of their datatypes and their stored values.  Other, lesser, characteristics may appear in their dictionaries as well.

Consider the following simple HAL/S code:

    MYPROGRAM: PROGRAM;
        DECLARE I INTEGER INITIAL(1), X SCALAR;

        MYFUNCTION: FUNCTION(A, B);
            DECLARE INTEGER A, B;
            DECLARE Y SCALAR;

            ...

        END MYFUNCTION;

        ...

    CLOSE MYPROGRAM;

I'm writing this in advance of implementation, so I'm speculating a bit, but here's what `PALMAT["scopes"]` might look like for this code:

    PALMAT["scopes"] = [
        {
            "parent" : None,        # This is the top level, so there is no parent scope.
            "self" : 0,             # Own index into PALMAT["scopes"].
            "children" : [1],       # There is a single child, the MYPROGRAM program.
            "identifiers" : { 
                "MYPROGRAM" : {
                    "program" : True,
                    "index" : 0,    # Index of its starting location in the "code" array
                }
            }
            "instructions" : [ ]    # There are no global PALMAT instructions ... maybe.
        },
        {                       # This is MYPROGRAM.
            "parent" : 0,
            "self" : 1,
            "children" : [2],   # The only child is MYFUNCTION.
            "identifiers" : {
                "I" : {
                    "integer" : True,
                    "value" : 1
                },
                "X" : {
                    "scalar" : True,
                    "value" : None 
                },
                "MYFUNCTION" : {
                    "function" : True,
                    "index" : ...,
                    "parameters" : ["A", "B"]
                }
            }
            "instructions" : [ ... ]
        },
        {                       # This is MYFUNCTION
            "parent" : 1,
            "self" : 2,
            "children" : [],
            "identifiers" : {
                "A" : {
                    "integer" : True,
                    "value" : None,
                    "parameter" : True
                },
                "B" : {
                    "integer" : True,
                    "value" : None,
                    "parameter" : True
                },
                "Y" : {
                    "scalar" : True,
                    "value" : None
                }
            }
            "instructions" : [ ... ]
        }
    ]

Notice the extra keys `"parameter"` for variables `B` and `Y`.  I don't know whether these will exist after implementation, but I've thrown them in here as examples of additional metadata that can be provide by the memory model.  In this case, they're intended to indicate that the variables in question are parameters of the `MYFUNCTION` function, and hence there may be limitations on what can be done with them that wouldn't apply to normal declarations.

As an example of usage, imagine that `MYFUNCTION()` were called during code emulation, there would be a PALMAT instruction upon entry to the `MYFUNCTION` block that set the current block number to 2, perhaps setting some variable in the emulator virtual machine like so: `scope = PALMAT["scopes"]`.  Once `scope` is available, the entire hierarchical memory model accessible by the block is not fully set up.  

Actually, that's not *entirely* true, since in a HAL/S declaration like 

    DECLARE I INTEGER INITIAL(1);

the initialization is performed only the first time that position in the code is reached, and not on each occasion the block containing the declaration is entered.  In analogy to the C language, all variables declared in functions or procedures are by default `static`, and retain their last values from one invocation of the function or procedure to the next.  In HAL/S, if you wanted the initialization to occur upon each entry (to be non-`static` in a C sense), you'd instead say

    DECLARE I INTEGER INITIAL(1) AUTOMATIC;

Thus the emulator would have to perform a little more work upon entry to such a block than just setting `scope` properly.

TBD

## The Source-Code File List

The source-code file list,

    PALMAT["SourceCodeFiles"]

is a one-dimensional array listing all of the filenames of source-code file read into the processor.  They appear in the order encountered, but there is no logical need for them to do so.

## The StructureTemplate List

The structure-template list,

    PALMAT["StructureTemplates"]

is a list of all templates needed from the structure-template library.  The format of the entries is TBD.

## The Raw Source-Code List

The raw source-code list,

    PALMAT["RawSourceCode"]

is a one-dimensional array of all HAL/S source code lines, unpreprocessed, in the order the preprocessor encounters them.  Each entry in the array is a dictionary with the following fields:

    {
        "code" : ...,       # The source-code line, as a string, exactly as 
                            # read from its file.
        "fileNum" : ...,    # The numerical index of the source-code file 
                            # within PALMAT["SourceCodeFiles"].
        "index" : ...,      # The line-number within the source file, 
                            # starting from 1.
        "template" : ...,   # (Usually not present.) For "D INCLUDE STRUCTURE"
                            # directives, index into PALMAT["StructureTemplates"]
        TBD
    }

## The Preprocessed Source-Code List

This list,

    PALMAT["PreprocessedSource"]

is a one-dimensional array of all source-code emitted from the preprocessor and input into the compiler.  Note that any given preprocessed line may correspond to a single raw line, a combination of several raw lines, a portion of a raw line, a line generated entirely by the preprocessor, etc.  Each entry in the array is a dictionary with the following fields:

    {
        "code" : ...,       # The full text of the line of code.
        TBD

## The Instruction List

The instruction list,

    PALMAT["Instructions"]

is a one-dimensional array in which each source line has been converted into zero or more PALMAT instructions, and stored in the array in the order in which the compiler encountered these lines of code.  Each PALMAT instruction itself takes the form of a Python dictionary.  Thus `PALMAT["Instructions"]` would look something like the following:

    [
      { ... }, # First PALMAT instruction generated for 1st HAL/S source line
        ...,
      { ... }, # Last PALMAT instruction generated for 1st HAL/S source line
      { ... }, # First PALMAT instruction generated for 2nd HAL/S source line
        ...,
      { ... }  # Last PALMAT instruction generated for last HAL/S source line
    ]

