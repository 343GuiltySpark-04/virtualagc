#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Copyright:  None - the author (Ron Burkey) declares this software to
            be in the Public Domain, with no rights reserved.
Filename:   executePALMAT.py
Requires:   Python 3.7 or later.
Purpose:    This is a VM (admittedly, and inefficient one) for 
            running PALMAT code generated by compilation of 
            HAL/S source code.
History:    2023-01-01 RSB  Began.
"""

import re
import math
import random
import time
import copy
from decimal import Decimal, ROUND_HALF_UP

timeOrigin = 0
# This function is called once at startup, in order to set the 
# time origin properaly.  If not, then the time functions will
# probably work, but they'll be of very low resolution since
# the time measurements (with nanosecond resolution) will be
# relative to 1970-01-01 00:00:00 UTC rather than relative to
# some point in the very recent past.
def setupExecutePALMAT():
    global timeOrigin;
    timeOrigin = time.time_ns()

# This is a replacement for Python's round() function.
# Python's round() function uses a method apparently called 
# "banker's rounding", in which everything rounds just as you'd
# expect except that numbers which are *exactly* integer+1/2
# round (from my perspective) very oddly: they round to the
# nearest *even* integer.  For example, 1.5 and 2.5 both round
# to 2, 3.5 and 4.5 both round to 4, and so on. As far as HAL/S
# is concerned, the documentation isn't 100% explicit in this
# regard, but the explanations on p. 3-4 (PDF p. 42) of 
# "Programming in HAL/S" make it pretty clear that banker's 
# rounding is *not* what was envisaged; 0.5 is supposed to round
# to 1, 3.5 is supposed to round to 4.  (What's left undiscussed
# are cases like -1.5 or -2.5.  Oh well!)  Therefore, the following
# function is provided to account for rounding that's closer to
# what's needed.  I think!
def hround(x):
    return int(Decimal(x).to_integral_value(rounding=ROUND_HALF_UP))

# Categorization of the HAL/S built-in functions by the number of arguments
# they take.
builtIns = [
    # No arguments
    ["CLOCKTIME", "DATE", "ERRGRP", "ERRNUM", "PRIO", "RANDOM", "RANDOMG", 
     "RUNTIME"],
    # One argument
    ["ABS", "CEILING", "FLOOR", "ODD", "ROUND", "SIGN", "SIGNUM", "TRUNCATE",
     "ARCCOS", "ARCCOSH", "ARCSIN", "ARCSINH", "ARCTAN", "ARCTANH", "COS",
     "COSH", "EXP", "LOG", "SIN", "SINH", "SQRT", "TAN", "TANH",
     "ABVAL", "DET", "INVERSE", "TRACE", "TRANSPOSE", "UNIT",
     "MAX", "MIN", "PROD", "SUM", "LENGTH", "TRIM", "NEXTIME", "SIZE"],
    # Two arguments
    ["DIV", "MOD", "REMAINDER", "ARCTAN2", "XOR", "INDEX", "LJUST", "RJUST",
     "SHL", "SHR"],
    # Three arguments
    ["MIDVAL"]
]

# Returns a tuple consisting of a new scope number and
# offset into the scope, or else returns None if not found.
# The premise is the that instructionDict has a key/value
# pair of the form { instructionName: s }, where s is either
# an ordered pair of a desired new scope index and offset,
# or else is an identifier giving the name of an accessible
# label.
def jump(PALMAT, scopeNumber, instructionDict, instructionName):
    #print("*", scopeNumber, instructionDict, instructionName)
    si, s = instructionDict[instructionName]
    if isinstance(s, str):
        attributes = PALMAT["scopes"][si]["identifiers"][s]
        if attributes == None or "label" not in attributes:
            print("\tCannot find target label", s)
            return None
        # The following line updates the PALMAT instruction
        # (goto or iffalse or whatever) in-place, so that
        # instead of holding the symbolic label that's the
        # target of the jump, it holds a list with two elements
        # that are the index of the scope and the offset
        # into the scope for the target label.  This isn't
        # 100% necessary; it's just there to slightly improve
        # the speed at which the jump can be made subsequently,
        # and might want to be handled differently in some 
        # other implementation.  (Such as making all of these
        # corrections when the PALMAT is loaded, or perhaps
        # having a separate post-compilation processing step
        # that corrects them all.  It's nice to have the 
        # labels as long as you can, though, in case you need
        # to refer to them for some reason.  Here we save the
        # symbolic label in a new key, which accomplishes the
        # same thing, basically.
        instructionDict["symbolicLabel"] = instructionDict[instructionName]
        instructionDict[instructionName] = attributes["label"]
    s = instructionDict[instructionName]
    return tuple(s)

# Convert a stringified HAL/S number (i.e., an INTEGER or SCALAR presented
# as a string, possibly with B, H, or E type exponents) into a Python
# float.
def stringifiedToFloat(stringifiedNumber):
    multiplier = 1.0
    # Recall that HAL/S literal numbers can include modifiers like
    # "B-12" or "H7" in addition to the usual "E23".  Python
    # has no knowledge of these additional funky modifiers, so
    # we have to handle them explicitly.  Unfortunately this 
    # can make the numerical version inexact compared to the 
    # stringified version, and not inexact in the same way as 
    # the original IBM 360 or AP-101S representations were. 
    # At some point I'll probably make the compiler do this work
    # for the sake of efficiency, but right now I'm going for 
    # correctness and leaving efficiency optimizations for later.
    while True:
        match = re.search("[EBH][-]?[0-9]+$", stringifiedNumber)
        if match == None:
            break
        modifier = match.group()
        stringifiedNumber = stringifiedNumber[:match.span()[0]]
        if modifier[0] == "E":
            multiplier *= 10 ** (int(modifier[1:]))
        elif modifier[0] == "B":
            multiplier *= 2 ** (int(modifier[1:]))
        else: # modifier[0] == "H":
            multiplier *= 16 ** (int(modifier[1:]))
    return float(stringifiedNumber) * multiplier

# Create a PALMAT for a new process/thread.
instantiationNumber = 0
def clonePALMAT(rawPALMAT):
    global instantiationNumber
    instantiationNumber += 1
    scopeIndex = 0
    
    # For the specified scope, make sure its identifiers are a deep copy
    # rather than a shallow copy.  Except for COMPOOLs.
    def deepcopyDescendents(scopeIndex):
        rawScope = rawPALMAT["scopes"][scopeIndex]
        scope = PALMAT["scopes"][scopeIndex]
        if rawScope["type"] != "compool":
            scope["identifiers"] = copy.deepcopy(rawScope["identifiers"])
        for childIndex in scope["children"]:
            deepcopyDescendents(childIndex)
    
    # After the following operation, both PALMAT and PALMAT["scopes"] are
    # entirely new, but each of the individual scopes PALMAT["scopes"][i]
    # is linked to the same object as rawPALMAT["scopes"][i]. So this is 
    # good for everything other than the "identifiers" field at scopeIndex
    # and its descendents.
    PALMAT = { 
        "scopes": [],
        "instantiation": instantiationNumber
        }
    for scope in rawPALMAT["scopes"]:
        PALMAT["scopes"].append(copy.copy(scope))
    # Now correct the shallowly-copied indentifiers to deep copies where needed.
    deepcopyDescendents(scopeIndex)
    return PALMAT

# Get a subscripted value from an object.  At present, this works only if the 
# subscripts are all numbers.  Returns None on error.
def subscripted(object, subscripts):
    for i in range(len(subscripts)):
        subscript = hround(subscripts[i])
        try:
            # Recall that HAL/S subscripts start from 1, while Python 
            # starts from 0.
            object = object[subscript-1]
        except:
            print("\tSubscript does not exist in object.")
            return None
    return copy.deepcopy(object)

# If this function returns, which in principle it might not if executing
# an actual flight program, it returns the current computation stack.
# That would normally be empty if full statements had been executed.
# However, this allow executing (say) just an expression without popping
# the value from the stack at the end, which is useful for the compiler
# since it can then use it to compute things like INITIAL(...) or 
# CONSTANT(...) for DECLARE statements.  If there is failure, for example
# the use of an unimplemented built-in function or referencing an 
# uninitialized variable, then None is returned instead.
def executePALMAT(rawPALMAT, pcScope=0, pcOffset=0, newInstantiation=False, \
                  trace=False, indent=0):
    if newInstantiation:
        PALMAT = clonePALMAT(rawPALMAT)
    else:
        PALMAT = rawPALMAT
    scopes = PALMAT["scopes"]
    scopeNumber = pcScope
    instructionIndex = pcOffset
    scope = scopes[scopeNumber]
    scope0 = scopes[0]
    computationStack = []
    while instructionIndex < len(scope["instructions"]):
        identifiers = scope["identifiers"]
        instructions = scope["instructions"]
        instruction = instructions[instructionIndex]
        if "subscripts" in scope0 and "fetch" not in instruction and \
                "fetchp" not in instruction:
            print("\tImplementation error, subscript(s) without variable")
            return None
        if "subscripts" in scope0:
            subscripts = scope0.pop("subscripts")
        else:
            subscripts = []
        instructionIndex += 1
        if trace:
            print("\tTRACE:  ", computationStack, instruction)
        stackSize = len(computationStack)
        if "debug" in instruction:
            pass
        elif "string" in instruction:
            computationStack.append(instruction["string"])
        elif "boolean" in instruction:
            computationStack.append(instruction["boolean"])
        elif "number" in instruction:
            computationStack.append(stringifiedToFloat(instruction["number"]))
        elif "bitarray" in instruction:
            computationStack.append(stringifiedToFloat(instruction["bitarray"]))
        elif "+><" in instruction:
            si, identifier = instruction["+><"]
            identifier = "^" + identifier + "^"
            if stackSize < 2:
                print("\tImplementation error, not enough operands for '+><'.")
                return None
            operand1 = computationStack.pop()
            negativeIncrement = (operand1 < 0)
            operand2 = computationStack[-1]
            attributes = PALMAT["scopes"][si]["identifiers"][identifier]
            if attributes == None:
                print("\tImplementation error, variable %s not found." \
                      % identifier[1:-1])
                return None
            if "integer" not in attributes and "scalar" not in attributes:
                print("\tImplementation error in '+><': Not a number.")
                return None
            if "value" not in attributes:
                print("\tImplementation error in '+><': Uninitialized variable.")
                return None
            operand1 += attributes["value"]
            if "integer" in attributes:
                attributes["value"] = hround(operand1)
            else:
                attributes["value"] = operand1
            if negativeIncrement:
                computationStack[-1] = (operand1 < operand2)
            else:
                computationStack[-1] = (operand1 > operand2)
        elif "sentinel" in instruction:
            computationStack.append({"sentinel"})
        elif "operator" in instruction:
            operator = instruction["operator"]
            if False:
                pass
            elif operator == "#":
                if stackSize < 2:
                    print(("Implementation error, not enough operands " + \
                          "for operator \"%s\"") % operator)
                    return None
                operand1 = computationStack.pop()
                operand2 = hround(computationStack.pop())
                while operand2 > 0:
                    computationStack.append(operand1)
            elif operator == "subscripts":
                subscripts = []
                while True:
                    value = computationStack.pop()
                    if value == {"sentinel"}:
                        break
                    subscripts.append(value)
                if len(subscripts) < 1:
                    print("\tSubscript operator without subscripts.")
                    return None
                scope0["subscripts"] = subscripts
            elif operator in ["U-", "NOT"]: # Unary operators.
                if stackSize < 1:
                    print(("Implementation error, not enough operands " + \
                          "for operator \"%s\"") % operator)
                    return None
                operand = computationStack[-1]
                if operator == "U-":
                    result = -operand
                elif operator == "NOT":
                    if isinstance(operand, bool):
                        result = not operand
                    elif isinstance(operand, int):
                        result = ~operand
                    else:
                        print("\tOperand type inappropriate for NOT operator")
                        return None
                else:
                    print(("Implementation error, unary operator \"%s\" " + \
                           "not yet implemented") % operator)
                    return None
                computationStack[-1] = result
            elif operator in ["+", "-", "", "/", "**", ".", "*", "C||", "OR", 
                              "AND", "==", "!=", "<", ">", "<=", ">="]: 
                # binary operators.
                if stackSize < 2:
                    print(("Implementation error, not enough operands " + \
                          "for operator \"%s\"") % operator)
                    return None
                operand1 = computationStack[-1]
                operand2 = computationStack[-2]
                computationStack.pop()
                if operator == "+":
                    result = operand1 + operand2
                elif operator == "-":
                    result = operand1 - operand2
                elif operator == "":
                    result = operand1 * operand2
                elif operator == "/":
                    result = operand1 / operand2
                elif operator == "**":
                    result = operand1 ** operand2
                elif operator == "C||": # string concatenation.
                    result = operand1 + operand2
                elif operator == "OR":
                    result = operand1 or operand2
                elif operator == "AND":
                    result = operand1 and operand2
                elif operator == "==":
                    result = (operand1 == operand2)
                elif operator == "!=":
                    result = (operand1 != operand2)
                elif operator == "<":
                    result = (operand1 < operand2)
                elif operator == ">":
                    result = (operand1 > operand2)
                elif operator == "<=":
                    result = (operand1 <= operand2)
                elif operator == ">=":
                    result = (operand1 >= operand2)
                #elif operator == "!<":
                #    result = not (operand2 < operand1)
                #elif operator == "!>":
                #    result = not (operand2 > operand1)
                else:
                    print(("Implementation error, binary operator \"%s\" " + \
                           "not yet implemented") % operator)
                    return None
                computationStack[-1] = result
            else:
                print("\tImplementation error, unknown binary operator \"%s\"" \
                                                                % operator)
                return None
        elif "fetch" in instruction or "fetchp" in instruction or \
                "store" in instruction or "storepop" in instruction:
            erroredUp = False
            fetch = False
            fetchp = False
            pop = False
            stackPos = 1
            if "fetch" in instruction:
                si, identifier = instruction["fetch"]
                fetch = True
            elif "fetchp" in instruction:
                si, identifier = instruction["fetch"]
                fetch = True
            elif "store" in instruction:
                si, identifier = instruction["store"]
            elif "storepop" in instruction:
                si, identifier = instruction["storepop"]
                pop = True
            if si == -1:
                si, identifier = scope["assignments"][identifier]
            try:
                attributes = PALMAT["scopes"][si]["identifiers"][\
                                                        "^" + identifier + "^"]
            except:
                print(si, identifier, instruction)
                sys.exit(1)
            identifier = "^" + identifier + "^"
            erroredUp = True
            if fetch:
                if "value" in attributes:
                    value = subscripted(attributes["value"], subscripts)
                elif "constant" in attributes:
                    value = subscripted(attributes["constant"], subscripts)
                else:
                    print("\tIdentifier %s uninitialized" % identifier)
                    return None
                if value == None:
                    print("\tCannot compute value.")
                    return None
                if value == True: # Convert BOOLEAN to INTEGER.
                    value = 1
                elif value == False:
                    value = 0
                computationStack.append(value)
            else: # store
                if len(computationStack) < stackPos:
                    print("\tImplementation error, stack too short for " +
                          "STOREXXX instruction")
                    return None
                value = copy.deepcopy(computationStack[-stackPos])
                if pop:
                    computationStack.pop(-stackPos)
                if "constant" in attributes:
                    print("\tCannot change value of constant %s." \
                          % identifier[1:-1])
                    return None
                if isinstance(value, str):
                    if "character" not in attributes:
                        print("\tCannot store string in non-CHARACTER " +
                              "variable %s." % identifier[1:-1])
                        return None
                    maxlen = attributes["character"]
                    value = value[:maxlen]
                elif isinstance(value, bool):
                    if "bit" not in attributes and "integer" not in attributes:
                        print("\tCannot store bit/boolean in variable %s." \
                              % identifier[1:-1])
                        return None
                    if "bit" not in attributes or attributes["bit"] != 1:
                        if value == True:
                            value = 1
                        elif value == False:
                            value = 0
                elif isinstance(value, (float, int)):
                    if "scalar" not in attributes and \
                            "integer" not in attributes and \
                            "bit" not in attributes:
                        print("\tCannot store arithmetic value in " + \
                              "variable %s." \
                              % identifier[1:-1])
                        return None
                    if "integer" in attributes:
                        value = hround(value)
                    elif "scalar" in attributes:
                        value = float(value)
                    elif "bit" in attributes:
                        value = hround(value)
                        if attributes["bit"] == 1:
                            if value & 1 == 0:
                                value = False
                            else:
                                value = True
                        else:
                            value = hround(value) & \
                                    ((1 << attributes["bit"]) - 1)
                else:
                    print("\tImplementation error, non-boolean/character/" + \
                          "arithmetic not yet implemented.")
                    return None
                attributes["value"] = value
            if not erroredUp:
                print("\tIdentifier %s not in any accessible scope" \
                      % identifier[1:-1])
                return None
        elif "pop" in instruction:
            value = instruction["pop"]
            if value <= stackSize:
                while value > 0:
                    computationStack.pop()
                    value -= 1
            else:
                print("\tImplementation error, too many POPs: %d vs %d" \
                      % (value, stackSize))
                return None
        elif "write" in instruction:
            lun = instruction["write"]
            if lun == '6':
                print("%*s" % (indent, ""), end="")
                # If this instruction is within a subroutine, then we can 
                # only regress in the computation stack until finding the 
                # return address, because we want to use that later (for 
                # returning!) rather than using it now for printing.
                start = 0
                for i in range(len(computationStack)-1, -1, -1):
                    if isinstance(computationStack[i], tuple):
                        start = i + 1
                        break
                if start < len(computationStack):
                    for value in computationStack[start:]:
                        if isinstance(value, bool):
                            if value:
                                print(" TRUE ", end="")
                            else:
                                print(" FALSE ", end="")
                        elif isinstance(value, (int, float)):
                            print(" %s " % str(value), end="")
                        else:
                            print(value, end="")
                while len(computationStack) > start:
                    computationStack.pop()
                print()
        elif "function" in instruction:
            function = instruction["function"]
            # First check all of the no-argument functions.
            if function in builtIns[0]:
                if function == "RANDOM":
                    # Note that this returns a number in the range [0, 1),
                    # and therefore cannot return exactly 1.  The HAL/S
                    # documentation isn't entirely clear whether values
                    # that are *exactly* 0 or 1 should be returned.
                    computationStack.append(random.random())
                elif function == "RANDOMG":
                    computationStack.append(random.gauss(0.0, 1.0))
                elif function == "RUNTIME":
                    computationStack.append(1.0e-9 * \
                                            (time.time_ns() - timeOrigin))
                else:
                    print("\tHAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            # Now all of the one-argument functions.
            elif function in builtIns[1]:
                if stackSize < 1:
                    print("\tNot enough arguments on stack for function", \
                          function)
                    return None
                operand = computationStack[-1]
                if function == "ABS":
                    computationStack[-1] = abs(operand)
                elif function == "CEILING":
                    computationStack[-1] = math.ceil(operand)
                elif function == "FLOOR":
                    computationStack[-1] = math.floor(operand)
                elif function == "ROUND":
                    operand = hround(operand)
                    computationStack[-1] = hround(operand)
                elif function == "SIGN":
                    if operand >= 0:
                        computationStack[-1] = 1
                    else:
                        computationStack[-1] = -1
                elif function == "SIGNUM":
                    if operand > 0:
                        computationStack[-1] = 1
                    elif operand < 0:
                        computationStack[-1] = -1
                    else:
                        computationStack[-1] = 0
                elif function == "TRUNCATE":
                    if operand >= 0:
                        computationStack[-1] = math.floor(operand)
                    else:
                        computationStack[-1] = math.ceil(operand)
                elif function == "ARCCOS":
                    computationStack[-1] = math.acos(operand)
                elif function == "ARCCOSH":
                    computationStack[-1] = math.acosh(operand)
                elif function == "ARCSIN":
                    computationStack[-1] = math.asin(operand)
                elif function == "ARCSINH":
                    computationStack[-1] = math.asinh(operand)
                elif function == "ARCTAN":
                    computationStack[-1] = math.atan(operand)
                elif function == "ARCTANH":
                    computationStack[-1] = math.atanh(operand)
                elif function == "COS":
                    computationStack[-1] = math.cos(operand)
                elif function == "COSH":
                    computationStack[-1] = math.cosh(operand)
                elif function == "SIN":
                    computationStack[-1] = math.sin(operand)
                elif function == "SINH":
                    computationStack[-1] = math.sinh(operand)
                elif function == "TAN":
                    computationStack[-1] = math.tan(operand)
                elif function == "TANH":
                    computationStack[-1] = math.tanh(operand)
                elif function == "EXP":
                    computationStack[-1] = math.exp(operand)
                elif function == "LOG":
                    computationStack[-1] = math.log(operand)
                elif function == "SQRT":
                    computationStack[-1] = math.sqrt(operand)
                elif function == "LENGTH":
                    operand = str(operand)
                    computationStack[-1] = len(operand)
                elif function == "TRIM":
                    operand = str(operand)
                    computationStack[-1] = operand.strip()
                elif function == "ODD":
                    # Note that this function returns a boolean.
                    operand = hround(operand)
                    if (operand & 1) == 0:
                        computationStack[-1] = False
                    else:
                        computationStack[-1] = True
                else:
                    print("\tHAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            # Now all of the two-argument functions.
            elif function in builtIns[2]:
                if stackSize < 2:
                    print("\tNot enough arguments on stack for function", \
                          function)
                    return None
                operand1 = computationStack.pop()
                operand2 = computationStack[-1]
                if function == "DIV":
                    computationStack[-1] = hround(operand1) // hround(operand2)
                elif function == "REMAINDER":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 % operand2 
                    if operand1 * operand2 < 0:
                        computationStack[-1] -= operand2
                elif function == "MOD":
                    value = operand1 % operand2
                    if operand2 < 0:
                        value -= operand2
                    computationStack[-1] = value
                elif function == "ARCTAN2":
                    computationStack[-1] = math.atan2(operand2, operand1)
                elif function == "XOR":
                    computationStack[-1] = operand1 ^ operand2
                elif function == "SHL":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 << operand2
                elif function == "SHR":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 >> operand2
                elif function == "INDEX":
                    # In Python, the character positions within the string are
                    # indexed from 0 (with -1 being "not present"), while in 
                    # HAL/S indexing is from 1 (with 0 being "not present").
                    operand1 = str(operand1)
                    operand2 = str(operand2)
                    computationStack[-1] = 1 + operand1.find(operand2)
                elif function == "LJUST":
                    operand1 = str(operand1)
                    operand2 = hround(operand2)
                    if operand2 < len(operand1):
                        computationStack[-1] = operand1[:operand2]
                        # This is also supposed to signal an error, which
                        # I have no idea about right now, so I'll have to come
                        # back to it later.
                        # TBD
                    else:
                        computationStack[-1] = "%*s" % (-operand2, operand1)
                elif function == "RJUST":
                    operand1 = str(operand1)
                    operand2 = hround(operand2)
                    if operand2 < len(operand1):
                        computationStack[-1] = operand1[:operand2]
                        # This is also supposed to signal an error, which
                        # I have no idea about right now, so I'll have to come
                        # back to it later.
                        # TBD
                    else:
                        computationStack[-1] = "%*s" % (operand2, operand1)
                else:
                    print("\tHAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            # Now all of the two-argument functions.
            elif function in builtIns[3]:
                if stackSize < 3:
                    print("\tNot enough arguments on stack for function", \
                          function)
                    return None
                operand1 = computationStack.pop()
                operand2 = computationStack.pop()
                operand3 = computationStack[-1]
                if function == "MIDVAL":
                    if operand1 > operand2:
                        operand1, operand2 = operand2, operand1
                    # We now have operand1 <= operand2.
                    if operand3 <= operand1:
                        computationStack[-1] = operand1
                    elif operand3 >= operand2:
                        computationStack[-1] = operand2
                    else:
                        computationStack[-1] = operand3
                else:
                    print("\tHAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            else:
                print("\tImplementation error, function", function)
                return None
        elif "goto" in instruction:
            scopeNumber, instructionIndex = \
                    jump(PALMAT, scopeNumber, instruction, "goto")
            scope = scopes[scopeNumber]
        elif "iffalse" in instruction:
            value = computationStack.pop()
            if not value:
                scopeNumber, instructionIndex = \
                    jump(PALMAT, scopeNumber, instruction, "iffalse")
                scope = scopes[scopeNumber]
        elif "iftrue" in instruction:
            value = computationStack.pop()
            if value:
                scopeNumber, instructionIndex = \
                    jump(PALMAT, scopeNumber, instruction, "iftrue")
                scope = scopes[scopeNumber]
        elif "noop" in instruction:
            pass # Nothing to do!
        elif "run" in instruction:
            si, identifier = instruction["run"]
            identifier = "^" + identifier + "^"
            attributes = PALMAT["scopes"][si]["identifiers"][identifier]
            if attributes == None:
                print("\tTarget of RUN not found:", identifier)
                return None
            if "program" not in attributes:
                print("\tRUN target is not a PROGRAM:", identifier)
                return None
            scopeNumber = attributes["scope"]
            instructionIndex = 0;
            scope = scopes[scopeNumber]
        elif "call" in instruction:
            si, identifier = instruction["call"]
            identifier = "^" + identifier + "^"
            attributes = PALMAT["scopes"][si]["identifiers"][identifier]
            if attributes == None:
                print("\tTarget of CALL not found:", identifier)
                return None
            if "function" not in attributes and "procedure" not in attributes:
                print("\tCALL to neither a FUNCTION nor PROCEDURE:", identifier)
                return None
            si = attributes["scope"]
            s = scopes[si]
            if "return" in s:
                print("\tRecursion in subroutine %s not allowed." \
                      % identifier[1:-1])
                return None
            # The return address.
            returnAddress = (scopeNumber, instructionIndex)
            #computationStack.append((scopeNumber, instructionIndex))
            # Transfer control.
            scopeNumber = si
            instructionIndex = 0
            scope = s
            if "assignments" in instruction:
                scope["assignments"] = copy.deepcopy(instruction["assignments"])
            scope["return"] = returnAddress
        elif "return" in instruction:
            enclosure = scope
            while enclosure != None:
                if "return" in enclosure:
                    scopeNumber, instructionIndex = enclosure["return"]
                    enclosure.pop("return")
                    if "assignments" in enclosure:
                        enclosure.pop("assignments")
                    break
                enclosure = PALMAT["scopes"][enclosure["parent"]]
            if enclosure == None:
                print("\tImplementation error, no return address.")
                return None
            #scopeNumber, instructionIndex = computationStack.pop(-stackPos)
            scope = scopes[scopeNumber]
        else:
            print("\tImplementation error, unknown PALMAT:", instruction)
            return None
    if trace:
        print("\tTRACE:  ", computationStack, "(end)")
    return computationStack
