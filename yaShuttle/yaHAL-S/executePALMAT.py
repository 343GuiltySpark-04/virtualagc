#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Copyright:      None - the author (Ron Burkey) declares this software to
                be in the Public Domain, with no rights reserved.
Filename:       executePALMAT.py
Purpose:        This is a VM (admittedly, and inefficient one) for 
                running PALMAT code generated by compilation of 
                HAL/S source code.
History:        2023-01-01 RSB  Began.
"""

import re

def executePALMAT(PALMAT, trace = False):
    scopes = PALMAT["scopes"]
    scopeNumber = len(scopes) - 1
    scope = scopes[scopeNumber]
    identifiers = scope["identifiers"]
    instructions = scope["instructions"]
    if len(instructions) < 1:
        return
    computationStack = []
    for instruction in instructions:
        if trace:
            print("\t==>", computationStack, instruction)
        stackSize = len(computationStack)
        if "string" in instruction:
            computationStack.append(instruction["string"])
        elif "number" in instruction:
            stringifiedNumber = instruction["number"]
            multiplier = 1.0
            # Recall that HAL/S literal numbers can include modifiers like
            # "B-12" or "H7" in addition to the usual "E23".  Python
            # has no knowledge of these additional funky modifiers, so
            # we have to handle them explicitly.  Unfortunately this 
            # can make the numerical version inexact compared to the 
            # stringified version, and not inexact in the same way as 
            # the original IBM 360 or AP-101S representations were. 
            # At some point I'll probably make the compiler do this work
            # for the sake of efficiency, but right now I'm going for 
            # correctness and leaving efficiency optimizations for later.
            while True:
                match = re.search("[BH][-]?[0-9]+$", stringifiedNumber)
                if match == None:
                    break
                modifier = match.group()
                stringifiedNumber = stringifiedNumber[:match.span()[0]]
                if modifier[0] == "B":
                    multiplier *= 2 ** (int(modifier[1:]))
                else: # modifier[0] == "H":
                    multiplier *= 16 ** (int(modifier[1:]))
            computationStack.append(float(stringifiedNumber) * multiplier)   
        elif "operator" in instruction:
            operator = instruction["operator"]
            if operator in ["U-"]: # Unary operators.
                if stackSize < 1:
                    print("Implementation error, not enough operands for operator \"%s\"" % operator)
                    break
                operand = computationStack[-1]
                if operator == "U-":
                    result = -operand
                else:
                    print("Implementation error, unary operator \"%s\" not yet implemented" % operator)
                    break
                computationStack[-1] = result
            elif operator in ["+", "-", "", "/", "**", ".", "*"]: # binary operators.
                if stackSize < 2:
                    print("Implementation error, not enough operands for operator \"%s\"" % operator)
                    break
                operand1 = computationStack[-1]
                operand2 = computationStack[-2]
                computationStack.pop()
                if operator == "+":
                    result = operand1 + operand2
                elif operator == "-":
                    result = operand1 - operand2
                elif operator == "":
                    result = operand1 * operand2
                elif operator == "/":
                    result = operand1 / operand2
                elif operator == "**":
                    result = operand1 ** operand2
                else:
                    print("Implementation error, binary operator \"%s\" not yet implemented" % operator)
                computationStack[-1] = result
            else:
                print("Implementation error, unknown binary operator \"%s\"" % operator)
                break
        elif "fetch" in instruction or "store" in instruction:
            erroredUp = False
            if "fetch" in instruction:
                identifier = instruction["fetch"]
                fetch = True
            else:
                identifier = instruction["store"]
                fetch = False
            identifier = "^" + identifier + "^"
            for s in reversed(scopes):
                if identifier in s["identifiers"]:
                    erroredUp = True
                    if fetch:
                        if "value" not in s["identifiers"][identifier]:
                            print("Identifier %s uninitialized" % identifier)
                            break
                        computationStack.append(s["identifiers"][identifier]["value"])
                    else: # store
                        if len(computationStack) < 1:
                            print("Implementation error, stack empty for STORE instruction")
                            break
                        s["identifiers"][identifier]["value"] = computationStack[-1]
                    break
            if not erroredUp:
                print("Identifier %s not in any accessible scope" % identifier)
                break
        elif "pop" in instruction:
            value = instruction["pop"]
            if value <= stackSize:
                while value > 0:
                    computationStack.pop()
                    value -= 1
            else:
                print("Implementation error, too many POPs: %d vs %d" \
                      % (value, stackSize))
                break
        elif "write" in instruction:
            lun = instruction["write"]
            if lun == '6':
                while len(computationStack) > 0:
                    value = computationStack.pop()
                    print(value, end="")
                print()
        else:
            print("Implementation error, unknown PALMAT:", instruction)
            break
    if trace:
        print("\t==>", computationStack, "(end)")