#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Copyright:  None - the author (Ron Burkey) declares this software to
            be in the Public Domain, with no rights reserved.
Filename:   executePALMAT.py
Requires:   Python 3.7 or later.
Purpose:    This is a VM (admittedly, and inefficient one) for 
            running PALMAT code generated by compilation of 
            HAL/S source code.
History:    2023-01-01 RSB  Began.
"""

import re
import math
import random
import time
from decimal import Decimal, ROUND_HALF_UP

timeOrigin = 0
# This function is called once at startup, in order to set the 
# time origin properaly.  If not, then the time functions will
# probably work, but they'll be of very low resolution since
# the time measurements (with nanosecond resolution) will be
# relative to 1970-01-01 00:00:00 UTC rather than relative to
# some point in the very recent past.
def setupExecutePALMAT():
    global timeOrigin;
    timeOrigin = time.time_ns()

# This is a replacement for Python's round() function.
# Python's round() function uses a method apparently called 
# "banker's rounding", in which everything rounds just as you'd
# expect except that numbers which are *exactly* integer+1/2
# round (from my perspective) very oddly: they round to the
# nearest *even* integer.  For example, 1.5 and 2.5 both round
# to 2, 3.5 and 4.5 both round to 4, and so on. As far as HAL/S
# is concerned, the documentation isn't 100% explicit in this
# regard, but the explanations on p. 3-4 (PDF p. 42) of 
# "Programming in HAL/S" make it pretty clear that banker's 
# rounding is *not* what was envisaged; 0.5 is supposed to round
# to 1, 3.5 is supposed to round to 4.  (What's left undiscussed
# are cases like -1.5 or -2.5.  Oh well!)  Therefore, the following
# function is provided to account for rounding that's closer to
# what's needed.  I think!
def hround(x):
    return int(Decimal(x).to_integral_value(rounding=ROUND_HALF_UP))

# Categorization of the HAL/S built-in functions by the number of arguments
# they take.
builtIns = [
    # No arguments
    ["CLOCKTIME", "DATE", "ERRGRP", "ERRNUM", "PRIO", "RANDOM", "RANDOMG", 
     "RUNTIME"],
    # One argument
    ["ABS", "CEILING", "FLOOR", "ODD", "ROUND", "SIGN", "SIGNUM", "TRUNCATE",
     "ARCCOS", "ARCCOSH", "ARCSIN", "ARCSINH", "ARCTAN", "ARCTANH", "COS",
     "COSH", "EXP", "LOG", "SIN", "SINH", "SQRT", "TAN", "TANH",
     "ABVAL", "DET", "INVERSE", "TRACE", "TRANSPOSE", "UNIT",
     "MAX", "MIN", "PROD", "SUM", "LENGTH", "TRIM", "NEXTIME", "SIZE"],
    # Two arguments
    ["DIV", "MOD", "REMAINDER", "ARCTAN2", "XOR", "INDEX", "LJUST", "RJUST",
     "SHL", "SHR"],
    # Three arguments
    ["MIDVAL"]
]

# Returns the dictionary associated with the identifier or else None if
# not found.  The scope is the dictionary associated with the 
# current scope ... i.e., it is an entry in PALMAT["scopes"] rather than
# and index into PALMAT["scopes"].  The search begins at the current 
# scope, and moves upward through the parent, grandparent, etc.
# Sibling scopes and descendent scopes are not searched.
# Note: There's also a findIdentifier() in the PALMAT
# module which provides the same service but is incompatible
# API-wise.  Oh well!  I should have researched it better before writing
# this one.
def findIdentifier(scopes, identifier, scope):
    while scope != None:
        if identifier in scope["identifiers"]:
            return scope["identifiers"][identifier]
        if scope["parent"] == None:
            return None
        scope = scopes[scope["parent"]]
    return scope

# Returns a tuple consisting of a new scope number and
# offset into the scope, or else returns None if not found.
# The premise is the that instructionDict has a key/value
# pair of the form { instructionName: s }, where s is either
# an ordered pair of a desired new scope index and offset,
# or else is an identifier giving the name of an accessible
# label.
def jump (scopes, scope, instructionDict, instructionName):
    s = instructionDict[instructionName]
    if isinstance(s, str):
        attributes = findIdentifier(scopes, s, scope)
        if attributes == None or "label" not in attributes:
            print("Cannot find target label", s)
            return None
        # The following line updates the PALMAT instruction
        # (goto or iffalse or whatever) in-place, so that
        # instead of holding the symbolic label that's the
        # target of the jump, it holds a list with two elements
        # that are the index of the scope and the offset
        # into the scope for the target label.  This isn't
        # 100% necessary; it's just there to slightly improve
        # the speed at which the jump can be made subsequently,
        # and might want to be handled differently in some 
        # other implementation.  (Such as making all of these
        # corrections when the PALMAT is loaded, or perhaps
        # having a separate post-compilation processing step
        # that corrects them all.  It's nice to have the 
        # labels as long as you can, though, in case you need
        # to refer to them for some reason.  Here we save the
        # symbolic label in a new key, which accomplishes the
        # same thing, basically.
        instructionDict["symbolicLabel"] = instructionDict[instructionName]
        instructionDict[instructionName] = attributes["label"]
    s = instructionDict[instructionName]
    #print("*", instructionName, instructionDict, s)
    return tuple(s)

# Convert a stringified HAL/S number (i.e., an INTEGER or SCALAR presented
# as a string, possibly with B, H, or E type exponents) into a Python
# float.
def stringifiedToFloat(stringifiedNumber):
    multiplier = 1.0
    # Recall that HAL/S literal numbers can include modifiers like
    # "B-12" or "H7" in addition to the usual "E23".  Python
    # has no knowledge of these additional funky modifiers, so
    # we have to handle them explicitly.  Unfortunately this 
    # can make the numerical version inexact compared to the 
    # stringified version, and not inexact in the same way as 
    # the original IBM 360 or AP-101S representations were. 
    # At some point I'll probably make the compiler do this work
    # for the sake of efficiency, but right now I'm going for 
    # correctness and leaving efficiency optimizations for later.
    while True:
        match = re.search("[EBH][-]?[0-9]+$", stringifiedNumber)
        if match == None:
            break
        modifier = match.group()
        stringifiedNumber = stringifiedNumber[:match.span()[0]]
        if modifier[0] == "E":
            multiplier *= 10 ** (int(modifier[1:]))
        elif modifier[0] == "B":
            multiplier *= 2 ** (int(modifier[1:]))
        else: # modifier[0] == "H":
            multiplier *= 16 ** (int(modifier[1:]))
    return float(stringifiedNumber) * multiplier

# If this function returns, which in principle it might not if executing
# an actual flight program, it returns the current computation stack.
# That would normally be empty if full statements had been executed.
# However, this allow executing (say) just an expression without popping
# the value from the stack at the end, which is useful for the compiler
# since it can then use it to compute things like INITIAL(...) or 
# CONSTANT(...) for DECLARE statements.  If there is failure, for example
# the use of an unimplemented built-in function or referencing an 
# uninitialized variable, then None is returned instead.
def executePALMAT(PALMAT, pcScope=0, pcOffset=0, trace = False, indent=0):
    scopes = PALMAT["scopes"]
    scopeNumber = pcScope
    instructionIndex = pcOffset
    scope = scopes[scopeNumber]
    computationStack = []
    while instructionIndex < len(scope["instructions"]):
        identifiers = scope["identifiers"]
        instructions = scope["instructions"]
        instruction = instructions[instructionIndex]
        instructionIndex += 1
        if trace:
            print("\t==>", computationStack, instruction)
        stackSize = len(computationStack)
        if "debug" in instruction:
            pass
        elif "string" in instruction:
            computationStack.append(instruction["string"])
        elif "boolean" in instruction:
            computationStack.append(instruction["boolean"])
        elif "number" in instruction:
            computationStack.append(stringifiedToFloat(instruction["number"]))
        elif "+><" in instruction:
            identifier = "^" + instruction["+><"] + "^"
            if stackSize < 2:
                print("Implementation error, not enough operands for '+><'.")
                return None
            operand1 = computationStack.pop()
            negativeIncrement = (operand1 < 0)
            operand2 = computationStack[-1]
            attributes = findIdentifier(scopes, identifier, scopes[scopeNumber])
            if "integer" not in attributes and "scalar" not in attributes:
                print("Implementation error in '+><': Not a number.")
                return None
            if "value" not in attributes:
                print("Implementation error in '+><': Uninitialized variable.")
                return None
            operand1 += attributes["value"]
            if "integer" in attributes:
                attributes["value"] = hround(operand1)
            else:
                attributes["value"] = operand1
            if negativeIncrement:
                computationStack[-1] = (operand1 < operand2)
            else:
                computationStack[-1] = (operand1 > operand2)
        elif "operator" in instruction:
            operator = instruction["operator"]
            if operator in ["U-", "NOT"]: # Unary operators.
                if stackSize < 1:
                    print(("Implementation error, not enough operands " + \
                          "for operator \"%s\"") % operator)
                    return None
                operand = computationStack[-1]
                if operator == "U-":
                    result = -operand
                elif operator == "NOT":
                    if isinstance(operand, bool):
                        result = not operand
                    elif isinstance(operand, int):
                        result = ~operand
                    else:
                        print("Operand type inappropriate for NOT operator")
                        return None
                else:
                    print(("Implementation error, unary operator \"%s\" " + \
                           "not yet implemented") % operator)
                    return None
                computationStack[-1] = result
            elif operator in ["+", "-", "", "/", "**", ".", "*", "C||", "OR", 
                              "AND", "==", "!=", "<", ">", "<=", ">="]: 
                # binary operators.
                if stackSize < 2:
                    print(("Implementation error, not enough operands " + \
                          "for operator \"%s\"") % operator)
                    return None
                operand1 = computationStack[-1]
                operand2 = computationStack[-2]
                computationStack.pop()
                if operator == "+":
                    result = operand1 + operand2
                elif operator == "-":
                    result = operand1 - operand2
                elif operator == "":
                    result = operand1 * operand2
                elif operator == "/":
                    result = operand1 / operand2
                elif operator == "**":
                    result = operand1 ** operand2
                elif operator == "C||": # string concatenation.
                    result = operand1 + operand2
                elif operator == "OR":
                    result = operand1 or operand2
                elif operator == "AND":
                    result = operand1 and operand2
                elif operator == "==":
                    result = (operand1 == operand2)
                elif operator == "!=":
                    result = (operand1 != operand2)
                elif operator == "<":
                    result = (operand1 < operand2)
                elif operator == ">":
                    result = (operand1 > operand2)
                elif operator == "<=":
                    result = (operand1 <= operand2)
                elif operator == ">=":
                    result = (operand1 >= operand2)
                #elif operator == "!<":
                #    result = not (operand2 < operand1)
                #elif operator == "!>":
                #    result = not (operand2 > operand1)
                else:
                    print(("Implementation error, binary operator \"%s\" " + \
                           "not yet implemented") % operator)
                    return None
                computationStack[-1] = result
            else:
                print("Implementation error, unknown binary operator \"%s\"" \
                                                                % operator)
                return None
        elif "fetch" in instruction or "store" in instruction:
            erroredUp = False
            if "fetch" in instruction:
                identifier = instruction["fetch"]
                fetch = True
            else:
                identifier = instruction["store"]
                fetch = False
            identifier = "^" + identifier + "^"
            attributes = findIdentifier(scopes, identifier, scopes[scopeNumber])
            if attributes != None:
                erroredUp = True
                if fetch:
                    if "value" in attributes:
                        computationStack.append(attributes["value"])
                    elif "constant" in attributes:
                        computationStack.append(attributes["constant"])
                    else:
                        print("Identifier %s uninitialized" % identifier)
                        return None
                    
                else: # store
                    if len(computationStack) < 1:
                        print("Implementation error, stack empty for " +
                              "STORE instruction")
                        return None
                    value = computationStack[-1]
                    if "constant" in attributes:
                        print("Cannot change a value in a CONSTANT.")
                        return None
                    if isinstance(value, str):
                        if "character" not in attributes:
                            print("Cannot store string in non-CHARACTER " +
                                  "variable.")
                            return None
                        maxlen = attributes["character"]
                        value = value[:maxlen]
                    elif isinstance(value, bool):
                        if "bit" not in attributes:
                            print("Cannot store bit/boolean in " +
                                  "non-bit/boolean variable.")
                            return None
                    elif isinstance(value, (float, int)):
                        if "scalar" not in attributes and \
                                "integer" not in attributes:
                            print("Cannot store arithmetic value in " + \
                                  "non-integer/scalar variable.")
                            return None
                        if "integer" in attributes:
                            value = hround(value)
                        elif "scalar" in attributes:
                            value = float(value)
                    else:
                        print("Implementation error, non-boolean/character/" + \
                              "arithmetic not yet implemented.")
                        return None
                    attributes["value"] = value
            if not erroredUp:
                print("Identifier %s not in any accessible scope" % identifier)
                return None
        elif "pop" in instruction:
            value = instruction["pop"]
            if value <= stackSize:
                while value > 0:
                    computationStack.pop()
                    value -= 1
            else:
                print("Implementation error, too many POPs: %d vs %d" \
                      % (value, stackSize))
                return None
        elif "write" in instruction:
            lun = instruction["write"]
            if lun == '6':
                print("%*s" % (indent, ""), end="")
                for value in computationStack:
                    if isinstance(value, bool):
                        if value:
                            print(" TRUE ", end="")
                        else:
                            print(" FALSE ", end="")
                    elif isinstance(value, (int, float)):
                        print(" %s " % str(value), end="")
                    else:
                        print(value, end="")
                computationStack.clear()
                print()
        elif "function" in instruction:
            function = instruction["function"]
            # First check all of the no-argument functions.
            if function in builtIns[0]:
                if function == "RANDOM":
                    # Note that this returns a number in the range [0, 1),
                    # and therefore cannot return exactly 1.  The HAL/S
                    # documentation isn't entirely clear whether values
                    # that are *exactly* 0 or 1 should be returned.
                    computationStack.append(random.random())
                elif function == "RANDOMG":
                    computationStack.append(random.gauss(0.0, 1.0))
                elif function == "RUNTIME":
                    computationStack.append(1.0e-9 * \
                                            (time.time_ns() - timeOrigin))
                else:
                    print("HAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            # Now all of the one-argument functions.
            elif function in builtIns[1]:
                if stackSize < 1:
                    print("Not enough arguments on stack for function", \
                          function)
                    return None
                operand = computationStack[-1]
                if function == "ABS":
                    computationStack[-1] = abs(operand)
                elif function == "CEILING":
                    computationStack[-1] = math.ceil(operand)
                elif function == "FLOOR":
                    computationStack[-1] = math.floor(operand)
                elif function == "ROUND":
                    operand = hround(operand)
                    computationStack[-1] = hround(operand)
                elif function == "SIGN":
                    if operand >= 0:
                        computationStack[-1] = 1
                    else:
                        computationStack[-1] = -1
                elif function == "SIGNUM":
                    if operand > 0:
                        computationStack[-1] = 1
                    elif operand < 0:
                        computationStack[-1] = -1
                    else:
                        computationStack[-1] = 0
                elif function == "TRUNCATE":
                    if operand >= 0:
                        computationStack[-1] = math.floor(operand)
                    else:
                        computationStack[-1] = math.ceil(operand)
                elif function == "ARCCOS":
                    computationStack[-1] = math.acos(operand)
                elif function == "ARCCOSH":
                    computationStack[-1] = math.acosh(operand)
                elif function == "ARCSIN":
                    computationStack[-1] = math.asin(operand)
                elif function == "ARCSINH":
                    computationStack[-1] = math.asinh(operand)
                elif function == "ARCTAN":
                    computationStack[-1] = math.atan(operand)
                elif function == "ARCTANH":
                    computationStack[-1] = math.atanh(operand)
                elif function == "COS":
                    computationStack[-1] = math.cos(operand)
                elif function == "COSH":
                    computationStack[-1] = math.cosh(operand)
                elif function == "SIN":
                    computationStack[-1] = math.sin(operand)
                elif function == "SINH":
                    computationStack[-1] = math.sinh(operand)
                elif function == "TAN":
                    computationStack[-1] = math.tan(operand)
                elif function == "TANH":
                    computationStack[-1] = math.tanh(operand)
                elif function == "EXP":
                    computationStack[-1] = math.exp(operand)
                elif function == "LOG":
                    computationStack[-1] = math.log(operand)
                elif function == "SQRT":
                    computationStack[-1] = math.sqrt(operand)
                elif function == "LENGTH":
                    operand = str(operand)
                    computationStack[-1] = len(operand)
                elif function == "TRIM":
                    operand = str(operand)
                    computationStack[-1] = operand.strip()
                elif function == "ODD":
                    # Note that this function returns a boolean.
                    operand = hround(operand)
                    if (operand & 1) == 0:
                        computationStack[-1] = False
                    else:
                        computationStack[-1] = True
                else:
                    print("HAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            # Now all of the two-argument functions.
            elif function in builtIns[2]:
                if stackSize < 2:
                    print("Not enough arguments on stack for function", \
                          function)
                    return None
                operand1 = computationStack.pop()
                operand2 = computationStack[-1]
                if function == "DIV":
                    computationStack[-1] = hround(operand1) // hround(operand2)
                elif function == "REMAINDER":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 % operand2 
                    if operand1 * operand2 < 0:
                        computationStack[-1] -= operand2
                elif function == "MOD":
                    value = operand1 % operand2
                    if operand2 < 0:
                        value -= operand2
                    computationStack[-1] = value
                elif function == "ARCTAN2":
                    computationStack[-1] = math.atan2(operand2, operand1)
                elif function == "XOR":
                    computationStack[-1] = operand1 ^ operand2
                elif function == "SHL":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 << operand2
                elif function == "SHR":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 >> operand2
                elif function == "INDEX":
                    # In Python, the character positions within the string are
                    # indexed from 0 (with -1 being "not present"), while in 
                    # HAL/S indexing is from 1 (with 0 being "not present").
                    operand1 = str(operand1)
                    operand2 = str(operand2)
                    computationStack[-1] = 1 + operand1.find(operand2)
                elif function == "LJUST":
                    operand1 = str(operand1)
                    operand2 = hround(operand2)
                    if operand2 < len(operand1):
                        computationStack[-1] = operand1[:operand2]
                        # This is also supposed to signal an error, which
                        # I have no idea about right now, so I'll have to come
                        # back to it later.
                        # TBD
                    else:
                        computationStack[-1] = "%*s" % (-operand2, operand1)
                elif function == "RJUST":
                    operand1 = str(operand1)
                    operand2 = hround(operand2)
                    if operand2 < len(operand1):
                        computationStack[-1] = operand1[:operand2]
                        # This is also supposed to signal an error, which
                        # I have no idea about right now, so I'll have to come
                        # back to it later.
                        # TBD
                    else:
                        computationStack[-1] = "%*s" % (operand2, operand1)
                else:
                    print("HAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            # Now all of the two-argument functions.
            elif function in builtIns[3]:
                if stackSize < 3:
                    print("Not enough arguments on stack for function", \
                          function)
                    return None
                operand1 = computationStack.pop()
                operand2 = computationStack.pop()
                operand3 = computationStack[-1]
                if function == "MIDVAL":
                    if operand1 > operand2:
                        operand1, operand2 = operand2, operand1
                    # We now have operand1 <= operand2.
                    if operand3 <= operand1:
                        computationStack[-1] = operand1
                    elif operand3 >= operand2:
                        computationStack[-1] = operand2
                    else:
                        computationStack[-1] = operand3
                else:
                    print("HAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            else:
                print("Implementation error, function", function)
                return None
        elif "goto" in instruction:
            scopeNumber, instructionIndex = jump(scopes, scope, instruction, \
                                                 "goto")
            scope = scopes[scopeNumber]
        elif "iffalse" in instruction:
            value = computationStack.pop()
            if not value:
                scopeNumber, instructionIndex = \
                    jump(scopes, scope, instruction, "iffalse")
                scope = scopes[scopeNumber]
        elif "iftrue" in instruction:
            value = computationStack.pop()
            if value:
                scopeNumber, instructionIndex = jump(scopes, scope, \
                                                     instruction, "iftrue")
                scope = scopes[scopeNumber]
        elif "noop" in instruction:
            pass # Nothing to do!
        elif "call" in instruction:
            pass
        else:
            print("Implementation error, unknown PALMAT:", instruction)
            return None
    if trace:
        print("\t==>", computationStack, "(end)")
    return computationStack
