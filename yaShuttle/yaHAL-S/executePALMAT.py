#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Copyright:  None - the author (Ron Burkey) declares this software to
            be in the Public Domain, with no rights reserved.
Filename:   executePALMAT.py
Requires:   Python 3.7 or later.
Purpose:    This is a VM (admittedly, an inefficient one) for 
            running PALMAT code generated by compilation of 
            HAL/S source code.
References: [HPG] HAL/S Programmer's Guide.
            [PIH] Programming in HAL/S.
History:    2023-01-01 RSB  Began.

I think this code (unlike my normal code) is pretty clean.  I've tried to keep 
it that way, so as to minimize the difficulty later developers might experience
in trying to use it as a model for converting PALMAT code to a more-efficient
encoding, as well as writing an emulator for that hypothetical more-efficient
encoding.

While this file is long, most of it (and most of the errors, I expect) is 
devoted to the multitudinous automatic conversions needed from one datatype
to the other in assignments and expressions, as well as rearrangements of 
elements in composite datatypes (VECTOR, MATRIX, ARRAY) needed for the the 
various "shaping functions" (INTEGER, SCALAR, VECTOR, and MATRIX).  Aside from
that, I hope the code is straightforward and relatively easy to understand.
"""

import re
import math
import random
import time
import copy
from decimal import Decimal, ROUND_HALF_UP
from palmatAux import flatten, isBitArray, formBitArray, parseBitArray, \
        findIdentifier, flexFindIdentifier, hTRUE, hFALSE, isArrayQuick

timeOrigin = 0

'''
The following code is intended to determine the precision (number of 
significant digits allowable to the right of the decimal point)
of floating-point values.  The precision may actually be slightly
higher than what I compute, because I subtract 1 decimal place, but 
subtracting the 1 gets rid of a lot of nasty-looking printouts.
'''
precision = len(str(math.pi).split(".")[1]) - 1
fpFormat = "%+2." + ("%d" % precision) + "e"

'''
This function is called once at startup, in order to set the 
time origin properaly.  If not, then the time functions will
probably work, but they'll be of very low resolution since
the time measurements (with nanosecond resolution) will be
relative to 1970-01-01 00:00:00 UTC rather than relative to
some point in the very recent past.
'''
def setupExecutePALMAT():
    global timeOrigin;
    timeOrigin = time.time_ns()

'''
This is a replacement for Python's round() function, which I'd like to use
for a direct implementation of the HAL/S ROUND() function, but can't due to 
incompatibility.  Python's round() function uses a method apparently called 
"banker's rounding", in which everything rounds just as you'd expect except 
that numbers which are *exactly* integer+1/2 round (from my and HAL'S's 
perspective) very oddly: they round to the nearest *even* integer.  For 
example, 1.5 and 2.5 both round to 2, 3.5 and 4.5 both round to 4, and so on. 
As far as HAL/S is concerned, the documentation isn't 100% explicit in this
regard since they apparently don't know there are daft alternatives, but the 
explanations on p. 3-4 (PDF p. 42) of [PIH] make it pretty 
clear that banker's rounding is *not* what was envisaged; 0.5 is supposed to 
round to 1, 3.5 is supposed to round to 4.  (What's left undiscussed are cases 
like -1.5 or -2.5.  Oh well!)  Therefore, the following function is provided to 
account for rounding that's closer to what's needed.  I think!
'''
def hround(x):
    return int(Decimal(x).to_integral_value(rounding=ROUND_HALF_UP))

'''
Categorization of the HAL/S built-in functions by the number of arguments
they take.
'''
builtIns = [
    # No arguments
    ["CLOCKTIME", "DATE", "ERRGRP", "ERRNUM", "PRIO", "RANDOM", "RANDOMG", 
     "RUNTIME"],
    # One argument
    ["ABS", "CEILING", "FLOOR", "ODD", "ROUND", "SIGN", "SIGNUM", "TRUNCATE",
     "ARCCOS", "ARCCOSH", "ARCSIN", "ARCSINH", "ARCTAN", "ARCTANH", "COS",
     "COSH", "EXP", "LOG", "SIN", "SINH", "SQRT", "TAN", "TANH",
     "ABVAL", "DET", "INVERSE", "TRACE", "TRANSPOSE", "UNIT",
     "MAX", "MIN", "PROD", "SUM", "LENGTH", "TRIM", "NEXTIME", "SIZE"],
    # Two arguments
    ["DIV", "MOD", "REMAINDER", "ARCTAN2", "XOR", "INDEX", "LJUST", "RJUST",
     "SHL", "SHR"],
    # Three arguments
    ["MIDVAL"]
]

'''
The following is the guts of a "jump" instruction.  The parameters are:
    PALMAT          The entire PALMAT structure of which the current instruction
                    is part, obviously.
    scopeNumber     The index of the PALMAT scope in which this instruction
                    resides.
    instructionDict The instruction itself.  PALMAT instructions in this 
                    implementation have the form of Python "dictionaries", so
                    that's why it happens to be called instructionDict, do 
                    distinguish it from the name of the instruction.  It is 
                    this instructionDict which tells you the destination for
                    the jump.
    instructionName This is the name of the instruction which the jump() 
                    function is helping to implement, which will typically
                    be "goto", "iffalse", "iftrue", or something else related
                    to a jump.
This function does two things: 
    1.  It returns an (index, offset) pair giving the index of the PALMAT scope
        into which the jump is occurring, and the offset into that scope of the
        target location.  The calling code has to make use of these return
        values to perform the actual jump
    2.  It may "optimize" the instructionDict.  The nature of this optimization
        is that the instructionDict, after compilation, may simply give the
        target scope index and the symbolic label attached to the target
        address.  This is inefficient at runtime, since it involves a lookup
        of the symbolic label.  The "optimization" is that if the emulator is
        forced to look up the symbolic label, it then replaces that symbolic
        label by the numeric offset directly in the instructionDict, so that
        the lookup won't be done again if the instruction is executed again
        later.  If it does that, it creates a new key, "symbolicLabel", to 
        preserve the original symbolic label for debugging purposes.  Of course,
        if the compiler or linker did this stuff for us, then the emulator 
        would not have to do it at all.
'''
def jump(PALMAT, scopeNumber, instructionDict, instructionName):
    si, s = instructionDict[instructionName]
    if isinstance(s, str):
        attributes = PALMAT["scopes"][si]["identifiers"][s]
        if attributes == None or "label" not in attributes:
            print("\tCannot find target label", s)
            return None
        instructionDict["symbolicLabel"] = instructionDict[instructionName]
        instructionDict[instructionName] = attributes["label"]
    s = instructionDict[instructionName]
    return tuple(s)

'''
Convert a stringified HAL/S number (i.e., an INTEGER or SCALAR presented
as a string, possibly with B, H, or E type exponents) into a Python
float.

Recall that HAL/S literal numbers can include modifiers like "B-12" or "H7" in 
addition to the usual "E23".  Python of course has no knowledge of these 
additional funky modifiers, so we have to handle them explicitly.  
Unfortunately this can make the numerical version inexact compared to the 
stringified version, and not inexact in the same way as the original IBM 360 or 
AP-101S representations were. At some point I'll probably make the compiler do 
this work for the sake of efficiency, but as for now I keep the accuracy for
as long as possible, so the compiler provides us with "stringified" numbers
and thus the emulator has to do this unpacking at runtime.
'''
def stringifiedToFloat(stringifiedNumber):
    multiplier = 1.0
    while True:
        match = re.search("[EBH][-]?[0-9]+$", stringifiedNumber)
        if match == None:
            break
        modifier = match.group()
        stringifiedNumber = stringifiedNumber[:match.span()[0]]
        if modifier[0] == "E":
            multiplier *= 10 ** (int(modifier[1:]))
        elif modifier[0] == "B":
            multiplier *= 2 ** (int(modifier[1:]))
        else: # modifier[0] == "H":
            multiplier *= 16 ** (int(modifier[1:]))
    return float(stringifiedNumber) * multiplier

'''
Create a PALMAT for a new process/thread.  This is related to the 
executePALMAT() function's newInstantiation parameter (see below).  The
clonePALMAT() function doesn't actually start such a new thread or process,
but merely creates a cloned PALMAT structure suitable for it, and then 
returns it.
'''
instantiationNumber = 0
def clonePALMAT(rawPALMAT):
    global instantiationNumber
    instantiationNumber += 1
    scopeIndex = 0
    
    # For the specified scope, make sure its identifiers are a deep copy
    # rather than a shallow copy.  Except for COMPOOLs.
    def deepcopyDescendents(scopeIndex):
        rawScope = rawPALMAT["scopes"][scopeIndex]
        scope = PALMAT["scopes"][scopeIndex]
        if rawScope["type"] != "compool":
            scope["identifiers"] = copy.deepcopy(rawScope["identifiers"])
        for childIndex in scope["children"]:
            deepcopyDescendents(childIndex)
    
    # After the following operation, both PALMAT and PALMAT["scopes"] are
    # entirely new, but each of the individual scopes PALMAT["scopes"][i]
    # is linked to the same object as rawPALMAT["scopes"][i]. So this is 
    # good for everything other than the "identifiers" field at scopeIndex
    # and its descendents.
    PALMAT = { 
        "scopes": [],
        "instantiation": instantiationNumber
        }
    for scope in rawPALMAT["scopes"]:
        PALMAT["scopes"].append(copy.copy(scope))
    # Now correct the shallowly-copied indentifiers to deep copies where needed.
    deepcopyDescendents(scopeIndex)
    return PALMAT

# Get a subscripted value from an object.  At present, this works only if the 
# subscripts are all numbers; i.e., not "slices".  Returns None on error.
def subscripted(object, subscripts):
    for i in range(len(subscripts)):
        subscript = hround(subscripts[i])
        try:
            # Recall that HAL/S subscripts start from 1, while Python 
            # starts from 0.
            object = object[subscript-1]
        except:
            print("\tSubscript does not exist in object.")
            return None
    return copy.deepcopy(object)

# For WRITE statements.
def printVectorOrMatrix(vOrM):
    if isinstance(vOrM, list):
        for v in vOrM:
            printVectorOrMatrix(v)
        return
    elif vOrM == None:
        value = "X.X"
    elif isinstance(vOrM, int):
        value = "%d" % vOrM
    elif vOrM == 0.0:
        value = " 0.0"
    else: # isinstance(vOrM, float)
        value = fpFormat % vOrM
        if value[:1] == "+":
            value = " " + value[1:]
        value = value.replace("e", "E")
    print(" " + value + " ", end="")

# For WRITE statements.
def printArray(array):
    if isinstance(array, list) and len(array) > 1 and array[-1] == "a":
        for a in array:
            printArray(a)
        return
    elif array == None:
        value = 'None'
    elif isinstance(array, int):
        value = "%d" % array
    elif array == 0.0:
        value = " 0.0"
    elif isinstance(array, float):
        value = fpFormat % array
        if value[:1] == "+":
            value = " " + value[1:]
        value = value.replace("e", "E")
    elif isBitArray(array):
        value = bin(parseBitArray(array)[0])[2:]
    elif isinstance(array, str):
        value = '"' + array + '"'
    else:
        value = "(unimplemented)"
    print(" " + value + " ", end="")

'''
For READ statements.  Read next value (in string form) from LUN 5 ... i.e., 
stdin.  The individual values in the input stream are delimited by commas 
and/or whitespace.  Commas/whitespace are used only for this purpose and are 
not returned by the function.  If a semicolon is encountered in the input
stream, it is returned whether or not it is delimited.  Semicolons are supposed
to be treated as the end of an input record and thus terminate a READ statement,
possibly prematurely.  However, this is the purview of the calling code, and
all readItemLUN5() does is to insure that the semicolon is returned.
'''
readLineFields = [] # Buffered data for READ statements
def readItemLUN5():
    global readLineFields
    while len(readLineFields) == 0:
        line = input("READ  > ").replace(";", " ; ").strip()
        if line == "":
            continue
        if "`" in line:
            print("The back-tick (`) is not a legal character for input data in a READ statement.")
            continue
        readLineFields = re.split(r"\s*,\s*|\s+", line.strip())
    return readLineFields.pop(0)

# Test if an object is a vector, and (optionally) if all its elements are 
# initialized.
def isVector(object, initialization=True):
    if not isinstance(object, list):
        return False
    if len(object) < 1:
        return False
    if isinstance(object[-1], str):
        return False # Is bitstring, pointer, array, etc.
    for e in object:
        if isinstance(e, (int, float)):
            continue
        if e == None and not initialization:
            continue
        return False
    return True

# Test if an object is a matrix, and (optionally if all its elements are 
# initialized.
def isMatrix(object, initialization=True):
    if not isinstance(object, list):
        return False
    numRows = len(object)
    if numRows < 1 or not isinstance(object[0], list):
        return False
    if isinstance(object[-1], str):
        return False # Is bitstring, pointer, array, etc.
    numCols = len(object[0])
    for row in object:
        if not isinstance(row, list) or len(row) != numCols:
            return False
        for e in row:
            if isinstance(e, (int, float)):
                continue
            if e == None and not initialization:
                continue
            return False
    return True

def isArrayGeometry(object, dimensions):
    if len(dimensions) == 0:
        # Object is an atomic element.  If we want to check that all of the 
        # types of the array elements are the same and/or initialized, this
        # is where we do it.
        return True
    if object == None:
        return False
    if not isinstance(object, list):
        return False
    if object[-1] != 'a':
        return False
    if len(object)-1 != dimensions[0]:
        return False
    # This level of the array is okay.  Now go on to the sub-levels.
    subDimensions = dimensions[1:]
    for subObject in object[:-1]:
        if isArrayGeometry(subObject, subDimensions):
            continue
        return False
    return True

# Converts True or False to a bit-array representation for the computation 
# stack.
def convertToBitArray(b):
    if b:
        return hTRUE
    else:
        return hFALSE

# Check operand type for INTEGER vs SCALAR vs VECTOR vs MATRIX.
def checkArithmeticalDatatype(operand):
    if isinstance(operand, int):
        return True, True, False, False
    if isinstance(operand, float):
        return False, True, False, False
    if isVector(operand):
        return False, False, True, False
    if isMatrix(operand):
        return False, False, False, True
    return False, False, False, False

'''
Compute determinant of a square matrix.  I have *not* researched optimal
methods.  This is simply the one that stuck in my mind from schooldays.
'''
def determinant(m):
    n = len(m)
    if n == 1:
        return m[0][0]
    d = 0.0
    s = 1
    for i in range(n):
        bottom = copy.deepcopy(m[1:])
        for row in bottom:
            row.pop(i)
        d += s * m[0][i] * determinant(bottom)
        s = -s
    return d

'''
Compute the inverse of a matrix.  There are innumerable methods for doing 
this, all of them accompanied by disclaimers as to why that particular method
is incredible for some specific kind of matrix, and all other methods are
horrible; and in the usual unhelpful web style, still other statements of the
form "are you sure you really want to invert that matrix anyway ... stupid!"
Of course, I haven't the slightest idea what the properties of the matrices 
that are going to be inverted are, nor however stupid it may be, any means
whatever of bypassing inversion. That being the case, here is simple Gaussian 
elimination with no frills whatever.  Returns either the inverse, or else
None if m is singular.
'''
def matrixInverse(m):
    # Augment m by attaching an identity matrix to the right.
    n = len(m)
    n2 = n + n
    a = []
    for i in range(n):
        addition = [0]*n
        addition[i] = 1
        a.append(m[i] + addition)
    # Reduce so that the left-hand side of the augmented matrix is in
    # upper-triangular form.
    for col in range(n):
        # At this step. only row = col and downard are considered.
        # First I find the row in this section with the largest element
        # in the column, and move it upward to row = col.
        maxElement = abs(a[col][col])
        maxRow = col
        for row in range(col + 1, n):
            e = abs(a[col][row])
            if e > maxElement:
                maxElement = e
                maxRow = row
        if maxElement == 0: # The matrix must be singular.
            return None
        if maxRow != col:
            a[col],a[maxRow] = a[maxRow],a[col]
        # Now we can subtract multiples of a[col) from all the rows below it
        # to make the elements in that column 0. 
        for row in range(col + 1, n):
            scale = a[row][col] / a[col][col]
            if scale == 0:
                continue
            #a[row][col] = 0
            for i in range(col, n2):
                a[row][i] -= scale * a[col][i]
    # Now reduce the upper triangle.
    for col in range(1, n):
        for row in range(col):
            scale = a[row][col] / a[col][col]
            if scale == 0:
                continue
            a[row][col] = 0
            for i in range(col + 1, n2):
                a[row][i] -= scale * a[col][i]
    # Finally, scale each row so that the diagonals on the left-hand side are
    # all 1, and pick off the left=hand side of the augmented matrix, since it's
    # the inverse.
    for row in range(n):
        e = a[row][row]
        a[row] = a[row][n:]
        for i in range(n):
            a[row][i] /= e
    return a

'''
The following function is used to apply a HAL/S built-in "array function"
like MAX, MIN, PROD to an array of integers and/or scalars.  The function
doesn't check the legality of the array, but merely uses the fact that 
the input object is some hierarchy of tuples in which the atomic elements
are integers and/or scalars.  The accumulation parameter is a list with a 
single element, namely the "accumulated" value.  the accumulation function 
(MAX, MIN, ...) adjusts that value in place; it acts like a global variable 
throughout the recursion, but a separate invocation of accumulate() with a 
different accumation parameter wouldn't conflict with it.
The accumulation can either be initialized to an appriate value before 
entry (such as 0.0 for SUM or 1.0 for PROD), or it can be set to True (i.e.,
accumulation = [True]), in which case the very first atomic array element
encountered is used.  Note that accumulation=[None] is used to indicate that
uninitialized or incompatible array values were encountered, so this setting
should not be used when invoking accumulate().
'''
fnMAX = 0
fnMIN = 1
fnPROD = 2
fnSUM = 3
def accumulate(array, function, accumulation):
    
    def prod(x, y):
        return x * y
    
    def sum(x, y):
        return x + y
    
    if accumulation[0] == None:
        return
    if array == None:
        accumulation[0] = None
        return
    if functionType == fnMAX:
        function = max
    elif functionType == fnMIN:
        function = min
    elif functionType == fnPROD:
        function = prod
    elif functionType == fnSUM:
        function = sum
    else:
        accumulation[0] = None
        return
    
    if isArrayQuick(array):
        for e in array[:-1]:
            accumulate(e, functionType, accumulation)
            if accumulation[0] == None:
                return 
    elif accumulation[0] == True:
        accumulation[0] = array
    else:
        try:
            accumulation[0] = function(accumulation[0], array)
        except:
            accumulation[0] = None

def identityMatrix(n):
    result = []
    for i in range(n):
        row = [0.0]*n
        row[i] = 1.0
        result.append(row)
    return result

# Assumes the inner dimensions match and all entries are initialized (!= None)
def matrixMultiply(a, b):
    numRows = len(a)
    numCols = len(b[0])
    numInner = len(b) # == len(a[0])
    result = []
    for i in range(numRows):
        row = []
        for j in range(numCols):
            s = 0
            for k in range(numInner):
                s += a[i][k] * b[k][j]
            row.append(s)
        result.append(row)
    return result

# Apply the INTEGER or SCALAR shaping function (with no subscripts) to a 
# single INTEGER, SCALAR, BIT(N), CHARACTER(N), VECTOR(N), MATRIX(N,M), or 
# an ARRAY(N,...,M) of any of those.
def toIntegerOrScalar(object, toInteger=True):
    if object == None:
        return None
    elif isArrayQuick(object):
        for i in range(len(object)-1):
            object[i] = toIntegerOrScalar(object[i], toInteger)
        return object
    elif isinstance(object, (int, float)):
        if toInteger:
            return int(object)
        return float(object) 
    elif isBitArray(object):
        value, dummy = parseBitArray(object)
        if toInteger:
            return value
        return float(value)
    elif isinstance(object, str):
        value = stringifiedToFloat(object)
        if toInteger:
            return hround(value)
        return value
    elif isinstance(object, list):
        for i in range(len(object)):
            object[i] = toIntegerOrScalar(object[i], toInteger)
        return object

# Flatten a VECTOR or MATRIX and turn it into something more presentable by
# rounding to a specific number of significant digits after the decimal.
# This is only used by the 'typeof' instruction.
def presentify(object, digits=5):
    fmt = "%" + ".%df" % digits
    onto = []
    flatten(object, onto)
    result = ""
    for e in onto:
        if result != "":
            result += ", "
        if isinstance(e, (int, float)):
            result += fmt % e
            while result[-1:] == "0" and result[-2:] != ".0":
                result = result[:-1]
        else:
            result += str(e)
    return result

# This assigns a value, presumably taken from the computation stack, to a
# variable, possibly with subscripts, as represented by its attributes from
# the identifier dictionary and an array of subscripts.  At the moment, the
# subscripts (if present) pick out a specific entry in an ARRAY, VECTOR, or 
# MATRIX, thus the subscripts list is either empty (indicating the entire
# object) or else has a length the same as the number of dimensions of the
# variable.  The exception is the case of an ARRAY of VECTOR or ARRAY of MATRIX,
# in which case the subscripts list could represent either the dimensions of
# the ARRAY or else the dimenstions of the ARRAY+VECTOR or ARRAY+MATRIX.

# For "simple" values only ... i.e., any but VECTOR, MATRIX, ARRAY, STRUCTURE.
# Returns the converted value, but doesn't actually make any assignment.  
# Returns NaN on failure.  None is a legal return value, interpreted as "do 
# not change".
def convertSimple(value, attributes, datatype, datalength, \
                   datatype2, datalength2):
    if value == None:
        return None
    elif datatype == "integer":
        if datatype2 == "integer":
            return value
        if datatype2 == "scalar":
            return (hround(value))
        if datatype2 == "bit":
            return parseBitArray(value)[0]
        if datatype2 == "character":
            # According to [HPG] Appendix A, the string must represent an 
            # integer, and not a float.
            try:
                return int(value)
            except:
                pass
    elif datatype == "scalar":
        if datatype2 == "integer" or datatype2 == "scalar":
            return float(value)
        if datatype2 == "bit":
            return float(parseBitArray(value)[0])
        if datatype2 == "character":
            try:
                return float(value)
            except:
                pass
    elif datatype == "bit":
        if datatype2 == "scalar":
            value = hround(value)
            datatype2 = "integer"
        elif datatype2 == "bit":
            value = parseBitArray(value)[0]
            datatype2 = "integer"
        elif datatype2 == "character":
            # From [HPG] Appendix A, the string must consist of 1's, 0's, and
            # blanks, but not all blanks.
            value = value.replace(" ", "")
            if value != "":
                try:
                    value = int(value, 2)
                    datatype2 = "integer"
                except:
                    pass
        if datatype2 == "integer":
            return [( value & ((1 << datalength)-1), datalength )]
    elif datatype == "character":
        # When compiling the Shuttle flight software, there's no guarantee 
        # here that the maximum string length of the variable will be obeyed.
        # I *could* just truncate these strings to the maximum length,
        # but I'd think this is very likely to screw up
        # SCALAR values, because I'm likely using a lot higher precision here
        # than the original HAL/S did ... but alas I have no clue whatever as
        # to what that original precision was.  The docs just say it's 
        # "implementation dependent".  But I bet those original developer
        # sure knew what that length was, and hardcoded it into their 
        # CHARACTER declarations when they needed to used it, setting me up to
        # fail.
        if datatype2 == "character":
            return value[:datalength]
        if datatype2 == "integer":
            return "%d" % value
        if datatype2 == "scalar":
            if value == 0.0:
                return " 0.0"
            fmt = fpFormat
            #fmt = "%+2." + ("%d" % 6) + "e"
            value = fmt % value
            if value[:1] == "+":
                value = " " + value[1:]
            value = value.replace("e", "E")
            return value
        if datatype2 == "bit":
            return bin(parseBitArray(value)[0])[2:]
    return NaN

# Returns True on success, False on failure.
def assignCompositeTo(value, attributes, subscripts=[]):
    #-------------------------------------------------------------------------
    # First determine the relevant characteristics of the target variable.
    # These are the variables 
    #        isArray
    #        primaryDimensions 
    #        secondaryDimensions
    #        datatype
    #        datalength
    isArray = "array" in attributes;
    primaryDimensions = []
    secondaryDimensions = []
    datatype = ""
    datalength = -1
    if "vector" in attributes:
        primaryDimensions = [attributes["vector"]]
    elif "matrix" in attributes:
        primaryDimensions = attributes["matrix"]
    if isARRAY:
        secondaryDimensions = primaryDimensions
        primaryDimensions = attributes["array"]
    if "bit" in attributes:
        datatype = "bit"
        datalength = attributes["bit"]
    elif "character" in attributes:
        datatype = "character"
        datalength = attributes["character"]
    elif "integer" in attributes:
        datatype = "integer"
    elif "scalar" in attributes:
        datatype = "scalar"
    elif "vector" in attributes:
        datatype = "scalar"
    elif "matrix" in attributes:
        datatype = "scalar"
    else:
        print("\tAssignments to this datatype not yet implemented.")
        return False
    #--------------------------------------------------------------------------
    # Now determine the relevant macro characteristics of the value to store.
    # These are the variables
    #        isArray2
    #        primaryDimensions2
    #        secondaryDimensions2
    #        datatype2
    #        datalength2
    isArray2 = False
    primaryDimensions2 = []
    secondaryDimensions2 = []
    dimensions = primaryDimensions2
    datatype2 = ""
    datalength2 = -1
    if isArrayQuick(value):
        dummy = value
        while isArrayQuick(dummy):
            dimensions.append(len(dummy)-1)
            dummy = dummy[0]
        if not isArrayGeometry(value, dimensions):
            print("\tImplementation error, unassignable datatype on stack.")
            return False
        isArray2 = True
        dimensions = secondaryDimensions2
    if value == None:
        datatype2 = "unassigned"
    elif isVector(value):
        datatype2 = "scalar"
        dimensions.append(len(value))
    elif isMatrix(value):
        datatype2 = "scalar"
        dimensions.append(len(value))
        dimensions.append(len(value[0]))
    elif isBitArray(value):
        datatype2 = "bit"
        dummy, datalength2 = parseBitArray(value)
    elif isinstance(value, str):
        datatype2 = "character"
        datalength2 = len(value)
    elif isinstance(value, int):
        datatype2 = "integer"
    elif isinstance(value, float):
        datatype2 = "scalar"
    else:
        print("\tNot presently an assignable datatype.")
        return False
    #--------------------------------------------------------------------------
    # Determine compatibility of composite-type geometries and subscripts.
    # I.e., we want to make sure that every element of the (subscripted) LHS
    # corresponds to a an object of the corresponding geometry (including 
    # ARRAY vs VECTOR/MATRIX) on the RHS.
    fullDimensions = primaryDimensions + secondaryDimensions
    fullDimensions2 = primaryDimensions2 + secondaryDimensions2
    for i in range(len(subscripts)):
        if subscripts[i] < 1 or subscripts[i] > fullDimensions[i]:
            print("\tSubscript out of range in LHS variable.")
            return False
    fullAssignment = False # Assigns full object to full object
    halfAssignment = False # Assigns value to an array element.
    leafAssignment = False # Assigns value to an element of an array element.
    if len(subscripts) == 0 and isArray == isArray2 and \
            primaryDimensions == primaryDimensions2 and \
            secondaryDimensions == secondaryDimensions2:
        fullAssignment = True
    elif len(subscripts) != 0 and len(subscripts) == len(primaryDimensions) \
            and not isArray2 and secondaryDimensions == primaryDimensions2 \
            and len(secondaryDimensions2) == 0:
        halfAssignment = True
    elif len(subscripts) != 0 and len(subscripts) == len(fullDimensions) and \
            len(fullDimensions2) == 0:
        leafAssignment = True
    else:
        print("\tGeometry mismatch in assignment.")
        return False
    #--------------------------------------------------------------------------
    # At this point the geometries of the assignments and assignees are 
    # known to be compatible. 
    
    return True
'''
This is the main emulator loop.  Basically, you feed it an entire PALMAT
structure of scopes (namely rawPALMAT) including the model of all variables
and constants for each scope, and the list of PALMAT instructions for each
scope.  You also give it a starting address (pcScope and pcOffset, defaulting
to 0, 0), and the emulation just runs until it runs out of PALMAT instructions;
i.e., until the next instruction to be executed is outside of the range of its
scope.

There are also a couple of flourishes:  If newInstantiation is True, then 
the PALMAT dataspaces are cloned prior to execution, so that any changes to
values of variables do not affect any other copies of the PALMAT structure.
In other words, you can have multiple instances running at the same time, and
they run independently.  However, PALMAT instruction lists and COMPOOLs are 
shared among instances, thus minimizing the amount of memory needed for the 
clones, as well as leaving open the possibility of sharing some memory (in the
COMPOOLs).  By default, however, newInstantiation is False, so any time that
executePALMAT() is run it can change variable values in a way that persists.

If this function returns, which in principle it might not if executing
an actual flight program, it returns the current computation stack.
That would normally be empty if full statements had been executed.
However, this allows executing (say) just a single expression without popping
the value from the stack at the end, which is useful for the compiler
since it can then use it to compute things like INITIAL(...) or 
CONSTANT(...) for DECLARE statements.  If there is failure, for example
the use of an unimplemented built-in function or referencing an 
uninitialized variable, then None is returned instead.
'''
def executePALMAT(rawPALMAT, pcScope=0, pcOffset=0, newInstantiation=False, \
                  trace=False, indent=0):
    if newInstantiation:
        PALMAT = clonePALMAT(rawPALMAT)
    else:
        PALMAT = rawPALMAT
    scopes = PALMAT["scopes"]
    scopeNumber = pcScope
    instructionIndex = pcOffset
    scope = scopes[scopeNumber]
    scope0 = scopes[0]
    computationStack = []
    while instructionIndex < len(scope["instructions"]):
        identifiers = scope["identifiers"]
        instructions = scope["instructions"]
        instruction = instructions[instructionIndex]
        if "subscripts" in scope0 and "fetch" not in instruction and \
                "fetchp" not in instruction and "shaping" not in instruction \
                and "unravel" not in instruction:
            print("\tImplementation error, subscript(s) without variable in instruction:", \
                  instruction)
            print(scope0)
            return None
        if "subscripts" in scope0:
            subscripts = scope0.pop("subscripts")
        else:
            subscripts = []
        instructionIndex += 1
        if trace:
            print("\tTRACE:  ", computationStack, \
                  " (%d,%d):" % (scopeNumber, instructionIndex), instruction)
        stackSize = len(computationStack)
        if "debug" in instruction:
            pass
        elif "empty" in instruction:
            computationStack.append(None)
        elif "fill" in instruction:
            computationStack.append({"fill"})
        elif "string" in instruction:
            computationStack.append(instruction["string"])
        elif "boolean" in instruction:
            computationStack.append(instruction["boolean"])
        elif "number" in instruction:
            try:
                value = int(instruction["number"])
            except:
                value = stringifiedToFloat(instruction["number"])
            computationStack.append(value)
        elif "vector" in instruction:
            computationStack.append(instruction["vector"])
        elif "matrix" in instruction:
            computationStack.append(instruction["matrix"])
        elif "array" in instruction:
            computationStack.append(instruction["array"])
        elif "bitarray" in instruction:
            computationStack.append(parseBitArray(instruction["bitarray"])[0])
        elif "+><" in instruction:
            si, identifier = instruction["+><"]
            identifier = "^" + identifier + "^"
            if stackSize < 2:
                print("\tImplementation error, not enough operands for '+><'.")
                return None
            operand1 = computationStack.pop()
            negativeIncrement = (operand1 < 0)
            operand2 = computationStack[-1]
            attributes = PALMAT["scopes"][si]["identifiers"][identifier]
            if attributes == None:
                print("\tImplementation error, variable %s not found." \
                      % identifier[1:-1])
                return None
            if "integer" not in attributes and "scalar" not in attributes:
                print("\tImplementation error in '+><': Not a number.")
                return None
            if "value" not in attributes:
                print("\tImplementation error in '+><': Uninitialized variable.")
                return None
            operand1 += attributes["value"]
            if "integer" in attributes:
                attributes["value"] = hround(operand1)
            else:
                attributes["value"] = operand1
            if negativeIncrement:
                computationStack[-1] = convertToBitArray(operand1 < operand2)
            else:
                computationStack[-1] = convertToBitArray(operand1 > operand2)
        elif "sentinel" in instruction:
            computationStack.append({"sentinel"})
        elif "operator" in instruction:
            operator = instruction["operator"]
            if False:
                pass
            elif operator == "#":
                if stackSize < 2:
                    print(("\tImplementation error, not enough operands " + \
                          "for operator \"%s\"") % operator)
                    return None
                operand1 = hround(computationStack.pop())
                # Recall that if a single item is being repeated, it is present
                # as itself, but if a group of items are being repeated then
                # that group appears on the computation stack in the form of 
                # a single item because the group is wrapped in [(...)].  That
                # particular wrapping is chosen because it's distinguishable 
                # from VECTOR, MATRIX, and ARRAY.
                if computationStack[-1] == {'sentinel'}:
                    computationStack.pop()
                    operands2 = [None]
                else:
                    operands2 = []
                    while True:
                        value = computationStack.pop()
                        if value == {'sentinel'}:
                            break
                        flatten(value, operands2)
                while operand1 > 0:
                    # I want to insert all the elements in operands2 into
                    # computation stack.  If I use the list .extend method
                    # for this, I find they end up in reversed order, so I
                    # want to do the insertion at the beginning rather than
                    # at the end.  I want to do this in place, without 
                    # creating a new computationStack object.
                    #computationStack.extend(operands2)
                    #computationStack[0:0] = operands2
                    computationStack.extend(reversed(operands2))
                    operand1 -= 1
            elif operator == "subscripts":
                subscripts = []
                while True:
                    value = computationStack.pop()
                    if value == {"sentinel"}:
                        break
                    subscripts.append(value)
                if len(subscripts) < 1:
                    print("\tSubscript operator without subscripts.")
                    return None
                scope0["subscripts"] = subscripts
            elif operator in ["U-", "NOT"]: # Unary operators.
                if stackSize < 1:
                    print(("\tImplementation error, not enough operands " + \
                          "for operator \"%s\"") % operator)
                    return None
                operand = computationStack[-1]
                if operator == "U-":
                    isi,isis,isv,ism = checkArithmeticalDatatype(operand)
                    if ism:
                        numRows = len(operand)
                        numCols = len(operand[0])
                        result = []
                        for i in range(numRows):
                            row = []
                            for j in range(numCols):
                                row.append(-operand[i][j])
                            result.append(row)
                    elif isv:
                        numCols = len(operand)
                        result = []
                        for j in range(numCols):
                            result.append(-operand[j])
                    elif isis:
                        result = -operand
                    else:
                        print("\tIncompatible operand for negation.")
                        return None
                elif operator == "NOT":
                    if not isBitArray(operand):
                        print("\tNot bit array:", operand)
                        return None
                    value, length = parseBitArray(operand)
                    result = formBitArray(~value, length)
                else:
                    print(("Implementation error, unary operator \"%s\" " + \
                           "not yet implemented") % operator)
                    return None
                computationStack[-1] = result
            elif operator in ["+", "-", "", "/", "**", ".", "*", "C||", "OR", 
                              "AND", "==", "!=", "<", ">", "<=", ">=", "B||",
                              "ORNOT"]: 
                # binary operators.
                if stackSize < 2:
                    print(("Implementation error, not enough operands " + \
                          "for operator \"%s\"") % operator)
                    return None
                result = None
                operand1 = computationStack[-1]
                operand2 = computationStack[-2]
                computationStack.pop()
                computationStack[-1] = None
                # For some overloaded operators, check out types of operands.
                if operator in ["+", "-", "", "/", "**", ".", "*"]:
                    isi1,isis1,isv1,ism1 = checkArithmeticalDatatype(operand1)
                    isi2,isis2,isv2,ism2 = checkArithmeticalDatatype(operand2)
                # When VECTOR and MATRIX datatypes are involved in operations
                # like addition, multiplication, etc., refer to the "HAL/S 
                # Programmer's Guide", Chapter 7, for lists of compatible 
                # datatypes for operand1 and operand2, as well as details about
                # the results that are supposed to be produced.
                if operand1 != None and operand2 != None:
                    if operator == "+":
                        if ism1 and ism2 and \
                                len(operand1) == len(operand2) and \
                                len(operand1[0]) == len(operand2[0]):
                            numRows = len(operand1)
                            numCols = len(operand1[0])
                            result = []
                            for i in range(numRows):
                                row = []
                                for j in range(numCols):
                                    row.append(operand1[i][j] + operand2[i][j])
                                result.append(row)
                        elif isv1 and isv2 and \
                                len(operand1) == len(operand2):
                            numCols = len(operand1)
                            result = []
                            for j in range(numCols):
                                result.append(operand1[j] + operand2[j])
                        elif isi1 and isi2:
                            result = operand1 + operand2
                        elif isis1 and isis2:
                            result = float(operand1) + float(operand2)
                        else:
                            print("\tIncompatible operands for addition.")
                            return None
                    elif operator == "-":
                        if ism1 and ism2 and \
                                len(operand1) == len(operand2) and \
                                len(operand1[0]) == len(operand2[0]):
                            numRows = len(operand1)
                            numCols = len(operand1[0])
                            result = []
                            for i in range(numRows):
                                row = []
                                for j in range(numCols):
                                    row.append(operand1[i][j] - operand2[i][j])
                                result.append(row)
                        elif isv1 and isv2 and \
                                len(operand1) == len(operand2):
                            numCols = len(operand1)
                            result = []
                            for j in range(numCols):
                                result.append(operand1[j] - operand2[j])
                        elif isi1 and isi2:
                            result = operand1 - operand2
                        elif isis1 and isis2:
                            result = float(operand1) - float(operand2)
                        else:
                            print("\tIncompatible operands for addition.")
                            return None
                    elif operator == "":
                        if isi1 and isi2:
                            result = operand1 * operand2
                        elif isis1 and isis2:
                            result = float(operand1) * float(operand2)
                        elif (isis1 and isv2) or (isv1 and isis2):
                            if isis1:
                                s = operand1
                                v = operand2
                            else:
                                s = operand2
                                v = operand1
                            numCols = len(v)
                            result = []
                            for i in range(numCols):
                                result.append(s * v[i])
                        elif (isis1 and ism2) or (ism1 and isis2):
                            if isis1:
                                s = operand1
                                m = operand2
                            else:
                                s = operand2
                                m = operand1
                            numRows = len(m)
                            numCols = len(m[0])
                            result = []
                            for i in range(numRows):
                                row = []
                                for j in range(numCols):
                                    row.append(s * m[i][j])
                                result.append(row)
                        elif isv1 and isv2:
                            numRows = len(operand1)
                            numCols = len(operand2)
                            result = []
                            for i in range(numRows):
                                row = []
                                for j in range(numCols):
                                    row.append(operand1[i] * operand2[j])
                                result.append(row)
                        elif ism1 and ism2 and \
                                len(operand1[0]) == len(operand2):
                            result = matrixMultiply(operand1, operand2)
                        elif isv1 and ism2 and len(operand1) == len(operand2):
                            numInner = len(operand1)
                            numCols = len(operand2[0])
                            result = []
                            for j in range(numCols):
                                s = 0
                                for k in range(numInner):
                                    s += operand1[k] * operand2[k][j]
                                result.append(s)
                        elif ism1 and isv2 and len(operand1[0]) == len(operand2):
                            numRows = len(operand1)
                            numInner = len(operand2)
                            result = []
                            for i in range(numRows):
                                s = 0
                                for k in range(numInner):
                                    s += operand1[i][k] * operand2[k]
                                result.append(s)
                        else:
                            print("\tIncompatible operands for multiplication.")
                            return None
                    elif operator == "/":
                        # I've so far not found any explanation of what happens
                        # with division by zero.
                        if not isis2:
                            print("\tIncompatible datatype for divisor.")
                            return None
                        operand2 = float(operand2)
                        if ism1:
                            numRows = len(operand1)
                            numCols = len(operand1[0])
                            result = []
                            for i in range(numRows):
                                row = []
                                for j in range(numCols):
                                    row.append(operand1[i][j] / operand2)
                                result.append(row)
                        elif isv1:
                            numCols = len(operand1)
                            result = []
                            for j in range(numCols):
                                result.append(operand1[j] / operand2)
                        elif isis1:
                            result = float(operand1) / operand2
                        else:
                            print("\tIncompatible datatype for dividend.")
                            return None
                    elif operator == "**":
                        if ism1 and isis2 and len(operand1) == len(operand1[0]):
                            n = len(operand1)
                            operand2 = hround(operand2)
                            if operand2 == 0:
                                result = identityMatrix(n)
                            elif operand2 < 0:
                                operand1 = matrixInverse(operand1)
                                result = copy.deepcopy(operand1)
                                operand2 = -operand2
                                if operand1 == None:
                                    print("\tMatrix is singular.")
                                    return None
                            else:
                                result = copy.deepcopy(operand1)
                            while operand2 > 1:
                                result = matrixMultiply(operand1, result)
                                operand2 -= 1
                        elif isis1 and isis2:
                            result = operand1 ** operand2
                        else:
                            print("\tUnsupported operand type(s) for **.")
                            return None
                    elif operator == "C||": # string concatenation.
                        result = operand1 + operand2
                    elif operator in ["AND", "OR", "ORNOT", "B|N" ]:
                        if not isBitArray(operand1):
                            print("\tNot bit array:", operand1)
                            return None
                        if not isBitArray(operand2):
                            print("\tNot bit array:", operand2)
                            return None
                        value1, length1 = parseBitArray(operand1)
                        value2, length2 = parseBitArray(operand2)
                        if operator == "OR":
                            numbits = min(length1, length2)
                            result = formBitArray(value1 | value2, numbits)
                        elif operator == "AND":
                            numbits = min(length1, length2)
                            result = formBitArray(value1 & value2, numbits)
                        elif operator == "ORNOT":
                            numbits = min(length1, length2)
                            result = formBitArray(value1 | ~value2, numbits)
                        elif operator == "B||":
                            numbits = length1 + length2
                            result = formBitArray((value1 << length2) | value2,\
                                                   numbits)
                    elif operator == "==":
                        result = convertToBitArray(operand1 == operand2)
                    elif operator == "!=":
                        result = convertToBitArray(operand1 != operand2)
                    elif operator == "<":
                        result = convertToBitArray(operand1 < operand2)
                    elif operator == ">":
                        result = convertToBitArray(operand1 > operand2)
                    elif operator == "<=":
                        result = convertToBitArray(operand1 <= operand2)
                    elif operator == ">=":
                        result = convertToBitArray(operand1 >= operand2)
                    elif operator == ".":
                        if isVector(operand1) and isVector(operand2) \
                                and len(operand1) == len(operand2):
                            result = 0
                            for i in range(len(operand1)):
                                result += operand1[i] * operand2[i]
                    elif operator == "*":
                        if isVector(operand1) and isVector(operand2) \
                                and len(operand1) == 3 and len(operand2) == 3:
                            result = [
                                operand1[1]*operand2[2]-operand1[2]*operand2[1],
                                operand1[2]*operand2[0]-operand1[0]*operand2[2],
                                operand1[0]*operand2[1]-operand1[1]*operand2[0]                                
                                ]
                        else:
                            print("\tOperands of * must be initialized 3-vectors.")
                            return None
                    else:
                        print(("\tImplementation error, binary operator \"%s\" " + \
                               "not yet implemented") % operator)
                        return None
                    if result == None:
                        print("\tUninitialized values in expression.")
                        return None
                    computationStack[-1] = result
                else:
                    print("\tImplementation error, unknown binary operator \"%s\"" \
                                                                    % operator)
                    return None
        elif "fetch" in instruction or "unravel" in instruction \
                or "fetchp" in instruction or \
                "store" in instruction or "storepop" in instruction or \
                "substore" in instruction or "substorepop" in instruction:
            erroredUp = False
            fetch = False
            fetchp = False
            pop = False
            unravel = False
            lhsSubscripts = False
            stackPos = 1
            if "fetch" in instruction:
                si, identifier = instruction["fetch"]
                fetch = True
            elif "unravel" in instruction:
                si, identifier = instruction["unravel"]
                fetch = True
                unravel = True
            elif "fetchp" in instruction:
                si, identifier = instruction["fetchp"]
                fetchp = True
            elif "store" in instruction:
                si, identifier = instruction["store"]
            elif "storepop" in instruction:
                si, identifier = instruction["storepop"]
                pop = True
            elif "substore" in instruction:
                si, identifier = instruction["substore"]
                lhsSubscripts = True
            elif "substorepop" in instruction:
                si, identifier = instruction["substorepop"]
                pop = True
                lhsSubscripts = True
            lhsSubscriptList = []
            if lhsSubscripts:
                subscript = computationStack.pop()
                while subscript != {"sentinel"}:
                    lhsSubscriptList.append(subscript)
                    subscript = computationStack.pop()
            if si == -1:
                dummyScope = scope
                while "assignments" not in dummyScope:
                    if dummyScope["parent"] == None:
                        print("\tCannot find identifier", identifier)
                        return None
                    dummyScope = PALMAT["scopes"][dummyScope["parent"]]
                si, identifier = dummyScope["assignments"][identifier]
            identifier = "^" + identifier + "^"
            try:
                attributes = PALMAT["scopes"][si]["identifiers"][\
                                                        identifier]
            except:
                print("\tProblem with PALMAT instruction:", instruction)
                print("\tnum scopes =", len(PALMAT["scopes"]))
                print("\ttype of si =", type(si))
                print("\tscope number =", si, " identifier =", identifier)
                print("\tidentifiers =", PALMAT["scopes"][si]["identifiers"])
                return None
            erroredUp = True
            if fetch:
                if "value" in attributes:
                    value = subscripted(attributes["value"], subscripts)
                elif "constant" in attributes:
                    value = subscripted(attributes["constant"], subscripts)
                else:
                    print("\tIdentifier %s uninitialized" % identifier)
                    return None
                if False and value == None:
                    print("\tCannot compute value.")
                    return None
                if unravel:
                    onto = []
                    flatten(value, onto)
                    computationStack.extend(reversed(onto))
                else:
                    computationStack.append(value)
            elif fetchp:
                computationStack.append( [si, identifier, 'p'] )
            else: # store
                if len(computationStack) < stackPos:
                    print("\tImplementation error, stack too short for " +
                          "STOREXXX instruction")
                    return None
                value = copy.deepcopy(computationStack[-stackPos])
                if pop:
                    computationStack.pop(-stackPos)
                if "constant" in attributes:
                    print("\tCannot change value of constant %s." \
                          % identifier[1:-1])
                    return None
                # Apply conversions to the data as necessary, if the datatype
                # found on the computation stack was not precisely what the
                # variable being assigned expects.
                dimensions = []
                if value == None:
                    pass
                elif isinstance(value, str):
                    if "character" not in attributes:
                        print("\tCannot store string in non-CHARACTER " +
                              "variable %s." % identifier[1:-1])
                        return None
                    maxlen = attributes["character"]
                    value = value[:maxlen]
                elif isinstance(value, (float, int)):
                    if "integer" in attributes:
                        value = hround(value)
                    elif "scalar" in attributes:
                        value = float(value)
                    elif "bit" in attributes:
                        value = hround(value) & ((1 << attributes["bit"])-1)
                    elif "character" in attributes:
                        # TBD
                        print("\tStoring number in CHARACTER not yet implemented.")
                        value = "?"
                elif isBitArray(value) and "bit" in attributes:
                    value = formBitArray(parseBitArray(value)[0], \
                                         attributes["bit"])
                elif isVector(value, False) and "vector" in attributes \
                        and not lhsSubscripts:
                    numRows = len(value)
                    dimensions = [numRows]
                    if numRows != attributes["vector"]:
                        print("\tVector length mismatch in store operation:", \
                              identifier[1:-1])
                        return None
                elif isMatrix(value, False) and "matrix" in attributes \
                        and not lhsSubscripts:
                    dimensions = [len(value), len(value[0])]
                    if dimensions != attributes["matrix"]:
                        print("\tMatrix geometry mismatch in store operation:",\
                              identifier[1:-1])
                        return None
                elif "array" in attributes:
                    dimensions = attributes["array"]
                    if not lhsSubscripts and \
                            not isArrayGeometry(value, dimensions):
                        print("\tArray geometry wrong in store operation:", \
                              identifier[1:-1])
                        return None
                else:
                    print("\tMismatched datatypes in instruction:", \
                          instruction, value)
                    return None
                if lhsSubscriptList == []:
                    if "bit" in attributes and not isBitArray(value):
                        value = formBitArray(value, attributes["bit"])
                    elif "character" in attributes and \
                            "array" not in attributes and \
                            "vector" not in attributes and \
                            "matrix" not in attributes:
                        value = str(value)[:attributes["character"]]
                    attributes["value"] = value
                else:
                    if "array" in attributes:
                        sdimensions = attributes["array"]
                    elif "vector" in attributes:
                        sdimensions = [attributes["vector"]]
                    elif "matrix" in attributes:
                        sdimensions = attributes["matrix"]
                    else:
                        sdimensions = []
                    if dimensions != sdimensions[len(lhsSubscriptList):]:
                        print("\tDimensionality mismatch in assignment.")
                        return None
                    if len(lhsSubscriptList) != len(sdimensions):
                        print("\tDimensionality of value and variable differ.")
                        #print(lhsSubscriptList, "vs", dimensions)
                        return None
                    for i in range(len(dimensions)):
                        if lhsSubscriptList[i] < 1 or \
                                lhsSubscriptList[i] > dimensions[i]:
                            print("\tSubscript out of range in assignment")
                            return None
                    # Recall that in python, the following manipulations of 
                    # "row" operate on pointers.  So the final "row" we end up 
                    # with is actually a pointer to a stored row existing 
                    # already in the VECTOR, MATRIX, or ARRAY variable.
                    # Recall also that HAL/S indexes from 1 while Python indexes
                    # from 0.  Recall finally that even uninitialized composite
                    # data in our HAL/S scopes have the proper dimensionality,
                    # but with unused elements set to None, so the sought row
                    # does actually exist.
                    row = attributes["value"]
                    for i in range(len(dimensions)-1):
                        row = row[lhsSubscriptList[i]-1]
                    row[lhsSubscriptList[-1]-1] = value
            if not erroredUp:
                print("\tIdentifier %s not in any accessible scope" \
                      % identifier[1:-1])
                return None
        elif "pop" in instruction:
            value = instruction["pop"]
            if value <= stackSize:
                while value > 0:
                    computationStack.pop()
                    value -= 1
            else:
                print("\tImplementation error, too many POPs: %d vs %d" \
                      % (value, stackSize))
                return None
        elif "read" in instruction:
            lun = instruction["read"]
            if lun == '5':
                # If this instruction is within a subroutine, then we can 
                # only regress in the computation stack until finding the 
                # return address, because we want to use that later (for 
                # returning!) rather than using it now for printing.
                start = 0
                for i in range(len(computationStack)-1, -1, -1):
                    entry = computationStack[i]
                    if isinstance(entry, list) and len(entry) == 3 and \
                            isinstance(entry[0], int) and \
                            isinstance(entry[1], str) and \
                            entry[2] == 'p':
                        continue
                    start = i + 1
                    break
                if start < len(computationStack):
                    semicolon = False
                    for value in computationStack[start:]:
                        if semicolon:
                            break
                        # In reality, we could have subscripted VECTOR, MATRIX,
                        # or ARRAY variables here. For now, I'm just ignoring 
                        # that possibility and implementing unsubscripted
                        # variables.
                        # Recall that "pointers" to variables, which is what
                        # should be on the computation stack at this point,
                        # are of the form [index, identifier, 'p'].
                        si = value[0]
                        identifier = value[1]
                        attributes = \
                            PALMAT["scopes"][si]["identifiers"][identifier]
                        if "vector" in attributes:
                            rowLength = attributes["vector"]
                            for i in range(rowLength):
                                value = readItemLUN5()
                                if value == ";":
                                    semicolon = True
                                    break
                                if value == "":
                                    continue
                                attributes["value"][i] = float(value)
                        elif "matrix" in attributes:
                            numRows, numCols = attributes["matrix"]
                            for i in range(numRows):
                                if semicolon:
                                    break
                                for j in range(numCols):
                                    value = readItemLUN5()
                                    if value == ";":
                                        semicolon = True
                                        break
                                    if value == "":
                                        continue
                                    attributes["value"][i][j] = float(value)
                        elif "integer" in attributes:
                            value = readItemLUN5()
                            if value == ";":
                                semicolon = True
                            elif value == "":
                                attributes["value"] == None
                            else:
                                attributes["value"] = int(value)
                        elif "scalar" in attributes:
                            value = readItemLUN5()
                            if value == ";":
                                semicolon = True
                            elif value == "":
                                attributes["value"] == None
                            else:
                                attributes["value"] = float(value)
                        elif "bit" in attributes:
                            value = readItemLUN5()
                            bitLength = attributes["bit"]
                            if value == ";":
                                semicolon = True
                            elif value == "":
                                attributes["value"] == [(None, bitLength)]
                            else:
                                value = int(value) & ((1 << bitLength) - 1)
                                attributes["value"] = [(value, bitLength)]
                while len(computationStack) > start:
                    computationStack.pop()
                #print()
        elif "write" in instruction:
            lun = instruction["write"]
            if lun == '6':
                print("%*s" % (indent, ""), end="")
                for value in computationStack:
                    if value == None:
                        print(" None ", end="")
                    elif isBitArray(value):
                        print(" " + bin(parseBitArray(value)[0])[2:], end="")
                    elif isinstance(value, (int, float, list)):
                        printVectorOrMatrix(value)
                    elif isArrayQuick(value):
                        printArray(value)
                    else:
                        print(value, end="")
                computationStack.clear()
                print()
        elif "iocontrol" in instruction:
            # We just ignore all i/o controls in WRITE for now.
            if len(computationStack) > 0:
                computationStack.pop()
        elif "shaping" in instruction:
            shapingFunction = instruction["shaping"]
            if shapingFunction == "sliceAT":
                sliceLength = hround(computationStack.pop())
                sliceStart = hround(computationStack[-1])
                computationStack[-1] = [sliceLength, sliceStart]
            elif shapingFunction == "sliceTO":
                sliceStart = hround(computationStack.pop())
                sliceEnd = hround(computationStack[-1])
                computationStack[-1] = (sliceStart, sliceEnd)
            elif shapingFunction in ["integer", "scalar", "vector", "matrix",
                                   "doubleinteger", "doublescalar",
                                   "doublevector", "doublematrix"]:
                dimensions = []
                if computationStack[-1] == {"subscripts"}:
                    computationStack.pop()
                    while True:
                        operand = computationStack.pop()
                        if operand == {"sentinel"}:
                            break
                        dimensions.append(operand)
                if len(dimensions) == 0:
                    if shapingFunction in ["vector", "doublevector"]:
                        dimensions.append(3)
                    elif shapingFunction in ["matrix", "doublematrix"]:
                        dimensions.append(3)
                        dimensions.append(3)
                # We now have the dimensionality, so let's create a Python
                # object to hold the data.  If the dimension list is empty,
                # there are a number of special cases (presumably originally
                # intended as convenience features for the code) that we need
                # to consider.
                if len(dimensions) == 0:
                        # The shaping function has no subscripts, and the 
                        # shaping function is integer or scalar, single or 
                        # double precision, though in this Python implementation
                        # single and double precision are treated as identical.
                        object = []
                        operand = computationStack.pop()
                        if computationStack[-1] == {"sentinel"}:
                            # If we're here, it's because there's a single
                            # argument to the shaping function, currently 
                            # stored in operand.
                            computationStack[-1] = \
                                toIntegerOrScalar(operand, \
                                                  shapingFunction in \
                                                  ["integer", "doubleinteger"])
                        else:
                            # If we're here, then there are multiple arguments
                            # to the shaping functions, none of which we've yet
                            # pulled from the stack and we're supposed to 
                            # produce a variable-length ARRAY by unraveling all
                            # of the arguments.
                            fill = False # TBD ... *do* something with fill!
                            while operand != {"sentinel"}:
                                if operand == {"fill"}:
                                    fill = True
                                    continue
                                flatten(operand, object)
                                operand = computationStack.pop()
                            if shapingFunction in ["integer", "doubleinteger"]:
                                for i in range(len(object)):
                                    if object[i] != None:
                                        object[i] = int(object[i])
                            elif shapingFunction in ["scalar", "doublescalar"]:
                                for i in range(len(object)):
                                    if object[i] != None:
                                        object[i] = float(object[i])
                            computationStack.append(object + ["a"])
                        continue
                print("\tHaven't yet implemented shaping functions with subscripts.")
                return None
            else:
                print("\tImplementation error, unknown shaping function:", \
                      shapingFunction)
                return None
        elif "modern" in instruction:
            # These are like RTL built-in functions, but are invented by me for
            # the "modern" compiler/interpreter.  They do things to make 
            # debugging the compiler easier.
            modern = instruction["modern"]
            if modern == "TYPEOF":
                if stackSize < 1:
                    print("\tNot enough arguments on stack for TYPEOF")
                    return None
                operand = computationStack[-1]
                if not isinstance(operand, str):
                    print("\tArgument of TYPEOF must be a string.")
                    return None
                result = [""]*20
                i, mangled = flexFindIdentifier(operand, PALMAT, scopeNumber)
                if i == -1:
                    a = None
                else:
                    i, a = findIdentifier(mangled, PALMAT, i)
                if a == None:
                    a = {}
                    result[0] = "MISSING"
                elif "bit" in a:
                    result[0] = "BIT"
                    result[1] = str(a["bit"])
                elif "character" in a:
                    result[0] = "CHARACTER"
                    result[1] = str(a["character"])
                elif "vector" in a:
                    result[0] = "VECTOR"
                    result[1] = str(a["vector"])
                elif "matrix" in a:
                    result[0] = "MATRIX"
                    result[1] = str(a["matrix"][0])
                    result[2] = str(a["matrix"][1])
                elif "scalar" in a:
                    result[0] = "SCALAR"
                elif "integer" in a:
                    result[0] = "INTEGER"
                elif "structure" in a:
                    result[0] = "STRUCTURE"
                elif "label" in a:
                    result[0] = "LABEL"
                else:
                    result[0] = "?"
                if "constant" in a:
                    if result[0] == "BIT":
                        value, length = parseBitArray(a["constant"])
                        result[3] = "%d, %d" % (value, length)
                    elif result[0] in ["VECTOR", "MATRIX"]:
                        result[3] = str(a["constant"])
                        result[3] = presentify(a['constant'])
                    else:
                        result[3] = str(a["constant"])
                if "initial" in a:
                    if result[0] == "BIT":
                        value, length = parseBitArray(a["initial"])
                        result[4] = "%d, %d" % (value, length)
                    elif result[0] in ["VECTOR", "MATRIX"]:
                        result[4] = str(a["initial"])
                        result[4] = presentify(a['initial'])
                    else:
                        result[4] = str(a["initial"])
                if "double" in a:
                    result[5] = "DOUBLE"
                if "array" in a:
                    dimensions = a["array"]
                    i = 15
                    for d in dimensions:
                        if i > 20:
                            break
                        result[i] = str(d)
                        i += 1
                computationStack[-1] = result + ["a"]
            elif modern == "TYPEOFV":
                # Same as TYPEOF, except analyzes the value atop the 
                # computation stack, rather than an identifier.
                if stackSize < 1:
                    print("\tNot enough arguments on stack for TYPEOFV")
                    return None
                operand = computationStack[-1]
                result = [""]*20
                if isinstance(operand, list) and len(operand) == 3 and \
                        operand[-1] == 'p':
                    result[0] = "POINTER"
                elif isinstance(operand, list) and operand[-1:] == ['a']:
                    dummy = operand
                    dimensions = []
                    while isinstance(dummy, list) and dummy[-1:] == ['a']:
                        dimensions.append(len(dummy)-1)
                        dummy = dummy[0]
                    if isArrayGeometry(operand, dimensions):
                        i = 15
                        for d in dimensions:
                            result[i] = str(d)
                            i += 1
                            if i > 20:
                                break
                        operand = dummy
                    else:
                        result[0] = "?"
                if operand == None:
                    result[0] = "NONE"
                elif isinstance(operand, int):
                    result[0] = "INTEGER"
                elif isinstance(operand, float):
                    result[0] = "SCALAR"
                elif isinstance(operand, str):
                    result[0] = "CHARACTER"
                    result[1] = str(len(operand))
                elif isBitArray(operand):
                    result[0] = "BIT"
                    dummy, result[1] = parseBitArray(operand)
                elif isVector(operand, False):
                    result[0] = "VECTOR"
                    result[1] = str(len(operand))
                elif isMatrix(operand, False):
                    result[0] = "MATRIX"
                    result[1] = str(len(operand))
                    result[2] = str(len(operand[0]))
                elif isinstance(operand, dict):
                    result[0] = "STRUCTURE"
                elif operand == {"sentinel"}:
                    result[0] = "SENTINEL"
                elif operand == {"fill"}:
                    result[0] = "*"
                elif result[0] == "":
                    result[0] = "?"
                computationStack[-1] = result + ["a"]
        elif "function" in instruction:
            function = instruction["function"]
            # First check all of the no-argument functions.
            if function in builtIns[0]:
                if function == "RANDOM":
                    # Note that this returns a number in the range [0, 1),
                    # and therefore cannot return exactly 1.  The HAL/S
                    # documentation isn't entirely clear whether values
                    # that are *exactly* 0 or 1 should be returned.
                    computationStack.append(random.random())
                elif function == "RANDOMG":
                    computationStack.append(random.gauss(0.0, 1.0))
                elif function == "RUNTIME":
                    computationStack.append(1.0e-9 * \
                                            (time.time_ns() - timeOrigin))
                else:
                    print("\tHAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            # Now all of the one-argument functions.
            elif function in builtIns[1]:
                if stackSize < 1:
                    print("\tNot enough arguments on stack for function", \
                          function)
                    return None
                operand = computationStack[-1]
                if False:
                    pass
                elif function == "MAX":
                    accumulation = [True]
                    accumulate(operand, fnMAX, accumulation)
                    if accumulation[0] in [None, True]:
                        print("\tCannot compute array function", function)
                        return None
                    computationStack[-1] = accumulation[0]
                elif function == "MIN":
                    accumulation = [True]
                    accumulate(operand, fnMIN, accumulation)
                    if accumulation[0] in [None, True]:
                        print("\tCannot compute array function", function)
                        return None
                    computationStack[-1] = accumulation[0]
                elif function == "PROD":
                    accumulation = [True]
                    accumulate(operand, fnPROD, accumulation)
                    if accumulation[0] in [None, True]:
                        print("\tCannot compute array function", function)
                        return None
                    computationStack[-1] = accumulation[0]
                elif function == "SUM":
                    accumulation = [True]
                    accumulate(operand, fnSUM, accumulation)
                    if accumulation[0] in [None, True]:
                        print("\tCannot compute array function", function)
                        return None
                    computationStack[-1] = accumulation[0]
                elif function == "ABS":
                    computationStack[-1] = abs(operand)
                elif function == "CEILING":
                    computationStack[-1] = math.ceil(operand)
                elif function == "FLOOR":
                    computationStack[-1] = math.floor(operand)
                elif function == "ROUND":
                    operand = hround(operand)
                    computationStack[-1] = hround(operand)
                elif function == "SIGN":
                    if operand >= 0:
                        computationStack[-1] = 1
                    else:
                        computationStack[-1] = -1
                elif function == "SIGNUM":
                    if operand > 0:
                        computationStack[-1] = 1
                    elif operand < 0:
                        computationStack[-1] = -1
                    else:
                        computationStack[-1] = 0
                elif function == "TRUNCATE":
                    if operand >= 0:
                        computationStack[-1] = math.floor(operand)
                    else:
                        computationStack[-1] = math.ceil(operand)
                elif function == "ARCCOS":
                    computationStack[-1] = math.acos(operand)
                elif function == "ARCCOSH":
                    computationStack[-1] = math.acosh(operand)
                elif function == "ARCSIN":
                    computationStack[-1] = math.asin(operand)
                elif function == "ARCSINH":
                    computationStack[-1] = math.asinh(operand)
                elif function == "ARCTAN":
                    computationStack[-1] = math.atan(operand)
                elif function == "ARCTANH":
                    computationStack[-1] = math.atanh(operand)
                elif function == "COS":
                    computationStack[-1] = math.cos(operand)
                elif function == "COSH":
                    computationStack[-1] = math.cosh(operand)
                elif function == "SIN":
                    computationStack[-1] = math.sin(operand)
                elif function == "SINH":
                    computationStack[-1] = math.sinh(operand)
                elif function == "TAN":
                    computationStack[-1] = math.tan(operand)
                elif function == "TANH":
                    computationStack[-1] = math.tanh(operand)
                elif function == "EXP":
                    computationStack[-1] = math.exp(operand)
                elif function == "LOG":
                    computationStack[-1] = math.log(operand)
                elif function == "SQRT":
                    computationStack[-1] = math.sqrt(operand)
                elif function == "LENGTH":
                    operand = str(operand)
                    computationStack[-1] = len(operand)
                elif function == "TRIM":
                    operand = str(operand)
                    computationStack[-1] = operand.strip()
                elif function == "ODD":
                    # Note that this function returns a boolean.
                    operand = hround(operand)
                    if (operand & 1) == 0:
                        computationStack[-1] = hFALSE
                    else:
                        computationStack[-1] = hTRUE
                elif function == "ABVAL":
                    vector = computationStack[-1]
                    if not isVector(vector):
                        print("\tABVAL requires a vector argument.")
                        return None
                    sum = 0.0
                    for v in vector:
                        sum += v * v
                    computationStack[-1] = math.sqrt(sum)
                elif function == "UNIT":
                    vector = computationStack[-1]
                    if not isVector(vector):
                        print("\tUNIT requires a vector argument.")
                        return None
                    sum = 0.0
                    for v in vector:
                        sum += v * v
                    length = math.sqrt(sum)
                    try:
                        for i in range(len(vector)):
                            vector[i] /= length
                    except:
                        print("\tDivide by zero in UNIT function; using [1,0,...].")
                        vector = [0.0]*len(vector)
                        vector[0] = 1.0
                    computationStack[-1] = vector
                elif function == "TRACE":
                    matrix = computationStack[-1]
                    if not isMatrix(matrix) or len(matrix) != len(matrix[0]):
                        print("\tTRACE requires a square matrix argument.")
                        return None
                    sum = 0.0
                    for i in range(len(matrix)):
                        sum += matrix[i][i]
                    computationStack[-1] = sum
                elif function == "TRANSPOSE":
                    matrix = computationStack[-1]
                    if not isMatrix(matrix, False):
                        print("\tTRANSPOSE requires a matrix argument.")
                        return None
                    numRows = len(matrix)
                    numCols = len(matrix[0])
                    transposed = []
                    for i in range(numCols):
                        transposed.append([0]*numRows)
                    for i in range(numCols):
                        for j in range(numRows):
                            transposed[i][j] = matrix[j][i]
                    computationStack[-1] = transposed
                elif function == "DET":
                    matrix = computationStack[-1]
                    if not isMatrix(matrix) or len(matrix) != len(matrix[0]):
                        print("\tDET requires a square-matrix argument.")
                        return None
                    computationStack[-1] = determinant(matrix)
                elif function == "INVERSE":
                    matrix = computationStack[-1]
                    if not isMatrix(matrix) or len(matrix) != len(matrix[0]):
                        print("\tINVERSE requires a square-matrix argument.")
                        return None
                    inverse = matrixInverse(matrix)
                    if inverse == None:
                        print("\tMatrix is singular, and cannot be inverted.")
                        return None
                    computationStack[-1] = inverse
                else:
                    print("\tHAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            # Now all of the two-argument functions.
            elif function in builtIns[2]:
                if stackSize < 2:
                    print("\tNot enough arguments on stack for function", \
                          function)
                    return None
                operand1 = computationStack.pop()
                operand2 = computationStack[-1]
                if function == "DIV":
                    computationStack[-1] = hround(operand1) // hround(operand2)
                elif function == "REMAINDER":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 % operand2 
                    if operand1 * operand2 < 0:
                        computationStack[-1] -= operand2
                elif function == "MOD":
                    value = operand1 % operand2
                    if operand2 < 0:
                        value -= operand2
                    computationStack[-1] = value
                elif function == "ARCTAN2":
                    computationStack[-1] = math.atan2(operand2, operand1)
                elif function == "XOR":
                    if not isBitArray(operand1):
                        print("\tNot bit array:", operand1)
                        return None
                    if not isBitArray(operand2):
                        print("\tNot bit array:", operand2)
                        return None
                    value1, length1 = parseBitArray(operand1)
                    value2, length2 = parseBitArray(operand2)
                    numbits = min(length1, length2)
                    computationStack[-1] = formBitArray(value1^value2, numbits)
                elif function == "SHL":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 << operand2
                elif function == "SHR":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 >> operand2
                elif function == "INDEX":
                    # In Python, the character positions within the string are
                    # indexed from 0 (with -1 being "not present"), while in 
                    # HAL/S indexing is from 1 (with 0 being "not present").
                    operand1 = str(operand1)
                    operand2 = str(operand2)
                    computationStack[-1] = 1 + operand1.find(operand2)
                elif function == "LJUST":
                    operand1 = str(operand1)
                    operand2 = hround(operand2)
                    if operand2 < len(operand1):
                        computationStack[-1] = operand1[:operand2]
                        # This is also supposed to signal an error, which
                        # I have no idea about right now, so I'll have to come
                        # back to it later.
                        # TBD
                    else:
                        computationStack[-1] = "%*s" % (-operand2, operand1)
                elif function == "RJUST":
                    operand1 = str(operand1)
                    operand2 = hround(operand2)
                    if operand2 < len(operand1):
                        computationStack[-1] = operand1[:operand2]
                        # This is also supposed to signal an error, which
                        # I have no idea about right now, so I'll have to come
                        # back to it later.
                        # TBD
                    else:
                        computationStack[-1] = "%*s" % (operand2, operand1)
                else:
                    print("\tHAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            # Now all of the two-argument functions.
            elif function in builtIns[3]:
                if stackSize < 3:
                    print("\tNot enough arguments on stack for function", \
                          function)
                    return None
                operand1 = computationStack.pop()
                operand2 = computationStack.pop()
                operand3 = computationStack[-1]
                if function == "MIDVAL":
                    if operand1 > operand2:
                        operand1, operand2 = operand2, operand1
                    # We now have operand1 <= operand2.
                    if operand3 <= operand1:
                        computationStack[-1] = operand1
                    elif operand3 >= operand2:
                        computationStack[-1] = operand2
                    else:
                        computationStack[-1] = operand3
                else:
                    print("\tHAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            else:
                print("\tImplementation error, function", function)
                return None
        elif "goto" in instruction:
            scopeNumber, instructionIndex = \
                    jump(PALMAT, scopeNumber, instruction, "goto")
            scope = scopes[scopeNumber]
        elif "iffalse" in instruction:
            value, dummy = parseBitArray(computationStack.pop())
            if (value & 1) == 0:
                scopeNumber, instructionIndex = \
                    jump(PALMAT, scopeNumber, instruction, "iffalse")
                scope = scopes[scopeNumber]
        elif "iftrue" in instruction:
            value, dummy = parseBitArray(computationStack.pop())
            if (value & 1) != 0:
                scopeNumber, instructionIndex = \
                    jump(PALMAT, scopeNumber, instruction, "iftrue")
                scope = scopes[scopeNumber]
        elif "noop" in instruction:
            pass # Nothing to do!
        elif "run" in instruction:
            si, identifier = instruction["run"]
            identifier = "^" + identifier + "^"
            attributes = PALMAT["scopes"][si]["identifiers"][identifier]
            if attributes == None:
                print("\tTarget of RUN not found:", identifier)
                return None
            if "program" not in attributes:
                print("\tRUN target is not a PROGRAM:", identifier)
                return None
            scopeNumber = attributes["scope"]
            instructionIndex = 0;
            scope = scopes[scopeNumber]
        elif "call" in instruction:
            si, identifier = instruction["call"]
            identifier = "^" + identifier + "^"
            attributes = PALMAT["scopes"][si]["identifiers"][identifier]
            if attributes == None:
                print("\tTarget of CALL not found:", identifier)
                return None
            if "function" not in attributes and "procedure" not in attributes:
                print("\tCALL to neither a FUNCTION nor PROCEDURE:", identifier)
                return None
            si = attributes["scope"]
            s = scopes[si]
            if "return" in s:
                print("\tRecursion in subroutine %s not allowed." \
                      % identifier[1:-1])
                return None
            # The return address.
            returnAddress = (scopeNumber, instructionIndex)
            #computationStack.append((scopeNumber, instructionIndex))
            # Transfer control.
            scopeNumber = si
            instructionIndex = 0
            scope = s
            if "assignments" in instruction:
                scope["assignments"] = copy.deepcopy(instruction["assignments"])
            scope["return"] = returnAddress
        elif "return" in instruction:
            enclosure = scope
            while enclosure != None:
                if "return" in enclosure:
                    scopeNumber, instructionIndex = enclosure["return"]
                    enclosure.pop("return")
                    if "assignments" in enclosure:
                        enclosure.pop("assignments")
                    break
                enclosure = PALMAT["scopes"][enclosure["parent"]]
            if enclosure == None:
                print("\tImplementation error, no return address.")
                return None
            #scopeNumber, instructionIndex = computationStack.pop(-stackPos)
            scope = scopes[scopeNumber]
        else:
            print("\tImplementation error, unknown PALMAT:", instruction)
            return None
    if trace:
        print("\tTRACE:  ", computationStack, \
              " (%d,%d):" % (scopeNumber, instructionIndex), "(end)")
    return computationStack
