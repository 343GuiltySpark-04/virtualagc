#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Copyright:  None - the author (Ron Burkey) declares this software to
            be in the Public Domain, with no rights reserved.
Filename:   executePALMAT.py
Requires:   Python 3.7 or later.
Purpose:    This is a VM (admittedly, and inefficient one) for 
            running PALMAT code generated by compilation of 
            HAL/S source code.
History:    2023-01-01 RSB  Began.
"""

import re
import math
import random
import time
import copy
from decimal import Decimal, ROUND_HALF_UP

timeOrigin = 0

# The following code is intended to determine the precision of 
# (number of significant digits to the right of the decimal point)
# of floating-point values.  The precision may actually be one 
# higher, but subtracting the 1 gets rid of a lot of nasty-looking
# prints.
precision = len(str(math.pi).split(".")[1]) - 1
fpFormat = "%+2." + ("%d" % precision) + "e"

# This function is called once at startup, in order to set the 
# time origin properaly.  If not, then the time functions will
# probably work, but they'll be of very low resolution since
# the time measurements (with nanosecond resolution) will be
# relative to 1970-01-01 00:00:00 UTC rather than relative to
# some point in the very recent past.
def setupExecutePALMAT():
    global timeOrigin;
    timeOrigin = time.time_ns()

# This is a replacement for Python's round() function.
# Python's round() function uses a method apparently called 
# "banker's rounding", in which everything rounds just as you'd
# expect except that numbers which are *exactly* integer+1/2
# round (from my perspective) very oddly: they round to the
# nearest *even* integer.  For example, 1.5 and 2.5 both round
# to 2, 3.5 and 4.5 both round to 4, and so on. As far as HAL/S
# is concerned, the documentation isn't 100% explicit in this
# regard, but the explanations on p. 3-4 (PDF p. 42) of 
# "Programming in HAL/S" make it pretty clear that banker's 
# rounding is *not* what was envisaged; 0.5 is supposed to round
# to 1, 3.5 is supposed to round to 4.  (What's left undiscussed
# are cases like -1.5 or -2.5.  Oh well!)  Therefore, the following
# function is provided to account for rounding that's closer to
# what's needed.  I think!
def hround(x):
    return int(Decimal(x).to_integral_value(rounding=ROUND_HALF_UP))

# Categorization of the HAL/S built-in functions by the number of arguments
# they take.
builtIns = [
    # No arguments
    ["CLOCKTIME", "DATE", "ERRGRP", "ERRNUM", "PRIO", "RANDOM", "RANDOMG", 
     "RUNTIME"],
    # One argument
    ["ABS", "CEILING", "FLOOR", "ODD", "ROUND", "SIGN", "SIGNUM", "TRUNCATE",
     "ARCCOS", "ARCCOSH", "ARCSIN", "ARCSINH", "ARCTAN", "ARCTANH", "COS",
     "COSH", "EXP", "LOG", "SIN", "SINH", "SQRT", "TAN", "TANH",
     "ABVAL", "DET", "INVERSE", "TRACE", "TRANSPOSE", "UNIT",
     "MAX", "MIN", "PROD", "SUM", "LENGTH", "TRIM", "NEXTIME", "SIZE"],
    # Two arguments
    ["DIV", "MOD", "REMAINDER", "ARCTAN2", "XOR", "INDEX", "LJUST", "RJUST",
     "SHL", "SHR"],
    # Three arguments
    ["MIDVAL"]
]

# Returns a tuple consisting of a new scope number and
# offset into the scope, or else returns None if not found.
# The premise is the that instructionDict has a key/value
# pair of the form { instructionName: s }, where s is either
# an ordered pair of a desired new scope index and offset,
# or else is an identifier giving the name of an accessible
# label.
def jump(PALMAT, scopeNumber, instructionDict, instructionName):
    #print("*", scopeNumber, instructionDict, instructionName)
    si, s = instructionDict[instructionName]
    if isinstance(s, str):
        attributes = PALMAT["scopes"][si]["identifiers"][s]
        if attributes == None or "label" not in attributes:
            print("\tCannot find target label", s)
            return None
        # The following line updates the PALMAT instruction
        # (goto or iffalse or whatever) in-place, so that
        # instead of holding the symbolic label that's the
        # target of the jump, it holds a list with two elements
        # that are the index of the scope and the offset
        # into the scope for the target label.  This isn't
        # 100% necessary; it's just there to slightly improve
        # the speed at which the jump can be made subsequently,
        # and might want to be handled differently in some 
        # other implementation.  (Such as making all of these
        # corrections when the PALMAT is loaded, or perhaps
        # having a separate post-compilation processing step
        # that corrects them all.  It's nice to have the 
        # labels as long as you can, though, in case you need
        # to refer to them for some reason.  Here we save the
        # symbolic label in a new key, which accomplishes the
        # same thing, basically.
        instructionDict["symbolicLabel"] = instructionDict[instructionName]
        instructionDict[instructionName] = attributes["label"]
    s = instructionDict[instructionName]
    return tuple(s)

# Convert a stringified HAL/S number (i.e., an INTEGER or SCALAR presented
# as a string, possibly with B, H, or E type exponents) into a Python
# float.
def stringifiedToFloat(stringifiedNumber):
    multiplier = 1.0
    # Recall that HAL/S literal numbers can include modifiers like
    # "B-12" or "H7" in addition to the usual "E23".  Python
    # has no knowledge of these additional funky modifiers, so
    # we have to handle them explicitly.  Unfortunately this 
    # can make the numerical version inexact compared to the 
    # stringified version, and not inexact in the same way as 
    # the original IBM 360 or AP-101S representations were. 
    # At some point I'll probably make the compiler do this work
    # for the sake of efficiency, but right now I'm going for 
    # correctness and leaving efficiency optimizations for later.
    while True:
        match = re.search("[EBH][-]?[0-9]+$", stringifiedNumber)
        if match == None:
            break
        modifier = match.group()
        stringifiedNumber = stringifiedNumber[:match.span()[0]]
        if modifier[0] == "E":
            multiplier *= 10 ** (int(modifier[1:]))
        elif modifier[0] == "B":
            multiplier *= 2 ** (int(modifier[1:]))
        else: # modifier[0] == "H":
            multiplier *= 16 ** (int(modifier[1:]))
    return float(stringifiedNumber) * multiplier

# Create a PALMAT for a new process/thread.
instantiationNumber = 0
def clonePALMAT(rawPALMAT):
    global instantiationNumber
    instantiationNumber += 1
    scopeIndex = 0
    
    # For the specified scope, make sure its identifiers are a deep copy
    # rather than a shallow copy.  Except for COMPOOLs.
    def deepcopyDescendents(scopeIndex):
        rawScope = rawPALMAT["scopes"][scopeIndex]
        scope = PALMAT["scopes"][scopeIndex]
        if rawScope["type"] != "compool":
            scope["identifiers"] = copy.deepcopy(rawScope["identifiers"])
        for childIndex in scope["children"]:
            deepcopyDescendents(childIndex)
    
    # After the following operation, both PALMAT and PALMAT["scopes"] are
    # entirely new, but each of the individual scopes PALMAT["scopes"][i]
    # is linked to the same object as rawPALMAT["scopes"][i]. So this is 
    # good for everything other than the "identifiers" field at scopeIndex
    # and its descendents.
    PALMAT = { 
        "scopes": [],
        "instantiation": instantiationNumber
        }
    for scope in rawPALMAT["scopes"]:
        PALMAT["scopes"].append(copy.copy(scope))
    # Now correct the shallowly-copied indentifiers to deep copies where needed.
    deepcopyDescendents(scopeIndex)
    return PALMAT

# Get a subscripted value from an object.  At present, this works only if the 
# subscripts are all numbers.  Returns None on error.
def subscripted(object, subscripts):
    for i in range(len(subscripts)):
        subscript = hround(subscripts[i])
        try:
            # Recall that HAL/S subscripts start from 1, while Python 
            # starts from 0.
            object = object[subscript-1]
        except:
            print("\tSubscript does not exist in object.")
            return None
    return copy.deepcopy(object)

def printVectorOrMatrix(vOrM):
    if isinstance(vOrM, list):
        for v in vOrM:
            printVectorOrMatrix(v)
        return
    elif vOrM == None:
        value = "X.X"
    elif isinstance(vOrM, int):
        value = "%d" % vOrM
    elif vOrM == 0.0:
        value = " 0.0"
    else: # isinstance(vOrM, float)
        value = fpFormat % vOrM
        if value[:1] == "+":
            value = " " + value[1:]
        value = value.replace("e", "E")
    print(" " + value + " ", end="")

# Read next value (in string form) from LUN 5 ... i.e., stdin.  If a semicolon
# is encountered that's returned.
readLineFields = [] # Buffered data for READ statements
def readItemLUN5():
    global readLineFields
    while len(readLineFields) == 0:
        line = input("READ  > ").replace(";", " ; ")
        readLineFields = re.split(r"\s*,\s*|\s+", line)
    return readLineFields.pop(0)

# Test if an object is a vector, and if all its elements are initialized.
def isVector(object, initialization=True):
    if not isinstance(object, list):
        return False
    for e in object:
        if isinstance(e, (int, float)):
            continue
        if e == None and not initialization:
            continue
        return False
    return True

# Test if an object is a matrix, and if all its elements are initialized.
def isMatrix(object, initialization=True):
    if not isinstance(object, list):
        return False
    numRows = len(object)
    if numRows < 1 or not isinstance(object[0], list):
        return False
    numCols = len(object[0])
    for row in object:
        if not isinstance(row, list) or len(row) != numCols:
            return False
        for e in row:
            if isinstance(e, (int, float)):
                continue
            if e == None and not initialization:
                continue
            return False
    return True

# Test if an object is an array, and if all its elements are initialized.
# The function is used recursively.  Returns a tuple:
#    Boolean        True if geometrically an array (i.e., rectangular tuple
#                   hierarchies), False otherwise.
#    Boolean        True if all elements initialized, False otherwise.  This
#                   can't be detected reliably, since some elements could be
#                   structures, I think, but at least we can detect missing
#                   array elements.
#    [...]          List of widths at each dimension, or [] if not an array.
def isArray0(object):
    # !!! Needs a lot more thought !!!
    if object == None:
        return False, True, []
    if not isinstance(object, tuple):
        return True, []
    dimensions = [len(object)]
    lastSubDimensions = None
    for subObject in object:
        subInitialized, subDimensions = isArray(subObject)
        if lastSubDimensions == None:
            lastSubDimensions = subDimensions
        if subDimensions != lastSubDimensions or not subInitialized:
            return subInitialized, []
    dimensions.extend(subDimensions)
    return True, dimensions

def isArray(object, dimensions):
    if len(dimensions) == 0:
        # Object is an atomic element.  If we want to check that all of the 
        # types of the array elements are the same and/or initialized, this
        # is where we do it.
        return True
    if object == None:
        return False
    if not isinstance(object, tuple):
        return False
    if len(object) != dimensions[0]:
        return False
    # This level of the array is okay.  Now go on to the sub-levels.
    subDimensions = dimensions[1:]
    for subObject in object:
        if isArray(subObject, subDimensions):
            continue
        return False
    return True

# Test if a value on the computation stack is a boolean.
def isBitArray(value):
    if isinstance(value, tuple) and len(value) == 2 and \
            isinstance(value[0], int) and isinstance(value[1], int):
        return True
    return False

# Converts True or False to a bit-array representation for the computation 
# stack.
def convertToBitArray(b):
    if b:
        return (1, 1)
    else:
        return (0, 1)

# Check operand type for INTEGER vs SCALAR vs VECTOR vs MATRIX.
def checkArithmeticalDatatype(operand):
    if isinstance(operand, int):
        return True, True, False, False
    if isinstance(operand, float):
        return False, True, False, False
    if isVector(operand):
        return False, False, True, False
    if isMatrix(operand):
        return False, False, False, True
    return False, False, False, False

# Compute determinant of a square matrix.  I have *not* researched optimal
# methods.  This is simply the one that stuck in my mind from schooldays.
def determinant(m):
    n = len(m)
    if n == 1:
        return m[0][0]
    d = 0.0
    s = 1
    for i in range(n):
        bottom = copy.deepcopy(m[1:])
        for row in bottom:
            row.pop(i)
        d += s * m[0][i] * determinant(bottom)
        s = -s
    return d

# Compute the inverse of a matrix.  There are innumerable methods for doing 
# this, all of them accompanied by disclaimers as to why that particular method
# is incredible for some specific kind of matrix, and all other methods are
# horrible; and in the usual unhelpful web style, still other statements of the
# form "are you sure you really want to invert that matrix anyway ... stupid!"
# Of course, I haven't the slightest idea what the properties of the matrices 
# that are going to be inverted are, nor however stupid it may be, any means
# whatever of bypassing inversion. That being the case, here is simple Gaussian 
# elimination with no frills whatever.  Returns either the inverse, or else
# None if m is singular.
def matrixInverse(m):
    # Augment m by attaching an identity matrix to the right.
    n = len(m)
    n2 = n + n
    a = []
    for i in range(n):
        addition = [0]*n
        addition[i] = 1
        a.append(m[i] + addition)
    # Reduce so that the left-hand side of the augmented matrix is in
    # upper-triangular form.
    for col in range(n):
        # At this step. only row = col and downard are considered.
        # First I find the row in this section with the largest element
        # in the column, and move it upward to row = col.
        maxElement = abs(a[col][col])
        maxRow = col
        for row in range(col + 1, n):
            e = abs(a[col][row])
            if e > maxElement:
                maxElement = e
                maxRow = row
        if maxElement == 0: # The matrix must be singular.
            return None
        if maxRow != col:
            a[col],a[maxRow] = a[maxRow],a[col]
        # Now we can subtract multiples of a[col) from all the rows below it
        # to make the elements in that column 0. 
        for row in range(col + 1, n):
            scale = a[row][col] / a[col][col]
            if scale == 0:
                continue
            #a[row][col] = 0
            for i in range(col, n2):
                a[row][i] -= scale * a[col][i]
    # Now reduce the upper triangle.
    for col in range(1, n):
        for row in range(col):
            scale = a[row][col] / a[col][col]
            if scale == 0:
                continue
            a[row][col] = 0
            for i in range(col + 1, n2):
                a[row][i] -= scale * a[col][i]
    # Finally, scale each row so that the diagonals on the left-hand side are
    # all 1, and pick off the left=hand side of the augmented matrix, since it's
    # the inverse.
    for row in range(n):
        e = a[row][row]
        a[row] = a[row][n:]
        for i in range(n):
            a[row][i] /= e
    return a

# The following function is used to apply a HAL/S built-in "array function"
# like MAX, MIN, PROD to an array of integers and/or scalars.  The function
# doesn't check the legality of the array, but merely uses the fact that 
# the input object is some hierarchy of tuples in which the atomic elements
# are integers and/or scalars.  The accumulation parameter is a list with a 
# single element, namely the "accumulated" value.  the accumulation function 
# (MAX, MIN, ...) adjusts that value in place; it acts like a global variable 
# throughout the recursion, but a separate invocation of accumulate() with a 
# different accumation parameter wouldn't conflict with it.
# The accumulation can either be initialized to an appriate value before 
# entry (such as 0.0 for SUM or 1.0 for PROD), or it can be set to True (i.e.,
# accumulation = [True]), in which case the very first atomic array element
# encountered is used.  Note that accumulation=[None] is used to indicate that
# uninitialized or incompatible array values were encountered, so this setting
# should not be used when invoking accumulate().
fnMAX = 0
fnMIN = 1
fnPROD = 2
fnSUM = 3
def accumulate(array, function, accumulation):
    
    def prod(x, y):
        return x * y
    
    def sum(x, y):
        return x + y
    
    if accumulation[0] == None:
        return
    if array == None:
        accumulation[0] = None
        return
    if functionType == fnMAX:
        function = max
    elif functionType == fnMIN:
        function = min
    elif functionType == fnPROD:
        function = prod
    elif functionType == fnSUM:
        function = sum
    else:
        accumulation[0] = None
        return
    
    if isinstance(array, tuple):
        for e in array:
            accumulate(e, functionType, accumulation)
            if accumulation[0] == None:
                return 
    elif accumulation[0] == True:
        accumulation[0] = array
    else:
        try:
            accumulation[0] = function(accumulation[0], array)
        except:
            accumulation[0] = None

def identityMatrix(n):
    result = []
    for i in range(n):
        row = [0.0]*n
        row[i] = 1.0
        result.append(row)
    return result

# Assumes the inner dimensions match and all entries are initialized (!= None)
def matrixMultiply(a, b):
    numRows = len(a)
    numCols = len(b[0])
    numInner = len(b) # == len(a[0])
    result = []
    for i in range(numRows):
        row = []
        for j in range(numCols):
            s = 0
            for k in range(numInner):
                s += a[i][k] * b[k][j]
            row.append(s)
        result.append(row)
    return result

# "Flatten" a composite object (list of lists of ... or tuple of tuples of ...)
# onto the end of a list.
def flatten(object, onto):
    if isinstance(object, (list, tuple)):
        for e in object:
            flatten(e, onto)
    else:
        onto.append(object)

# If this function returns, which in principle it might not if executing
# an actual flight program, it returns the current computation stack.
# That would normally be empty if full statements had been executed.
# However, this allow executing (say) just an expression without popping
# the value from the stack at the end, which is useful for the compiler
# since it can then use it to compute things like INITIAL(...) or 
# CONSTANT(...) for DECLARE statements.  If there is failure, for example
# the use of an unimplemented built-in function or referencing an 
# uninitialized variable, then None is returned instead.
def executePALMAT(rawPALMAT, pcScope=0, pcOffset=0, newInstantiation=False, \
                  trace=False, indent=0):
    if newInstantiation:
        PALMAT = clonePALMAT(rawPALMAT)
    else:
        PALMAT = rawPALMAT
    scopes = PALMAT["scopes"]
    scopeNumber = pcScope
    instructionIndex = pcOffset
    scope = scopes[scopeNumber]
    scope0 = scopes[0]
    computationStack = []
    while instructionIndex < len(scope["instructions"]):
        identifiers = scope["identifiers"]
        instructions = scope["instructions"]
        instruction = instructions[instructionIndex]
        if "subscripts" in scope0 and "fetch" not in instruction and \
                "fetchp" not in instruction:
            print("\tImplementation error, subscript(s) without variable in instruction:", \
                  instruction)
            return None
        if "subscripts" in scope0:
            subscripts = scope0.pop("subscripts")
        else:
            subscripts = []
        instructionIndex += 1
        if trace:
            print("\tTRACE:  ", computationStack, instruction)
        stackSize = len(computationStack)
        if "debug" in instruction:
            pass
        elif "empty" in instruction:
            computationStack.append(None)
        elif "fill" in instruction:
            computationStack.append({"fill"})
        elif "string" in instruction:
            computationStack.append(instruction["string"])
        elif "boolean" in instruction:
            computationStack.append(instruction["boolean"])
        elif "number" in instruction:
            computationStack.append(stringifiedToFloat(instruction["number"]))
        elif "vector" in instruction:
            computationStack.append(instruction["vector"])
        elif "matrix" in instruction:
            computationStack.append(instruction["matrix"])
        elif "array" in instruction:
            computationStack.append(instruction["array"])
        elif "bitarray" in instruction:
            computationStack.append(stringifiedToFloat(instruction["bitarray"]))
        elif "+><" in instruction:
            si, identifier = instruction["+><"]
            identifier = "^" + identifier + "^"
            if stackSize < 2:
                print("\tImplementation error, not enough operands for '+><'.")
                return None
            operand1 = computationStack.pop()
            negativeIncrement = (operand1 < 0)
            operand2 = computationStack[-1]
            attributes = PALMAT["scopes"][si]["identifiers"][identifier]
            if attributes == None:
                print("\tImplementation error, variable %s not found." \
                      % identifier[1:-1])
                return None
            if "integer" not in attributes and "scalar" not in attributes:
                print("\tImplementation error in '+><': Not a number.")
                return None
            if "value" not in attributes:
                print("\tImplementation error in '+><': Uninitialized variable.")
                return None
            operand1 += attributes["value"]
            if "integer" in attributes:
                attributes["value"] = hround(operand1)
            else:
                attributes["value"] = operand1
            if negativeIncrement:
                computationStack[-1] = convertToBitArray(operand1 < operand2)
            else:
                computationStack[-1] = convertToBitArray(operand1 > operand2)
        elif "sentinel" in instruction:
            computationStack.append({"sentinel"})
        elif False and "condense" in instruction:
            if instruction["condense"] == "end":
                computationStack.append({"condense"})
            else:
                popped = []
                while True:
                    value = computationStack.pop()
                    if value == {"condense"}:
                        break
                    popped.append(value)
                condensed = []
                for v in reversed(popped):
                    if isinstance(v, list) and len(v) == 1 \
                            and isinstance(v[0], tuple):
                        v = list(v[0])
                    else:
                        v = [v]
                    condensed.extend(v)
                computationStack.append(condensed)
        elif "operator" in instruction:
            operator = instruction["operator"]
            if False:
                pass
            elif operator == "#":
                if stackSize < 2:
                    print(("\tImplementation error, not enough operands " + \
                          "for operator \"%s\"") % operator)
                    return None
                operand1 = hround(computationStack.pop())
                # Recall that if a single item is being repeated, it is present
                # as itself, but if a group of items are being repeated then
                # that group appears on the computation stack in the form of 
                # a single item because the group is wrapped in [(...)].  That
                # particular wrapping is chosen because it's distinguishable 
                # from VECTOR, MATRIX, and ARRAY.
                if computationStack[-1] == {'sentinel'}:
                    computationStack.pop()
                    operands2 = [None]
                else:
                    operands2 = []
                    while True:
                        value = computationStack.pop()
                        if value == {'sentinel'}:
                            break
                        flatten(value, operands2)
                while operand1 > 0:
                    # I want to insert all the elements in operands2 into
                    # computation stack.  If I use the list .extend method
                    # for this, I find they end up in reversed order, so I
                    # want to do the insertion at the beginning rather than
                    # at the end.  I want to do this in place, without 
                    # creating a new computationStack object.
                    #computationStack.extend(operands2)
                    #computationStack[0:0] = operands2
                    computationStack.extend(reversed(operands2))
                    operand1 -= 1
            elif operator == "subscripts":
                subscripts = []
                while True:
                    value = computationStack.pop()
                    if value == {"sentinel"}:
                        break
                    subscripts.append(value)
                if len(subscripts) < 1:
                    print("\tSubscript operator without subscripts.")
                    return None
                scope0["subscripts"] = subscripts
            elif operator in ["U-", "NOT"]: # Unary operators.
                if stackSize < 1:
                    print(("\tImplementation error, not enough operands " + \
                          "for operator \"%s\"") % operator)
                    return None
                operand = computationStack[-1]
                if operator == "U-":
                    isi,isis,isv,ism = checkArithmeticalDatatype(operand)
                    if ism:
                        numRows = len(operand)
                        numCols = len(operand[0])
                        result = []
                        for i in range(numRows):
                            row = []
                            for j in range(numCols):
                                row.append(-operand[i][j])
                            result.append(row)
                    elif isv:
                        numCols = len(operand)
                        result = []
                        for j in range(numCols):
                            result.append(-operand[j])
                    elif isis:
                        result = -operand
                    else:
                        print("\tIncompatible operand for negation.")
                        return None
                elif operator == "NOT":
                    if not isBitArray(operand):
                        print("\tNot bit array:", operand)
                        return None
                    numbits = operand[1]
                    result = (((1<<numbits)-1) & ~operand[0], numbits)
                else:
                    print(("Implementation error, unary operator \"%s\" " + \
                           "not yet implemented") % operator)
                    return None
                computationStack[-1] = result
            elif operator in ["+", "-", "", "/", "**", ".", "*", "C||", "OR", 
                              "AND", "==", "!=", "<", ">", "<=", ">="]: 
                # binary operators.
                if stackSize < 2:
                    print(("Implementation error, not enough operands " + \
                          "for operator \"%s\"") % operator)
                    return None
                result = None
                operand1 = computationStack[-1]
                operand2 = computationStack[-2]
                computationStack.pop()
                computationStack[-1] = None
                # For some overloaded operators, check out types of operands.
                if operator in ["+", "-", "", "/", "**", ".", "*"]:
                    isi1,isis1,isv1,ism1 = checkArithmeticalDatatype(operand1)
                    isi2,isis2,isv2,ism2 = checkArithmeticalDatatype(operand2)
                # When VECTOR and MATRIX datatypes are involved in operations
                # like addition, multiplication, etc., refer to the "HAL/S 
                # Programmer's Guide", Chapter 7, for lists of compatible 
                # datatypes for operand1 and operand2, as well as details about
                # the results that are supposed to be produced.
                if operand1 != None and operand2 != None:
                    if operator == "+":
                        if ism1 and ism2 and \
                                len(operand1) == len(operand2) and \
                                len(operand1[0]) == len(operand2[0]):
                            numRows = len(operand1)
                            numCols = len(operand1[0])
                            result = []
                            for i in range(numRows):
                                row = []
                                for j in range(numCols):
                                    row.append(operand1[i][j] + operand2[i][j])
                                result.append(row)
                        elif isv1 and isv2 and \
                                len(operand1) == len(operand2):
                            numCols = len(operand1)
                            result = []
                            for j in range(numCols):
                                result.append(operand1[j] + operand2[j])
                        elif isi1 and isi2:
                            result = operand1 + operand2
                        elif isis1 and isis2:
                            result = float(operand1) + float(operand2)
                        else:
                            print("\tIncompatible operands for addition.")
                            return None
                    elif operator == "-":
                        if ism1 and ism2 and \
                                len(operand1) == len(operand2) and \
                                len(operand1[0]) == len(operand2[0]):
                            numRows = len(operand1)
                            numCols = len(operand1[0])
                            result = []
                            for i in range(numRows):
                                row = []
                                for j in range(numCols):
                                    row.append(operand1[i][j] - operand2[i][j])
                                result.append(row)
                        elif isv1 and isv2 and \
                                len(operand1) == len(operand2):
                            numCols = len(operand1)
                            result = []
                            for j in range(numCols):
                                result.append(operand1[j] - operand2[j])
                        elif isi1 and isi2:
                            result = operand1 - operand2
                        elif isis1 and isis2:
                            result = float(operand1) - float(operand2)
                        else:
                            print("\tIncompatible operands for addition.")
                            return None
                    elif operator == "":
                        if isi1 and isi2:
                            result = operand1 * operand2
                        elif isis1 and isis2:
                            result = float(operand1) * float(operand2)
                        elif (isis1 and isv2) or (isv1 and isis2):
                            if isis1:
                                s = operand1
                                v = operand2
                            else:
                                s = operand2
                                v = operand1
                            numCols = len(v)
                            result = []
                            for i in range(numCols):
                                result.append(s * v[i])
                        elif (isis1 and ism2) or (ism1 and isis2):
                            if isis1:
                                s = operand1
                                m = operand2
                            else:
                                s = operand2
                                m = operand1
                            numRows = len(m)
                            numCols = len(m[0])
                            result = []
                            for i in range(numRows):
                                row = []
                                for j in range(numCols):
                                    row.append(s * m[i][j])
                                result.append(row)
                        elif isv1 and isv2:
                            numRows = len(operand1)
                            numCols = len(operand2)
                            result = []
                            for i in range(numRows):
                                row = []
                                for j in range(numCols):
                                    row.append(operand1[i] * operand2[j])
                                result.append(row)
                        elif ism1 and ism2 and \
                                len(operand1[0]) == len(operand2):
                            result = matrixMultiply(operand1, operand2)
                        elif isv1 and ism2 and len(operand1) == len(operand2):
                            numInner = len(operand1)
                            numCols = len(operand2[0])
                            result = []
                            for j in range(numCols):
                                s = 0
                                for k in range(numInner):
                                    s += operand1[k] * operand2[k][j]
                                result.append(s)
                        elif ism1 and isv2 and len(operand1[0]) == len(operand2):
                            numRows = len(operand1)
                            numInner = len(operand2)
                            result = []
                            for i in range(numRows):
                                s = 0
                                for k in range(numInner):
                                    s += operand1[i][k] * operand2[k]
                                result.append(s)
                        else:
                            print("\tIncompatible operands for multiplication.")
                            return None
                    elif operator == "/":
                        # I've so far not found any explanation of what happens
                        # with division by zero.
                        if not isis2:
                            print("\tIncompatible datatype for divisor.")
                            return None
                        operand2 = float(operand2)
                        if ism1:
                            numRows = len(operand1)
                            numCols = len(operand1[0])
                            result = []
                            for i in range(numRows):
                                row = []
                                for j in range(numCols):
                                    row.append(operand1[i][j] / operand2)
                                result.append(row)
                        elif isv1:
                            numCols = len(operand1)
                            result = []
                            for j in range(numCols):
                                result.append(operand1[j] / operand2)
                        elif isis1:
                            result = float(operand1) / operand2
                        else:
                            print("\tIncompatible datatype for dividend.")
                            return None
                    elif operator == "**":
                        if ism1 and isis2 and len(operand1) == len(operand1[0]):
                            n = len(operand1)
                            operand2 = hround(operand2)
                            if operand2 == 0:
                                result = identityMatrix(n)
                            elif operand2 < 0:
                                operand1 = matrixInverse(operand1)
                                result = copy.deepcopy(operand1)
                                operand2 = -operand2
                                if operand1 == None:
                                    print("\tMatrix is singular.")
                                    return None
                            else:
                                result = copy.deepcopy(operand1)
                            while operand2 > 1:
                                result = matrixMultiply(operand1, result)
                                operand2 -= 1
                        elif isis1 and isis2:
                            result = operand1 ** operand2
                        else:
                            print("\tUnsupported operand type(s) for **.")
                            return None
                    elif operator == "C||": # string concatenation.
                        result = operand1 + operand2
                    elif operator in ["AND", "OR" ]:
                        if not isBitArray(operand1):
                            print("\tNot bit array:", operand1)
                            return None
                        if not isBitArray(operand2):
                            print("\tNot bit array:", operand2)
                            return None
                        numbits = min(operand1[1], operand2[1])
                        if operator == "OR":
                            result = (operand1[0] | operand2[0], numbits)
                        else: # "AND"
                            result = (operand1[0] & operand2[0], numbits)
                    elif operator == "==":
                        result = convertToBitArray(operand1 == operand2)
                    elif operator == "!=":
                        result = convertToBitArray(operand1 != operand2)
                    elif operator == "<":
                        result = convertToBitArray(operand1 < operand2)
                    elif operator == ">":
                        result = convertToBitArray(operand1 > operand2)
                    elif operator == "<=":
                        result = convertToBitArray(operand1 <= operand2)
                    elif operator == ">=":
                        result = convertToBitArray(operand1 >= operand2)
                    elif operator == ".":
                        if isVector(operand1) and isVector(operand2) \
                                and len(operand1) == len(operand2):
                            result = 0
                            for i in range(len(operand1)):
                                result += operand1[i] * operand2[i]
                    elif operator == "*":
                        if isVector(operand1) and isVector(operand2) \
                                and len(operand1) == 3 and len(operand2) == 3:
                            result = [
                                operand1[1]*operand2[2]-operand1[2]*operand2[1],
                                operand1[2]*operand2[0]-operand1[0]*operand2[2],
                                operand1[0]*operand2[1]-operand1[1]*operand2[0]                                
                                ]
                        else:
                            print("\tOperands of * must be initialized 3-vectors.")
                            return None
                    else:
                        print(("\tImplementation error, binary operator \"%s\" " + \
                               "not yet implemented") % operator)
                        return None
                    if result == None:
                        print("\tUninitialized values in expression.")
                        return None
                    computationStack[-1] = result
                else:
                    print("\tImplementation error, unknown binary operator \"%s\"" \
                                                                    % operator)
                    return None
        elif "fetch" in instruction or "fetchp" in instruction or \
                "store" in instruction or "storepop" in instruction:
            erroredUp = False
            fetch = False
            fetchp = False
            pop = False
            stackPos = 1
            if "fetch" in instruction:
                si, identifier = instruction["fetch"]
                fetch = True
            elif "fetchp" in instruction:
                si, identifier = instruction["fetchp"]
                fetchp = True
            elif "store" in instruction:
                si, identifier = instruction["store"]
            elif "storepop" in instruction:
                si, identifier = instruction["storepop"]
                pop = True
            if si == -1:
                if "assignments" not in scope:
                    print("\tCannot find identifier", identifier)
                    return None
                si, identifier = scope["assignments"][identifier]
            caratIdentifier = "^" + identifier + "^"
            try:
                attributes = PALMAT["scopes"][si]["identifiers"][\
                                                        caratIdentifier]
            except:
                print("\tProblem with PALMAT instruction:", instruction)
                print("\tnum scopes =", len(PALMAT["scopes"]))
                print("\ttype of si =", type(si))
                print("\tscope number =", si, " identifier =", caratIdentifier)
                print("\tidentifiers =", PALMAT["scopes"][si]["identifiers"])
                return None
            identifier = "^" + identifier + "^"
            erroredUp = True
            if fetch:
                if "value" in attributes:
                    value = subscripted(attributes["value"], subscripts)
                elif "constant" in attributes:
                    value = subscripted(attributes["constant"], subscripts)
                else:
                    print("\tIdentifier %s uninitialized" % identifier)
                    return None
                if value == None:
                    print("\tCannot compute value.")
                    return None
                computationStack.append(value)
            elif fetchp:
                computationStack.append(tuple([(si, identifier)]))
            else: # store
                if len(computationStack) < stackPos:
                    print("\tImplementation error, stack too short for " +
                          "STOREXXX instruction")
                    return None
                value = copy.deepcopy(computationStack[-stackPos])
                if pop:
                    computationStack.pop(-stackPos)
                if "constant" in attributes:
                    print("\tCannot change value of constant %s." \
                          % identifier[1:-1])
                    return None
                if isinstance(value, str):
                    if "character" not in attributes:
                        print("\tCannot store string in non-CHARACTER " +
                              "variable %s." % identifier[1:-1])
                        return None
                    maxlen = attributes["character"]
                    value = value[:maxlen]
                elif isinstance(value, (float, int)):
                    if "scalar" not in attributes and \
                            "integer" not in attributes and \
                            "bit" not in attributes:
                        print("\tCannot store arithmetic value in " + \
                              "variable %s." \
                              % identifier[1:-1])
                        return None
                    if "integer" in attributes:
                        value = hround(value)
                    elif "scalar" in attributes:
                        value = float(value)
                elif isBitArray(value) and "bit" in attributes:
                    length = attributes["bit"]
                    value = (value[0] & ((1 << length)-1) , value[1])
                elif isVector(value) and "vector" in attributes:
                    numRows = len(value)
                    if numRows != attributes["vector"]:
                        print("\tVector length mismatch in store operation:", \
                              identifier[1:-1])
                        return None
                elif isMatrix(value) and "matrix" in attributes:
                    dimensions = [len(value), len(value[0])]
                    if dimensions != attributes["matrix"]:
                        print("\tMatrix geometry mismatch in store operation:",\
                              identifier[1:-1])
                        return None
                elif "array" in attributes:
                    dimensions = attributes["array"]
                    if not isArray(value, dimensions):
                        print("\tArray geometry wrong in store operation:", \
                              identifier[1:-1])
                        return None
                else:
                    print("\tMismatched datatypes in store operation.")
                    return None
                attributes["value"] = value
            if not erroredUp:
                print("\tIdentifier %s not in any accessible scope" \
                      % identifier[1:-1])
                return None
        elif "pop" in instruction:
            value = instruction["pop"]
            if value <= stackSize:
                while value > 0:
                    computationStack.pop()
                    value -= 1
            else:
                print("\tImplementation error, too many POPs: %d vs %d" \
                      % (value, stackSize))
                return None
        elif "read" in instruction:
            lun = instruction["read"]
            if lun == '5':
                # If this instruction is within a subroutine, then we can 
                # only regress in the computation stack until finding the 
                # return address, because we want to use that later (for 
                # returning!) rather than using it now for printing.
                start = 0
                for i in range(len(computationStack)-1, -1, -1):
                    entry = computationStack[i]
                    # The return address, if it's present, is of the form
                    # (index, offset), whereas there are likely a lot of 
                    # "pointers" to variables, of the form 
                    # ((index, identifier)).  So in looking for the start of
                    # the list of variables to be read, we have to distinguish
                    # between tuples with and without a nested tuple.
                    if not isinstance(entry, tuple) or len(entry) != 2:
                        continue
                    start = i + 1
                    break
                if start < len(computationStack):
                    semicolon = False
                    for value in computationStack[start:]:
                        if semicolon:
                            break
                        # In reality, we could have subscripted VECTOR, MATRIX,
                        # or ARRAY variables here. For now, I'm just ignoring 
                        # that possibility and implementing unsubscripted
                        # variables.
                        si = value[0][0]
                        identifier = value[0][1]
                        attributes = \
                            PALMAT["scopes"][si]["identifiers"][identifier]
                        if "vector" in attributes:
                            rowLength = attributes["vector"]
                            for i in range(rowLength):
                                value = readItemLUN5()
                                if value == ";":
                                    semicolon = True
                                    break
                                if value == "":
                                    continue
                                attributes["value"][i] = float(value)
                        elif "matrix" in attributes:
                            numRows, numCols = attributes["matrix"]
                            for i in range(numRows):
                                if semicolon:
                                    break
                                for j in range(numCols):
                                    value = readItemLUN5()
                                    if value == ";":
                                        semicolon = True
                                        break
                                    if value == "":
                                        continue
                                    attributes["value"][i][j] = float(value)
                        elif "integer" in attributes:
                            value = readItemLUN5()
                            if value == ";":
                                semicolon = True
                            attributes["value"] = int(value)
                        elif "scalar" in attributes:
                            value = readItemLUN5()
                            if value == ";":
                                semicolon = True
                            attributes["value"] = float(value)
                        elif "bit" in attributes:
                            value = readItemLUN5()
                            bitLength = attributes["bit"]
                            if value == ";":
                                semicolon = True
                            value = int(value) & ((1 << bitLength) - 1)
                            if bitLength == 1:
                                attributes["value"] = value != 0
                            else:
                                attributes["value"] = value
                        pass
                while len(computationStack) > start:
                    computationStack.pop()
                #print()
        elif "write" in instruction:
            lun = instruction["write"]
            if lun == '6':
                print("%*s" % (indent, ""), end="")
                for value in computationStack:
                    if isBitArray(value):
                        print(" %d " % value[0], end="")
                    elif isinstance(value, (int, float, list)):
                        printVectorOrMatrix(value)
                    else:
                        print(value, end="")
                computationStack.clear()
                print()
        elif "iocontrol" in instruction:
            # We just ignore all i/o controls in WRITE for now.
            if len(computationStack) > 0:
                computationStack.pop()
        elif "shaping" in instruction:
            shapingFunction = instruction["shaping"]
            if shapingFunction in ["integer", "scalar", "vector", "matrix",
                                   "doubleinteger", "doublescalar",
                                   "doublevector", "doublematrix"]:
                operand = computationStack.pop()
                if operand == {"sentinel"}:
                    # The shaping function has subscripts, and hence has
                    # operands representing both the dimensionality of the
                    # array, vector, or matrix to be produced, but also the
                    # data to fill the object.  First collect the dimensions.
                    dimensions = []
                    while True:
                        operand = computationStack.pop()
                        if operand == {"sentinel"}:
                            break
                        dimensions.append(operand)
                    # We now have the dimensionality, so let's create a Python
                    # object to hold the data.  This will be a hierarchy of 
                    # lists, for convenience while we're working with it, but
                    # depending on datatype, may need to be be converted to
                    # a hierarchy of tuples when we stick the result back on
                    # the computation stack.  If the dimensions list is empty,
                    # for an integer or scalar shaping function it means that 
                    # it's a one-dimensionsl object but the
                    # length is unknown and should be tailored to fit the 
                    # available data; whereas for a vector it means the length
                    # is the default (3) and for a matrix it means that the
                    # geometry is the default (3x3).
                    if len(dimensions) == 0:
                        if shapingFunction in ["vector", "doublevector"]:
                            dimensions.append(3)
                        elif shapingFunction in ["matrix", "doublematrix"]:
                            dimensions.append(3)
                            dimensions.append(3)
                        else:
                            # We have no predefined length for the scalar or
                            # integer array we're supposed to produce, so let's
                            # just start pull in all of the data and build it!
                            object = []
                            while True:
                                operand = computationStack.pop()
                                if operand == {"sentinel"}:
                                    break
                                flatten(operand, object)
                            if shapingFunction in ["integer", "doubleinteger"]:
                                for i in range(len(object)):
                                    object[i] = int(object[i])
                            elif shapingFunction in ["scalar", "doublescalar"]:
                                for i in range(len(object)):
                                    object[i] = float(object[i])
                            computationStack.append(tuple(object))
                elif shapingFunction in ["integer", "doubleinteger"]:
                    computationStack.append(int(operand))
                elif shapingFunction in ["scalar", "doublescalar"]:
                    computationStack.append(float(operand))
                elif shapingFunction in ["vector", "doublevector"]:
                    print("\tNot yet implemented")
                    return None
                elif shapingFunction in ["scalar", "doublescalar"]:
                    print("\tNot yet implemented")
                    return None
            else:
                print("\tImplementation error, unknown shaping function:", \
                      shapingFunction)
                return None
        elif "function" in instruction:
            function = instruction["function"]
            # First check all of the no-argument functions.
            if function in builtIns[0]:
                if function == "RANDOM":
                    # Note that this returns a number in the range [0, 1),
                    # and therefore cannot return exactly 1.  The HAL/S
                    # documentation isn't entirely clear whether values
                    # that are *exactly* 0 or 1 should be returned.
                    computationStack.append(random.random())
                elif function == "RANDOMG":
                    computationStack.append(random.gauss(0.0, 1.0))
                elif function == "RUNTIME":
                    computationStack.append(1.0e-9 * \
                                            (time.time_ns() - timeOrigin))
                else:
                    print("\tHAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            # Now all of the one-argument functions.
            elif function in builtIns[1]:
                if stackSize < 1:
                    print("\tNot enough arguments on stack for function", \
                          function)
                    return None
                operand = computationStack[-1]
                if False:
                    pass
                elif function == "MAX":
                    accumulation = [True]
                    accumulate(operand, fnMAX, accumulation)
                    if accumulation[0] in [None, True]:
                        print("\tCannot compute array function", function)
                        return None
                    computationStack[-1] = accumulation[0]
                elif function == "MIN":
                    accumulation = [True]
                    accumulate(operand, fnMIN, accumulation)
                    if accumulation[0] in [None, True]:
                        print("\tCannot compute array function", function)
                        return None
                    computationStack[-1] = accumulation[0]
                elif function == "PROD":
                    accumulation = [True]
                    accumulate(operand, fnPROD, accumulation)
                    if accumulation[0] in [None, True]:
                        print("\tCannot compute array function", function)
                        return None
                    computationStack[-1] = accumulation[0]
                elif function == "SUM":
                    accumulation = [True]
                    accumulate(operand, fnSUM, accumulation)
                    if accumulation[0] in [None, True]:
                        print("\tCannot compute array function", function)
                        return None
                    computationStack[-1] = accumulation[0]
                elif function == "ABS":
                    computationStack[-1] = abs(operand)
                elif function == "CEILING":
                    computationStack[-1] = math.ceil(operand)
                elif function == "FLOOR":
                    computationStack[-1] = math.floor(operand)
                elif function == "ROUND":
                    operand = hround(operand)
                    computationStack[-1] = hround(operand)
                elif function == "SIGN":
                    if operand >= 0:
                        computationStack[-1] = 1
                    else:
                        computationStack[-1] = -1
                elif function == "SIGNUM":
                    if operand > 0:
                        computationStack[-1] = 1
                    elif operand < 0:
                        computationStack[-1] = -1
                    else:
                        computationStack[-1] = 0
                elif function == "TRUNCATE":
                    if operand >= 0:
                        computationStack[-1] = math.floor(operand)
                    else:
                        computationStack[-1] = math.ceil(operand)
                elif function == "ARCCOS":
                    computationStack[-1] = math.acos(operand)
                elif function == "ARCCOSH":
                    computationStack[-1] = math.acosh(operand)
                elif function == "ARCSIN":
                    computationStack[-1] = math.asin(operand)
                elif function == "ARCSINH":
                    computationStack[-1] = math.asinh(operand)
                elif function == "ARCTAN":
                    computationStack[-1] = math.atan(operand)
                elif function == "ARCTANH":
                    computationStack[-1] = math.atanh(operand)
                elif function == "COS":
                    computationStack[-1] = math.cos(operand)
                elif function == "COSH":
                    computationStack[-1] = math.cosh(operand)
                elif function == "SIN":
                    computationStack[-1] = math.sin(operand)
                elif function == "SINH":
                    computationStack[-1] = math.sinh(operand)
                elif function == "TAN":
                    computationStack[-1] = math.tan(operand)
                elif function == "TANH":
                    computationStack[-1] = math.tanh(operand)
                elif function == "EXP":
                    computationStack[-1] = math.exp(operand)
                elif function == "LOG":
                    computationStack[-1] = math.log(operand)
                elif function == "SQRT":
                    computationStack[-1] = math.sqrt(operand)
                elif function == "LENGTH":
                    operand = str(operand)
                    computationStack[-1] = len(operand)
                elif function == "TRIM":
                    operand = str(operand)
                    computationStack[-1] = operand.strip()
                elif function == "ODD":
                    # Note that this function returns a boolean.
                    operand = hround(operand)
                    if (operand & 1) == 0:
                        computationStack[-1] = (0, 1)
                    else:
                        computationStack[-1] = (1, 1)
                elif function == "ABVAL":
                    vector = computationStack[-1]
                    if not isVector(vector):
                        print("\tABVAL requires a vector argument.")
                        return None
                    sum = 0.0
                    for v in vector:
                        sum += v * v
                    computationStack[-1] = math.sqrt(sum)
                elif function == "UNIT":
                    vector = computationStack[-1]
                    if not isVector(vector):
                        print("\tUNIT requires a vector argument.")
                        return None
                    sum = 0.0
                    for v in vector:
                        sum += v * v
                    length = math.sqrt(sum)
                    try:
                        for i in range(len(vector)):
                            vector[i] /= length
                    except:
                        print("\tDivide by zero in UNIT function; using [1,0,...].")
                        vector = [0.0]*len(vector)
                        vector[0] = 1.0
                    computationStack[-1] = vector
                elif function == "TRACE":
                    matrix = computationStack[-1]
                    if not isMatrix(matrix) or len(matrix) != len(matrix[0]):
                        print("\tTRACE requires a square matrix argument.")
                        return None
                    sum = 0.0
                    for i in range(len(matrix)):
                        sum += matrix[i][i]
                    computationStack[-1] = sum
                elif function == "TRANSPOSE":
                    matrix = computationStack[-1]
                    if not isMatrix(matrix):
                        print("\tTRANSPOSE requires a matrix argument.")
                        return None
                    numRows = len(matrix)
                    numCols = len(matrix[0])
                    transposed = []
                    for i in range(numCols):
                        transposed.append([0]*numRows)
                    for i in range(numCols):
                        for j in range(numRows):
                            transposed[i][j] = matrix[j][i]
                    computationStack[-1] = transposed
                elif function == "DET":
                    matrix = computationStack[-1]
                    if not isMatrix(matrix) or len(matrix) != len(matrix[0]):
                        print("\tDET requires a square-matrix argument.")
                        return None
                    computationStack[-1] = determinant(matrix)
                elif function == "INVERSE":
                    matrix = computationStack[-1]
                    if not isMatrix(matrix) or len(matrix) != len(matrix[0]):
                        print("\tINVERSE requires a square-matrix argument.")
                        return None
                    inverse = matrixInverse(matrix)
                    if inverse == None:
                        print("\tMatrix is singular, and cannot be inverted.")
                        return None
                    computationStack[-1] = inverse
                else:
                    print("\tHAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            # Now all of the two-argument functions.
            elif function in builtIns[2]:
                if stackSize < 2:
                    print("\tNot enough arguments on stack for function", \
                          function)
                    return None
                operand1 = computationStack.pop()
                operand2 = computationStack[-1]
                if function == "DIV":
                    computationStack[-1] = hround(operand1) // hround(operand2)
                elif function == "REMAINDER":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 % operand2 
                    if operand1 * operand2 < 0:
                        computationStack[-1] -= operand2
                elif function == "MOD":
                    value = operand1 % operand2
                    if operand2 < 0:
                        value -= operand2
                    computationStack[-1] = value
                elif function == "ARCTAN2":
                    computationStack[-1] = math.atan2(operand2, operand1)
                elif function == "XOR":
                    if not isBitArray(operand1):
                        print("\tNot bit array:", operand1)
                        return None
                    if not isBitArray(operand2):
                        print("\tNot bit array:", operand2)
                        return None
                    numbits = min(operand1[1], operand2[1])
                    computationStack[-1] = \
                        ((operand1 ^ operand2) & ((1<<numbits)-1), numbits)
                elif function == "SHL":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 << operand2
                elif function == "SHR":
                    operand1 = hround(operand1)
                    operand2 = hround(operand2)
                    computationStack[-1] = operand1 >> operand2
                elif function == "INDEX":
                    # In Python, the character positions within the string are
                    # indexed from 0 (with -1 being "not present"), while in 
                    # HAL/S indexing is from 1 (with 0 being "not present").
                    operand1 = str(operand1)
                    operand2 = str(operand2)
                    computationStack[-1] = 1 + operand1.find(operand2)
                elif function == "LJUST":
                    operand1 = str(operand1)
                    operand2 = hround(operand2)
                    if operand2 < len(operand1):
                        computationStack[-1] = operand1[:operand2]
                        # This is also supposed to signal an error, which
                        # I have no idea about right now, so I'll have to come
                        # back to it later.
                        # TBD
                    else:
                        computationStack[-1] = "%*s" % (-operand2, operand1)
                elif function == "RJUST":
                    operand1 = str(operand1)
                    operand2 = hround(operand2)
                    if operand2 < len(operand1):
                        computationStack[-1] = operand1[:operand2]
                        # This is also supposed to signal an error, which
                        # I have no idea about right now, so I'll have to come
                        # back to it later.
                        # TBD
                    else:
                        computationStack[-1] = "%*s" % (operand2, operand1)
                else:
                    print("\tHAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            # Now all of the two-argument functions.
            elif function in builtIns[3]:
                if stackSize < 3:
                    print("\tNot enough arguments on stack for function", \
                          function)
                    return None
                operand1 = computationStack.pop()
                operand2 = computationStack.pop()
                operand3 = computationStack[-1]
                if function == "MIDVAL":
                    if operand1 > operand2:
                        operand1, operand2 = operand2, operand1
                    # We now have operand1 <= operand2.
                    if operand3 <= operand1:
                        computationStack[-1] = operand1
                    elif operand3 >= operand2:
                        computationStack[-1] = operand2
                    else:
                        computationStack[-1] = operand3
                else:
                    print("\tHAL/S built-in function", function, \
                          "not yet implemented")
                    return None
            else:
                print("\tImplementation error, function", function)
                return None
        elif "goto" in instruction:
            scopeNumber, instructionIndex = \
                    jump(PALMAT, scopeNumber, instruction, "goto")
            scope = scopes[scopeNumber]
        elif "iffalse" in instruction:
            value = computationStack.pop()
            if (value[0] & 1) == 0:
                scopeNumber, instructionIndex = \
                    jump(PALMAT, scopeNumber, instruction, "iffalse")
                scope = scopes[scopeNumber]
        elif "iftrue" in instruction:
            value = computationStack.pop()
            if (value[0] & 1) != 0:
                scopeNumber, instructionIndex = \
                    jump(PALMAT, scopeNumber, instruction, "iftrue")
                scope = scopes[scopeNumber]
        elif "noop" in instruction:
            pass # Nothing to do!
        elif "run" in instruction:
            si, identifier = instruction["run"]
            identifier = "^" + identifier + "^"
            attributes = PALMAT["scopes"][si]["identifiers"][identifier]
            if attributes == None:
                print("\tTarget of RUN not found:", identifier)
                return None
            if "program" not in attributes:
                print("\tRUN target is not a PROGRAM:", identifier)
                return None
            scopeNumber = attributes["scope"]
            instructionIndex = 0;
            scope = scopes[scopeNumber]
        elif "call" in instruction:
            si, identifier = instruction["call"]
            identifier = "^" + identifier + "^"
            attributes = PALMAT["scopes"][si]["identifiers"][identifier]
            if attributes == None:
                print("\tTarget of CALL not found:", identifier)
                return None
            if "function" not in attributes and "procedure" not in attributes:
                print("\tCALL to neither a FUNCTION nor PROCEDURE:", identifier)
                return None
            si = attributes["scope"]
            s = scopes[si]
            if "return" in s:
                print("\tRecursion in subroutine %s not allowed." \
                      % identifier[1:-1])
                return None
            # The return address.
            returnAddress = (scopeNumber, instructionIndex)
            #computationStack.append((scopeNumber, instructionIndex))
            # Transfer control.
            scopeNumber = si
            instructionIndex = 0
            scope = s
            if "assignments" in instruction:
                scope["assignments"] = copy.deepcopy(instruction["assignments"])
            scope["return"] = returnAddress
        elif "return" in instruction:
            enclosure = scope
            while enclosure != None:
                if "return" in enclosure:
                    scopeNumber, instructionIndex = enclosure["return"]
                    enclosure.pop("return")
                    if "assignments" in enclosure:
                        enclosure.pop("assignments")
                    break
                enclosure = PALMAT["scopes"][enclosure["parent"]]
            if enclosure == None:
                print("\tImplementation error, no return address.")
                return None
            #scopeNumber, instructionIndex = computationStack.pop(-stackPos)
            scope = scopes[scopeNumber]
        else:
            print("\tImplementation error, unknown PALMAT:", instruction)
            return None
    if trace:
        print("\tTRACE:  ", computationStack, "(end)")
    return computationStack
