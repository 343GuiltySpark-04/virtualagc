#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Copyright:      None - the author (Ron Burkey) declares this software to
                be in the Public Domain, with no rights reserved.
Filename:       pass1.py
Purpose:        This is for yaHAL-S-FC.py.  It tries to parse the abstract
                syntax tree output by the HAL/S compiler front-end into a 
                usable form.
History:        2022-12-12 RSB  Created.

Parsing the abstract syntax tree output by the Printer.c autogenerated by
BNF Converter is actually quite hard, and may be impossible.  That's because
strings appear in the abstract syntax simply with double-quote slapped around
them, and that means that any string literals already containing double-quotes
are going to be trashed in unpredictable ways.  We get around that by altering
Printer.c before compilation (done automatically by the makefile) by inserting
a line reading 
        #include "fixPrinter.c"
at the very beginning of the bufAppendC() function.  This, obviously, relies
on a completely-unjustified assumption about the internals of BNF Converter.
At any rate, what fixPrinter.c does is to intercept this slapping on of 
double-quotes and instead to slap on carats.  Since carats aren't in the 
HAL/S character set, they won't be appearing in strings, so this should be
safe (and now trivial to parse afterward).

But the bottom line is that we expect abstract syntax trees output from the
compiler front end to have strings delimited by carats rather than quotes.
"""

import sys
import subprocess
import re
                
tmpFile = "yaHAL-S-FC.tmp"
compiler = "modernHAL-S-FC" # Must be in the PATH.

"""
 Make the abstract syntax tree given to us as a list of strings into an actual 
 tree structure.  This is actually a recursive function.  It assumes that the
 string passed to it always starts with "(", and it processes until the 
 matching closing parenthesis is reached.  It returns
        success, tree, index
 where success is a boolean for success vs failure, tree is the tree structure
 created, and index is an index to the first unprocessed character in the 
 input string.
"""
def makeTree(abstractSyntax, index=0):
    ast = None
    if abstractSyntax[0] != "(":
        return False, None, 0
    label = ""
    startIndex = index
    index += 1
    while abstractSyntax[index] not in [" ", ")"]:
        index += 1
    label = abstractSyntax[startIndex+3:index]
    ast = { "lbnfLabel" : label, "components" : [] }
    index += 1
    if abstractSyntax[index] == ")":
        return True, ast, index
    # Loop on the components of this node.
    while True:
        # There are several possibilities.  As atomic components, we might
        # have an lbnfLabel or a string (delimited by carats) of a couple of
        # possible types.  Or else we could have a non-atomic component that
        # actually has components of its own.  In that case, we must do a 
        # recursive descent to parse it.
        if abstractSyntax[index] == "(": # non-atomic
            success, node, index = makeTree(abstractSyntax, index)
            if success:
                ast["components"].append(node)
            else:
                print("Internal error: failure to parse abstract syntax.", \
                        file=sys.stderr)
                sys.exit(1)
        elif abstractSyntax[index] == "^": # atomic string.
            start = index
            index += 1
            while abstractSyntax[index] != "^":
                index += 1
            ast["components"].append(abstractSyntax[start:index+1])
        else:
            start = index
            while abstractSyntax[index+1] not in [" ", ")"]:
                index += 1
            ast["components"].append(abstractSyntax[start:index+1])
        # At this point, index is pointing to the last character processed,
        # and the next character should be either " " or ")".
        index += 1  
        if abstractSyntax[index] == ")":
            return True, ast, index
        if abstractSyntax[index] != " ":
            print("Internal error: failure to parse abstract syntax.", \
                    file=sys.stderr)
            sys.exit(1)
        index += 1
    '''
    ast = []
    for line in astList:
        line = line.strip()
        if line == "":
            continue
        # Replace all of spaces in any string by carats.
        while True:
            match = re.search("\\^[^^]*\\s[^^]*\\^", line)
            if match == None:
                break
            line = line[:match.span()[0]+1] + \
                    match.group()[1:-1].replace(" ", "^") + \
                    line[match.span()[1]-1:]
        fields = line.split()
        depth = int(fields[0])
        label = fields[1]
        for i in range(1, len(fields)):
            if fields[i][:1] == "^":
                fields[i] = "^" + fields[i][1:-1].replace("^", " ")
        node = { "parent": -1, "depth": depth, "label" : label,
                 "fields" : fields[2:], "children" : [] }
        ast.append(node)
    for i in range(1, len(ast)):
        depth = ast[i]["depth"] - 1
        for j in range(i - 1, -1, -1):
            if ast[j]["depth"] == depth:
                ast[i]["parent"] = j
                break
    for i in range(1, len(ast)):
        parent = ast[i]["parent"]
        ast[parent]["children"].append(i)
    return success, ast
    '''

# Invoke compiler front end.  The source code to be compiled is a list of 
# strings that will be written to the temporary file (tmpFile), but if the list 
# is empty, it's assumed that the temporary file is already populated.  Returns
# a pair
#       boolean, list
# where the boolean if True/False on failure/success and the list is the 
# dictionary is an actionable form of the abstract syntax tree.  Yes this is
# cumbersome, but I see no way to use the BNF Converter framework otherwise, 
# at least not in C.
def tokenizeAndParse(sourceList=[]):
    try:
        if len(sourceList) > 0:
            f = open(tmpFile, "w")
            f.writelines(sourceList)
            f.close()
        output = subprocess.check_output([compiler, tmpFile], 
                                        stderr=subprocess.STDOUT)
        output = output.decode("utf-8").split("\n")
        for line in output:
            if "(" != line[:1]:
                continue
            return makeTree(line)[:2]
    except:
        return False, []


