#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Copyright:      None - the author (Ron Burkey) declares this software to
                be in the Public Domain, with no rights reserved.
Filename:       pass1.py
Purpose:        This is for yaHAL-S-FC.py.  It tries to parse the abstract
                syntax tree output by the HAL/S compiler front-end into a 
                usable form.
History:        2022-12-12 RSB  Created.

Parsing the abstract syntax tree output by the Printer.c autogenerated by
BNF Converter is actually quite hard, and may be impossible.  That's because
strings appear in the abstract syntax simply with double-quote slapped around
them, and that means that any string literals already containing double-quotes
are going to be trashed in unpredictable ways.  We get around that by altering
Printer.c before compilation (done automatically by the makefile) by inserting
a line reading 
        #include "fixPrinter.c"
at the very beginning of the bufAppendC() function.  This, obviously, relies
on a completely-unjustified assumption about the internals of BNF Converter.
At any rate, what fixPrinter.c does is to intercept this slapping on of 
double-quotes and instead to slap on carats.  Since carats aren't in the 
HAL/S character set, they won't be appearing in strings, so this should be
safe (and now trivial to parse afterward).

But the bottom line is that we expect abstract syntax trees output from the
compiler front end to have strings delimited by carats rather than quotes.
"""

import sys
import subprocess
import re
                
tmpFile = "yaHAL-S-FC.tmp"
compiler = "modernHAL-S-FC" # Must be in the PATH.

"""
 Make the "abstract syntax" obtained as a big string from the compiler 
 front-end into an actual abstract syntax tree (AST) structure.  This is 
 actually a recursive function.  It assumes that the abstract-syntax
 string passed to it always starts with "(", and it processes until the 
 matching closing parenthesis is reached, which is not necessarily the end
 of the string itself.  It returns
        success, tree, index
 where success is a boolean for success vs failure, tree is the tree structure
 created, and index is an index to the first unprocessed character in the 
 input string.
 
 The abstract syntax tree itself is in the form of a linked nodes that are 
 dictionaries generally having the form
    {
        "lbnfLabel" : string,
        "components" : [ ... strings or nodes ... ]
    }
 Since by convention the LBNF labels in my HAL/S grammar always begin with
 two arbitrary capital letters present solely to make the labels unique, and 
 I may or may not remove those two prefixed capitals.  The number of prefixed
 characters to remove from LBNF labels is determined by removePrefixedCapitals.
 In the "components", the "strings mentioned are themselves lbnfLabels or
 else string literals, the latter of which are distinguished by the fact that
 they begin and end with carats.  For example, for the HAL/S LBNF grammar,
 the root node will always be
    {
        "lbnfLabel" : "compilaton",
        "components" : [ a single compile_list node ]
    }
 In general, the number of components is exactly the number of components
 in the LBNF rule associated with the (full LBNF label), except that string
 literals won't have been passed along.  If that sound confusing, consider
 the rule:
    AAreplace_stmt . REPLACE_STMT ::= "REPLACE" REPLACE_HEAD "BY" TEXT ;
 The string literals "REPLACE" and "BY" won't appear among the components,
 so the node associated with this rule would look like this:
    {
        "lbnfLabel" : "AAreplace_stmt",
        "components" : [ a REPLACE_HEAD node, a TEXT node ]
    }
"""
removePrefixedCapitals = 2 # Number of chars to remove from front of LBNF labels
def makeTree(abstractSyntax, index=0):
    ast = None
    if abstractSyntax[0] != "(":
        return False, None, 0
    label = ""
    startIndex = index
    index += 1
    while abstractSyntax[index] not in [" ", ")"]:
        index += 1
    label = abstractSyntax[startIndex+1+removePrefixedCapitals:index]
    ast = { "lbnfLabel" : label, "components" : [] }
    index += 1
    if abstractSyntax[index] == ")":
        return True, ast, index
    # Loop on the components of this node.
    while True:
        # There are several possibilities.  As atomic components, we might
        # have an lbnfLabel or a string (delimited by carats) of a couple of
        # possible types.  Or else we could have a non-atomic component that
        # actually has components of its own.  In that case, we must do a 
        # recursive descent to parse it.
        if abstractSyntax[index] == "(": # non-atomic
            success, node, index = makeTree(abstractSyntax, index)
            if success:
                ast["components"].append(node)
            else:
                print("Internal error: failure to parse abstract syntax.", \
                        file=sys.stderr)
                sys.exit(1)
        elif abstractSyntax[index] == "^": # atomic string.
            start = index
            index += 1
            while abstractSyntax[index] != "^":
                index += 1
            ast["components"].append(abstractSyntax[start:index+1])
        else:
            start = index
            while abstractSyntax[index+1] not in [" ", ")"]:
                index += 1
            ast["components"].append(abstractSyntax[start:index+1])
        # At this point, index is pointing to the last character processed,
        # and the next character should be either " " or ")".
        index += 1  
        if abstractSyntax[index] == ")":
            return True, ast, index
        if abstractSyntax[index] != " ":
            print("Internal error: failure to parse abstract syntax.", \
                    file=sys.stderr)
            sys.exit(1)
        index += 1

# Invoke compiler front end.  The source code to be compiled is a list of 
# strings that will be written to the temporary file (tmpFile), but if the list 
# is empty, it's assumed that the temporary file is already populated.  Returns
# a pair
#       boolean, list
# where the boolean if True/False on failure/success and the list is the 
# dictionary is an actionable form of the abstract syntax tree.  Yes this is
# cumbersome, but I see no way to use the BNF Converter framework otherwise, 
# at least not in C.
captured = { "stderr" : [] }
def tokenizeAndParse(sourceList=[], trace=False):
    global captured
    captured["stderr"] = []
    try:
        if len(sourceList) > 0:
            f = open(tmpFile, "w")
            f.writelines(sourceList)
            f.close()
        #output = subprocess.check_output([compiler, tmpFile])
        compilerAndParameters = [compiler]
        if trace:
            compilerAndParameters.append("--trace")
        compilerAndParameters.append(tmpFile)
        #print(compilerAndParameters)
        run =subprocess.run(compilerAndParameters, capture_output=True)
        if len(run.stderr) > 0:
            captured["stderr"] = run.stderr.decode("utf-8").strip().split("\n")
        if len(run.stdout) > 0:
            output = run.stdout.decode("utf-8").strip().split("\n")
            for line in output:
                if "(" != line[:1]:
                    #print(line, file=sys.stderr)
                    continue
                else:
                    return makeTree(line)[:2]
    except:
        pass
    return False, []

# A function that prints an abstract syntax tree.
#indenter = "    |    |    |    |    |    |    |    |    |    |    |    |    |"
#indenter = "   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |"
indenter = "░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ ░ "
indenter += indenter
def astPrint(ast, indent=0):
    print("%s" % (indenter[:indent]), end="")
    print(ast["lbnfLabel"], ":", end="")
    interrupted = False
    needNewline = True
    for component in ast["components"]:
        if isinstance(component, str):
            if interrupted:
                print("%s" % (indenter[:indent]), end="")
                interrupted = False
            print(" %s" % component, end="")
            needNewline = True
        else:
            if needNewline:
                print()
                needNewline = False
            astPrint(component, indent + 1)
            needNewline = False
            interrupted = True
    if needNewline:        
        print()
