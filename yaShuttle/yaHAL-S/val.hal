 /* 
    License:    Declared to be in the Public Domain by its author,
    		Ron Burkey.
    Purpose:	Validation and regression testing of the "modern" HAL/S
    		compiler
    Filename:	val.hal
 */
 
 /* This constant either enables (TRUE) or disables (FALSE) the time-consuming
    4.xx tests. */
 DECLARE TEST4 BOOLEAN INITIAL(TRUE);
 WRITE(6) 'Enter 0 to disable time-consuming tests, non-zero to enable.';
 READ(5) TEST4;
 
 /*---------------------------------------------------------------------------- 
   Some functions for helping to automate tests of declarations.
 	
   The TESTXXXX functions are used for testing whether a DECLARE
   produced the correct result.  To used them, feed them the name
   of an identifier, in string form, along with its basic type
   ('INTEGER', 'SCALAR', 'VECTOR', 'MATRIX', 'BIT', 'CHARACTER'),
   along with the number of a field in the ARRAY(20) returned by
   the typeof() function, and the expected value for that 
   field in either character-string form (TESTCHAR), integer form
   (TESTINT), or scalar form (TESTSCALAR).  The TESTXXXX function
   checks the basic type and the extra field value, and returns
   either TRUE (on match) or FALSE (on failure).  Note that while
   the TESTINT function is pretty foolproof, the TESTSCALAR 
   function may fail because of roundoff error the TESTCHAR
   function may fail if your notion of how typeof() has stringified
   the fields being tested isn't quite right.
 */
 
 TESTCHAR: FUNCTION(IDENTIFIER, TYPE, FIELD, VALUE) BOOLEAN;
 	DECLARE CHARACTER(32), TYPE, IDENTIFIER;
 	DECLARE CHARACTER(2048), VALUE;
 	DECLARE INTEGER, FIELD;
 	DECLARE TEST ARRAY(20) CHARACTER(256);
 	TEST = typeof(IDENTIFIER);
 	IF TEST$1 = TYPE AND TEST$FIELD = VALUE THEN RETURN TRUE;
 	RETURN FALSE;
 CLOSE TESTCHAR;
 
 TESTINT: FUNCTION(IDENTIFIER, TYPE, FIELD, VALUE) BOOLEAN;
 	DECLARE CHARACTER(32), TYPE, IDENTIFIER;
 	DECLARE INTEGER, FIELD, VALUE;
 	DECLARE TEST ARRAY(20) CHARACTER(256);
 	TEST = typeof(IDENTIFIER);
 	IF TEST$1 = TYPE AND INTEGER(TEST$FIELD) = VALUE THEN RETURN TRUE;
 	RETURN FALSE;
 CLOSE TESTINT;
 
 TESTSCALAR: FUNCTION(IDENTIFIER, TYPE, FIELD, VALUE) BOOLEAN;
 	DECLARE CHARACTER(32), IDENTIFIER, TYPE;
 	DECLARE INTEGER, FIELD;
 	DECLARE SCALAR, VALUE;
 	DECLARE TEST ARRAY(20) CHARACTER(256);
 	TEST = typeof(IDENTIFIER);
 	IF TEST$1 = TYPE AND SCALAR(TEST$FIELD) = VALUE THEN RETURN TRUE;
 	RETURN FALSE;
 CLOSE TESTSCALAR;
 
 /* The procedure PRINT_RESULT() is used to print the result ('success' or 
    'fail') of a test with a given character-string designation.  It also
    updates the global count of ERRORS, and should be CALL'd with 
    ASSIGN(ERRORS). */
 DECLARE ERRORS INTEGER INITIAL(0);
 PRINT_RESULT:
 PROCEDURE(DESIGNATION, IS_SUCCESS) ASSIGN(ERRORS);
 DECLARE DESIGNATION CHARACTER(32), IS_SUCCESS BOOLEAN, ERRORS INTEGER;
 	IF IS_SUCCESS THEN WRITE(6) DESIGNATION, ': success';
 	ELSE DO;
 		WRITE(6) DESIGNATION, ': fail';
 		ERRORS = ERRORS + 1;
 	END;
 CLOSE PRINT_RESULT;
 
 /*--------------------------------------------------------------------------*/ 
 
 WRITE(6) ;
 WRITE(6) 'Each test has a designation, such as "4.56B" or "DOT PRODUCT", for';
 WRITE(6) 'cross-referencing failures back to the associated HAL/S source code';
 WRITE(6) 'for the test procedures.';
 WRITE(6) ;
 
 WRITE(6) 'Various tests of DECLARE.';
 DECLARE SCALAR, T, X INITIAL(2.0), Y CONSTANT(3.0), Z DOUBLE;
 CALL PRINT_RESULT('1.00A', TESTCHAR('T', 'SCALAR', 16, '')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.00B', TESTSCALAR('X', 'SCALAR', 5, 2.0)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.00C', TESTSCALAR('Y', 'SCALAR', 4, 3.0)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.00D', TESTCHAR('Z', 'SCALAR', 6, 'DOUBLE')) ASSIGN(ERRORS);
 	
 DECLARE A, B DOUBLE, C INITIAL(4.0), D SCALAR CONSTANT(2 Y - 12);
 CALL PRINT_RESULT('1.01A', TESTCHAR('A', 'SCALAR', 6, '')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.01B', TESTCHAR('B', 'SCALAR', 6, 'DOUBLE')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.01C', TESTSCALAR('C', 'SCALAR', 5, 4.0)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.01D', TESTSCALAR('D', 'SCALAR', 4, -6.0)) ASSIGN(ERRORS);
 	
 DECLARE INTEGER, I, J CONSTANT(4 D + 2), K INITIAL(J + D);
 CALL PRINT_RESULT('1.02A', TESTCHAR('I', 'INTEGER', 4, '')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.02B', TESTINT('J', 'INTEGER', 4, -22)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.02C', TESTINT('K', 'INTEGER', 5, -28)) ASSIGN(ERRORS);
 
 DECLARE L INTEGER DOUBLE, M INTEGER;
 CALL PRINT_RESULT('1.03A', TESTCHAR('L', 'INTEGER', 6, 'DOUBLE')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.03B', TESTCHAR('M', 'INTEGER', 6, '')) ASSIGN(ERRORS);
 
 DECLARE CHARACTER(20), C1, C2 INITIAL('abc'), C3 CONSTANT('def'),
 	C4 CONSTANT(C3 CAT 'ghi');
 CALL PRINT_RESULT('1.04A', TESTINT('C1', 'CHARACTER', 2, 20)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.04B', TESTCHAR('C2', 'CHARACTER', 5, 'abc')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.04C', TESTCHAR('C3', 'CHARACTER', 4, 'def')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.04D', TESTCHAR('C4', 'CHARACTER', 4, 'defghi')) ASSIGN(ERRORS);
 	
 DECLARE C5 CHARACTER(30), C6 CHARACTER(20) INITIAL('sam ' CAT C3);
 CALL PRINT_RESULT('1.05A', TESTINT('C5', 'CHARACTER', 2, 30)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.05B', TESTCHAR('C6', 'CHARACTER', 5, 'sam def')) ASSIGN(ERRORS);
 	
 DECLARE BOOLEAN, B1, B2 CONSTANT(TRUE), B3 INITIAL(NOT B2);
 CALL PRINT_RESULT('1.06A', TESTINT('B1', 'BIT', 2, 1)) ASSIGN(ERRORS);
 DECLARE BB BOOLEAN;
 IF B2 AND TESTINT('B2', 'BIT', 2, 1) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('1.06B', BB) ASSIGN(ERRORS);
 IF NOT B3 AND TESTINT('B3', 'BIT', 2, 1) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('1.06C', BB) ASSIGN(ERRORS);
 	
 DECLARE B4 BOOLEAN, B5 BOOLEAN CONSTANT(NOT B2 AND B2), 
 	 B6 BOOLEAN INITIAL(B2 OR ~B2); 
 CALL PRINT_RESULT('1.07A', TESTINT('B4', 'BIT', 2, 1)) ASSIGN(ERRORS);
 IF NOT B5 AND TESTCHAR('B5', 'BIT', 4, '0, 1') THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('1.07B', BB) ASSIGN(ERRORS);
 IF B6 AND TESTCHAR('B6', 'BIT', 5, '1, 1') THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('1.07C', BB) ASSIGN(ERRORS);
 
 DECLARE CV1 CONSTANT(2); 
 DECLARE VN1 VECTOR(5); 
 DECLARE VN1A VECTOR(CV1 + 3); 
 CALL PRINT_RESULT('1.08A', TESTSCALAR('CV1', 'SCALAR', 4, 2.0)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.08B', TESTINT('VN1', 'VECTOR', 2, 5)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.08C', TESTINT('VN1A', 'VECTOR', 2, 5)) ASSIGN(ERRORS);
 
 DECLARE VN2 VECTOR(10) INITIAL(2.47); 
 DECLARE VN2A VECTOR(10) INITIAL(CV1 + 0.47); 
 DECLARE VN3 VECTOR(20) INITIAL(1, 2, 3, 4, 5, *); 
 CALL PRINT_RESULT('1.08D', TESTCHAR('VN2', 'VECTOR', 5, 
 		'2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.08E', TESTCHAR('VN2A', 'VECTOR', 5, 
 		'2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.08F', TESTCHAR('VN3', 'VECTOR', 5,
 	'1.0, 2.0, 3.0, 4.0, 5.0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None')) ASSIGN(ERRORS);
 	
 DECLARE VN3A VECTOR(3 CV1) INITIAL(1, CV1, 3, 4, 1 + CV1 2, *); 
 DECLARE VN4 VECTOR(15) CONSTANT(12); 
 DECLARE VN4A VECTOR(15) CONSTANT(12, CV1 + 11, 2 CV1 +10, *); 
 CALL PRINT_RESULT('1.08G', TESTCHAR('VN3A', 'VECTOR', 5,
 		'1.0, 2.0, 3.0, 4.0, 5.0, None')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.08H', TESTCHAR('VN4', 'VECTOR', 4,
 	'12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.08I', TESTCHAR('VN4A', 'VECTOR', 4,
 	'12.0, 13.0, 14.0, None, None, None, None, None, None, None, None, None, None, None, None')) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Some tests of expressions and arithmetic.';
 I = 1.4;
 A = 2;
 B = 12.6E2B-1 A + 6 ( I A**3 - 21 ) / 4.2;
 IF I = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.00A', BB) ASSIGN(ERRORS);
 IF A = 2.0 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.00B', BB) ASSIGN(ERRORS);
 IF ABS(B - 1241.428571) <= 0.0000005 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.00C', BB) ASSIGN(ERRORS);
 IF TRUE THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.00D', BB) ASSIGN(ERRORS);
 IF FALSE THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.00E', BB) ASSIGN(ERRORS);
 IF NOT FALSE THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.00F', BB) ASSIGN(ERRORS);
 IF NOT TRUE THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.00G', BB) ASSIGN(ERRORS);
 
 I = 5; 
 IF I < 10 THEN BB = TRUE; ELSE BB = FALSE; 
 CALL PRINT_RESULT('2.01A', BB) ASSIGN(ERRORS);
 IF I < 5 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01B', BB) ASSIGN(ERRORS); 
 IF I < 2 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01C', BB) ASSIGN(ERRORS); 
 IF I <= 10 THEN BB = TRUE; ELSE BB = FALSE; 
 CALL PRINT_RESULT('2.01D', BB) ASSIGN(ERRORS);
 IF I <= 5 THEN BB = TRUE; ELSE BB = FALSE; 
 CALL PRINT_RESULT('2.01E', BB) ASSIGN(ERRORS);
 IF I <= 2 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01F', BB) ASSIGN(ERRORS); 
 IF I > 2 THEN BB = TRUE; ELSE BB = FALSE; 
 CALL PRINT_RESULT('2.01G', BB) ASSIGN(ERRORS);
 IF I > 5 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01H', BB) ASSIGN(ERRORS); 
 IF I > 10 THEN BB = FALSE; ELSE BB = TRUE; 
 CALL PRINT_RESULT('2.01I', BB) ASSIGN(ERRORS);
 IF I >= 2 THEN BB = TRUE; ELSE BB = FALSE; 
 CALL PRINT_RESULT('2.01J', BB) ASSIGN(ERRORS);
 IF I >= 5 THEN BB = TRUE; ELSE BB = FALSE; 
 CALL PRINT_RESULT('2.01K', BB) ASSIGN(ERRORS);
 IF I >= 10 THEN BB = FALSE; ELSE BB = TRUE; 
 CALL PRINT_RESULT('2.01L', BB) ASSIGN(ERRORS);
 IF I = 2 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01M', BB) ASSIGN(ERRORS); 
 IF I = 5 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.01N', BB) ASSIGN(ERRORS); 
 IF I = 10 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01O', BB) ASSIGN(ERRORS); 
 IF I ~= 2 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.01P', BB) ASSIGN(ERRORS); 
 IF I ~= 5 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01Q', BB) ASSIGN(ERRORS); 
 IF I ~= 10 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.01R', BB) ASSIGN(ERRORS); 

 IF 'ABC' = 'A' || 'BC' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.02A', BB) ASSIGN(ERRORS); 
 IF 'AB' || 'C' = 'ABC' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.02B', BB) ASSIGN(ERRORS); 
 IF 'ABC' = 'AB' THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.02C', BB) ASSIGN(ERRORS); 
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Some tests of simple subscripting.';
 DO FOR TEMPORARY I = 1 TO 10; VN2$I = 1; END;
 IF ROUND(VN2$1) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00A', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$2) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00B', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$3) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00C', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$4) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00D', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$5) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00E', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$6) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00F', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$7) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00G', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$8) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00H', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$9) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00I', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$10) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00J', BB) ASSIGN(ERRORS);
 
 I = 0; DO WHILE I < 10; I = I + 1; VN2$I = I; END;
 IF 1 = ROUND(VN2$1 + 0) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01A', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(-1 + VN2$2) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01B', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$3 / 3) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01C', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(0.25 VN2$4) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01D', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$5 0.2) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01E', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$6 - 5) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01F', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$7 - 6) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01G', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$8 - 7) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01H', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$9 - 8) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01I', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$10 - 9) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01J', BB) ASSIGN(ERRORS);
 	
 DO FOR TEMPORARY I = 1 TO 10; VN2$I = 1; END;
 K = 0; DO FOR TEMPORARY I = 1 TO 10; IF VN2$I = 1 THEN K = K + 1; END;
 IF K = 10 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.02', BB) ASSIGN(ERRORS);
 B1=TRUE; I=0; 
 DO WHILE B1; 
 	I=I+1; 
 	IF I>=10 THEN B1=FALSE; 
 	VN2$I = I; 
 END; 	
 K = 0; DO FOR TEMPORARY I = 1 TO 10; IF VN2$I = I THEN K = K + 1; END;
 IF K = 10 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.03', BB) ASSIGN(ERRORS);
 
 B1 = TRUE; DO WHILE FALSE; B1 = FALSE; END;
 CALL PRINT_RESULT('3.04', B1) ASSIGN(ERRORS);
 B1 = FALSE; DO UNTIL TRUE; B1 = TRUE; END;
 CALL PRINT_RESULT('3.05', B1) ASSIGN(ERRORS);
 
 DO FOR TEMPORARY I = 1 TO 10; VN2$I = 1; END;
 I=0; DO UNTIL I >= 10; I=I+1; VN2$I = I; END; 
 K = 0; DO FOR TEMPORARY I = 1 TO 10; IF VN2$I = I THEN K = K + 1; END;
 IF K = 10 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.06', BB) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Various tests of DO WHILE, DO UNTIL, DO FOR.';
 /* Make TEST4 TRUE to run the various loop tests. As written, they're 
    too time-consuming to do every time, so making TEST4 FALSE skips them. */
 IF TEST4 THEN DO;
 
 WRITE(6) 'The following timing tests take about 3 seconds each ...';
 TEMPORARY SCALAR, START, THISSTART, THISTIME, STOP;
 TEMPORARY INTEGER, DELTA, RUNS CONSTANT(3);
 
 START = RUNTIME; 
 THISSTART = START;
 I = 1; DO WHILE I <= RUNS; 
 	THISTIME = RUNTIME;
 	DO WHILE THISTIME - THISSTART < 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	I = I + 1; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.00', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 I = 1; DO WHILE I <= RUNS; 
 	DO UNTIL THISTIME - THISSTART >= 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	I = I + 1; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.01', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 I = 1; DO UNTIL I > RUNS; 
 	THISTIME = RUNTIME;
 	DO WHILE THISTIME < THISSTART + 1.0; 
 		THISTIME = RUNTIME ;
 	END; 
 	I = I + 1; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.02', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 I=1; DO UNTIL I > RUNS; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME;
 	END; 
 	I = I + 1; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.03', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 DO FOR TEMPORARY I = 1 TO RUNS; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.04', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 DO FOR TEMPORARY I = 1 TO 2 RUNS BY 2; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.05', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 DO FOR TEMPORARY I = RUNS TO 1 BY -1; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.06', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 DO FOR TEMPORARY I = 1 TO 100 UNTIL I >= RUNS; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.07', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 DO FOR TEMPORARY I = 1 TO 100 WHILE I <= RUNS; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.08', B1) ASSIGN(ERRORS);
 
 WRITE(6) 'The following timing tests take about 15 seconds each ...';
 START = RUNTIME; 
 THISSTART = START;
 DO FOR A = 1.4 TO 26.3 BY 1.7; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = 15 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.09', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 DO FOR A = 25.2 TO 0.0 BY -1.7; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = 15 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.10', B1) ASSIGN(ERRORS);
 
 END; ELSE WRITE(6) 'Skipping 4.xx tests.';
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Various simple tests of FUNCTION and PROCEDURE.';
 /* Function that averages 3 floats. */ 
 AVG3: 
 FUNCTION(X, Y, Z) SCALAR; 
 	DECLARE SCALAR, X, Y, Z, T; 
 
 	/* Function that adds 3 floats. */
 	ADD3: 
 	FUNCTION(X, Y, Z) SCALAR; 
 		DECLARE X, Y, Z; 
 		DECLARE ADD2 FUNCTION SCALAR; 
 		RETURN ADD2(X, ADD2(Y, Z)); 
 		
 		/* Function that adds 2 floats. */
 		ADD2: 
 		FUNCTION(X, Y) SCALAR; 
 			DECLARE X, Y; 
 			RETURN X + Y; 
 		CLOSE; 
 		
 	CLOSE ADD3; 
 
	T = ADD3(X, Y, Z); 
 	RETURN T/3; 
 CLOSE AVG3; 
 IF ABS(AVG3(4, 5, 7) - 5.33333) <= 0.000005 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('5.00', B1) ASSIGN(ERRORS);
 
 /* A "projection" function that picks out just one
    parameter from among three, using W as an index. */
 PROJECTION3: 
 FUNCTION(W, X, Y, Z); 
 	DECLARE X, Y, Z; 
 	DECLARE W INTEGER; 
 	IF W = 1 THEN RETURN X; 
 	IF W = 2 THEN RETURN Y; 
 	IF W = 3 THEN RETURN Z; 
 	RETURN 0; 
 CLOSE PROJECTION3; 
 IF PROJECTION3(1, 100, 200, 300) = 100.0 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('5.01A', B1) ASSIGN(ERRORS);
 IF PROJECTION3(2, 100, 200, 300) = 200.0 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('5.01B', B1) ASSIGN(ERRORS);
 IF PROJECTION3(3, 100, 200, 300) = 300.0 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('5.01C', B1) ASSIGN(ERRORS);
 
 DECLARE X1 SCALAR INITIAL(0), Y1 SCALAR INITIAL(1), Y2, Z1 SCALAR INITIAL(2); 
 P: 
 PROCEDURE(X) ASSIGN(Y); 
	 DECLARE X, Y; 
	 Y=X; 
 CLOSE; 
 CALL P(39) ASSIGN(Z1); 
 IF Y1 = 1.0 AND Z1 = 39.0 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('5.02', B1) ASSIGN(ERRORS);
 
 P2: 
 PROCEDURE(A, B, C) ASSIGN(D, E, F); 
	 DECLARE A, B, C, D, E, F; 
	 D = A; 
	 E = B; 
	 F = C; 
 CLOSE P2; 
 CALL P2(123, 245, 789) ASSIGN(X1, Y2, Z1); 
 IF X1 = 123.0 AND Y2 = 245.0 AND Z1 = 789.0 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('5.03', B1) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Some tests of "shaping" functions.';
 DECLARE VC100 VECTOR(5) CONSTANT(1, 1#, 3, *); 
 CALL PRINT_RESULT('6.00', TESTCHAR('VC100', 'VECTOR', 4, '1.0, None, 3.0, None, None')) ASSIGN(ERRORS);
 DECLARE VC101 VECTOR(20) CONSTANT(VC100, 2#(2#(1,2,3), 4), 24); 
 CALL PRINT_RESULT('6.01', TESTCHAR('VC101', 'VECTOR', 4, 
 	'1.0, None, 3.0, None, None, 1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 4.0, 1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 4.0, 24.0')) ASSIGN(ERRORS);
 DECLARE VC102 VECTOR(5) CONSTANT(1, 1#2, 3, 4, 5); 
 CALL PRINT_RESULT('6.02', TESTCHAR('VC102', 'VECTOR', 4, '1.0, 2.0, 3.0, 4.0, 5.0')) ASSIGN(ERRORS);
 DECLARE VC103 VECTOR(5) CONSTANT(VC102); 
 CALL PRINT_RESULT('6.03', TESTCHAR('VC103', 'VECTOR', 4, '1.0, 2.0, 3.0, 4.0, 5.0')) ASSIGN(ERRORS);
 DECLARE VC104 VECTOR(20) CONSTANT(VC102, 2#(2#(1,2,3), 4), 24); 
 CALL PRINT_RESULT('6.04', TESTCHAR('VC104', 'VECTOR', 4, 
 	'1.0, 2.0, 3.0, 4.0, 5.0, 1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 4.0, 1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 4.0, 24.0')) ASSIGN(ERRORS);
 DECLARE VC105 VECTOR(10) CONSTANT(1, 2, VC102, 3, 4, 5); 
 CALL PRINT_RESULT('6.05', TESTCHAR('VC105', 'VECTOR', 4,
 	'1.0, 2.0, 1.0, 2.0, 3.0, 4.0, 5.0, 3.0, 4.0, 5.0')) ASSIGN(ERRORS);
 DECLARE A100 ARRAY(20) INTEGER; 
 CALL PRINT_RESULT('6.06', TESTINT('A100', 'INTEGER', 16, 20)) ASSIGN(ERRORS);
 DECLARE B100 ARRAY(20) SCALAR; 
 CALL PRINT_RESULT('6.07', TESTINT('B100', 'SCALAR', 16, 20)) ASSIGN(ERRORS);
 A100 = INTEGER(2#VC100, 10#5); 
 IF 1 = ROUND(A100$1/VC100$1) AND ROUND(A100$3/VC100$3) = 1 AND 
 	1 = ROUND(A100$6/VC100$1) AND ROUND(A100$8/VC100$3) = 1 AND
 	1 = ROUND(A100$11/5) AND ROUND(A100$12/5) = 1 AND
 	1 = ROUND(A100$13/5) AND ROUND(A100$14/5) = 1 AND
 	1 = ROUND(A100$15/5) AND ROUND(A100$16/5) = 1 AND
 	1 = ROUND(A100$17/5) AND ROUND(A100$18/5) = 1 AND 
 	1 = ROUND(A100$19/5) AND ROUND(A100$20/5) = 1 
 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('6.08A', BB) ASSIGN(ERRORS);
 DECLARE MYTYPE ARRAY(20) CHARACTER(2048);
 MYTYPE = typeofv(INTEGER(2#VC100, 10#5));
 IF MYTYPE$1 = 'INTEGER' AND MYTYPE$16 = '20' THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('6.08B', B1) ASSIGN(ERRORS);
 B100 = SCALAR(3#VC100, 5#6); 
 IF 1 = ROUND(B100$1/VC100$1) AND 1 = ROUND(B100$3/VC100$3) AND
 	1 = ROUND(B100$6/VC100$1) AND 1 = ROUND(B100$8/VC100$3) AND
 	1 = ROUND(B100$11/VC100$1) AND 1 = ROUND(B100$13/VC100$3) AND
 	1 = ROUND(B100$16/6) AND 1 = ROUND(B100$17/6) AND
 	1 = ROUND(B100$18/6) AND 1 = ROUND(B100$19/6) AND
 	1 = ROUND(B100$20/6) THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('6.09A', B1) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR(3#VC100, 5#6));
 IF MYTYPE$1 = 'SCALAR' AND MYTYPE$16 = '20' THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('6.09B', B1) ASSIGN(ERRORS);
 I = 27; K = 52;
 DECLARE A201 ARRAY(10) INTEGER; 
 BB = TRUE; 
 DO FOR TEMPORARY I = 1 TO 10; 
 	A201 = INTEGER(1, 2, 3, 4, 2 I, 6, 7, 8, 9, 10); 
 	DO FOR TEMPORARY K = 1 TO 10;
 		IF K = 5 AND A201$K ~= 2 I THEN BB = FALSE;
 		ELSE IF K ~= 5 AND A201$K ~= K THEN BB = FALSE; 
 	END;
 END; 
 CALL PRINT_RESULT('6.09C', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(I / 27) AND 1 = ROUND(K / 52) THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('6.09D', B1) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Some tests of repitition factors (#).';
 DECLARE B300 BIT(6);
 CALL PRINT_RESULT('7.00A', TESTINT('B300', 'BIT', 2, 6)) ASSIGN(ERRORS);
 MYTYPE = typeofv(34);
 IF MYTYPE$1 = 'INTEGER' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00B', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(34.2);
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00C', BB) ASSIGN(ERRORS);
 B300 = 34.2;
 IF INTEGER(B300) = 34 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00D', BB) ASSIGN(ERRORS);
 B300 = 98;
 IF INTEGER(B300) = 34 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00E', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER(B300));
 IF MYTYPE$1 = 'INTEGER' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00F', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER('34'));
 IF MYTYPE$1 = 'INTEGER' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00G', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER('34.2'));
 IF MYTYPE$1 = 'INTEGER' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00H', BB) ASSIGN(ERRORS);
 
 MYTYPE = typeofv(34.0);
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.01A', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(34.0);
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.01B', BB) ASSIGN(ERRORS);
 B300 = 98;
 MYTYPE = typeofv(SCALAR(B300));
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.01C', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR('34'));
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00D', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR('34.2'));
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.01E', BB) ASSIGN(ERRORS);
 
 DECLARE VECTOR, V300 CONSTANT(1.0, 2.0, 3.0), V301, V302; 
 DECLARE MATRIX, M300 CONSTANT(1, 2, 3, 4, 5, 6, 7, 8, 9), M301, M302; 
 DECLARE ARRAY(3), A300; 
 DECLARE A301 ARRAY(9) SCALAR, A302 ARRAY(3) SCALAR; 
 CALL PRINT_RESULT('7.02A', TESTCHAR('V300', 'VECTOR', 4, '1.0, 2.0, 3.0')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02B', TESTINT('V301', 'VECTOR', 2, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02C', TESTINT('V302', 'VECTOR', 2, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02D', TESTCHAR('M300', 'MATRIX', 4, 
 				'1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02E', TESTINT('M301', 'MATRIX', 2, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02F', TESTINT('M301', 'MATRIX', 3, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02G', TESTINT('M302', 'MATRIX', 2, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02H', TESTINT('M302', 'MATRIX', 3, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02I', TESTINT('A300', 'SCALAR', 16, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02J', TESTINT('A301', 'SCALAR', 16, 9)) ASSIGN(ERRORS);
 
 IF V300$1 = 1.0 AND V300$2 = 2.0 AND V300$3 = 3.0 THEN BB = TRUE; 
 ELSE BB = FALSE;
 CALL PRINT_RESULT('7.02K', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER(V300));
 IF MYTYPE$1 = 'VECTOR' AND MYTYPE$2 = '3' AND MYTYPE$3 = '' THEN BB = TRUE;
 ELSE BB = FALSE;
 CALL PRINT_RESULT('7.02L', BB) ASSIGN(ERRORS);
 V301 = INTEGER(V300); 
 MYTYPE = typeofv(V301$1);
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.02M', BB) ASSIGN(ERRORS);
 IF V301$1 = 1 AND V301$2 = 2 AND V301$3 = 3 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.02N', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER(1#V300));
 IF MYTYPE$1 = 'INTEGER' AND MYTYPE$16 = '3' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.02O', BB) ASSIGN(ERRORS);
 A300 = INTEGER(1#V300); 
 IF A300$1 = 1 AND V300$2 = 2 AND V300$3 = 3 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.02P', BB) ASSIGN(ERRORS);
 
 BB = TRUE; K = 1;
 DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
 	IF M300$(I,J) ~= K THEN BB = FALSE;
 	K = K + 1;
 END; END;
 CALL PRINT_RESULT('7.03A', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER(M300));
 M301 = INTEGER(M300);
 BB = TRUE; IF MYTYPE$1 ~= 'MATRIX' THEN BB = FALSE;
 CALL PRINT_RESULT('7.03B', BB) ASSIGN(ERRORS);
 BB = TRUE; K = 1;
 DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
 	IF M301$(I,J) ~= K THEN BB = FALSE;
 	K = K + 1;
 END; END;
 CALL PRINT_RESULT('7.03C', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER(1#M300));
 BB = TRUE; 
 IF MYTYPE$1 ~= 'INTEGER' OR MYTYPE$16 ~= '9'THEN BB = FALSE;
 CALL PRINT_RESULT('7.03D', BB) ASSIGN(ERRORS);
 A301 = INTEGER(1#M300); 
 BB = TRUE; DO FOR TEMPORARY I = 1 TO 9; IF A301$I ~= I THEN BB = FALSE; END;
 CALL PRINT_RESULT('7.03E', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR(V301));
 BB = TRUE; IF MYTYPE$1 ~= 'VECTOR' THEN BB = FALSE;
 CALL PRINT_RESULT('7.03F', BB) ASSIGN(ERRORS);
 V302 = SCALAR(V301);
 BB = TRUE; DO FOR TEMPORARY K = 1 TO 3; IF V302$K ~= K THEN BB = FALSE; END;
 CALL PRINT_RESULT('7.03G', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR(1#V301));
 BB = TRUE; IF MYTYPE$1 ~= 'SCALAR' OR MYTYPE$16 ~= '3' THEN BB = FALSE;
 CALL PRINT_RESULT('7.03H', BB) ASSIGN(ERRORS);
 A300 = SCALAR(1#V301); 
 BB = TRUE; DO FOR TEMPORARY K = 1 TO 3; IF A300$K ~= K THEN BB = FALSE; END;
 CALL PRINT_RESULT('7.03I', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR(M301));
 BB = TRUE; 
 IF MYTYPE$1 ~= 'MATRIX' OR MYTYPE$2 ~= '3' OR MYTYPE$3 ~= '3' THEN BB = FALSE;
 CALL PRINT_RESULT('7.03J', BB) ASSIGN(ERRORS);
 M302 = SCALAR(M301);
 BB = TRUE; K = 1;
 DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
 	IF M302$(I,J) ~= K THEN BB = FALSE;
 	K = K + 1;
 END; END;
 CALL PRINT_RESULT('7.03K', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR(1#M301));
 BB = TRUE; 
 IF MYTYPE$1 ~= 'SCALAR' OR MYTYPE$16 ~= '9' THEN BB = FALSE;
 CALL PRINT_RESULT('7.03L', BB) ASSIGN(ERRORS);
 A301 = SCALAR(1#M301);
 BB = TRUE; DO FOR TEMPORARY K = 1 TO 9; IF A301$K ~= K THEN BB = FALSE; END;
 CALL PRINT_RESULT('7.03M', BB) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Some tests of initialized vs uninitialized values and "shaping" functions.';
 DECLARE V400 VECTOR(10), V401 VECTOR(10), V402 VECTOR(10); 
 DECLARE MATRIX, M400, M400U, M401, M402; 
 CALL PRINT_RESULT('8.00A', NOT initialized(V400)) ASSIGN(ERRORS);
 V400$1=100; 
 V400$3=200; 
 V400$5=300; 
 BB = TRUE;
 DO FOR TEMPORARY I = 1 TO 10;
 	IF I = 1 OR I = 3 OR I = 5 THEN 
 		DO; IF V400$I ~= ROUND(50 (I + 1)) THEN BB = FALSE; END;
 	ELSE IF initialized(V400$I) THEN BB = FALSE;
 END; 
 CALL PRINT_RESULT('8.00B', BB) ASSIGN(ERRORS);
 DO FOR TEMPORARY I = 1 TO 10; V401$I = 49 I; END;
 CALL PRINT_RESULT('8.00C', initialized(V401)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('8.00D', NOT initialized(M400U)) ASSIGN(ERRORS);
 BB = TRUE;
 DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
 	IF NOT initialized(M300$(I,J)) THEN BB = FALSE;
 END; END;
 CALL PRINT_RESULT('8.00E', BB) ASSIGN(ERRORS);
 
 MYREVERSE:
 PROCEDURE(V) ASSIGN(W); 
 	DECLARE VECTOR(10), V, W; 
 	DO FOR TEMPORARY I = 1 TO 10; 
 		W$I = V$(11-I); 
 	END; 
 CLOSE MYREVERSE; 
 CALL MYREVERSE(V401) ASSIGN(V402); 
 BB = TRUE;
 DO FOR TEMPORARY I = 1 TO 10;
 	IF V402$I ~= 49 (11 - I) THEN BB = FALSE; 
 END; 
 CALL PRINT_RESULT('8.01A', BB) ASSIGN(ERRORS);
 
 DO FOR TEMPORARY I = 1 TO 3; 
 	DO FOR TEMPORARY J = 1 TO 3; 
 		M400$(I,J) = 10 I + J; 
 	END; 
 END; 
 DECLARE M400T MATRIX CONSTANT(11, 12, 13, 21, 22, 23, 31, 32, 33);
 DECLARE M401T MATRIX CONSTANT(11, 21, 31, 12, 22, 32, 13, 23, 33);
 BB = TRUE;
 DO FOR TEMPORARY I = 1 TO 3;
 	DO FOR TEMPORARY J = 1 TO 3;
 		IF M400$(I,J) ~= M400T$(I,J) THEN BB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('8.01B', BB) ASSIGN(ERRORS);
 
 MYTRANSPOSE:
 PROCEDURE(M) ASSIGN(MT); 
 	DECLARE MATRIX, M, MT; 
 	DO FOR TEMPORARY I = 1 TO 3; 
 		DO FOR TEMPORARY J = 1 TO 3; 
 			MT$(I, J) = M$(J, I); 
 		END; 
 	END; 
 CLOSE MYTRANSPOSE; 
 CALL MYTRANSPOSE(M400) ASSIGN(M401); 
 BB = TRUE;
 DO FOR TEMPORARY I = 1 TO 3;
 	DO FOR TEMPORARY J = 1 TO 3;
 		IF M401$(I,J) ~= M401T$(I,J) THEN BB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('8.01C', BB) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Some tests of automatic datatype conversions.';
 DECLARE I590 INTEGER, X590 SCALAR, 
 	B590 BIT(4), B591 BIT(5) INITIAL(23), 
 	B595 BIT(4) INITIAL(5), B596 BIT(4) INITIAL(6), B597 BIT(4) INITIAL(7),
 	C590 CHARACTER(25),
 	V590 VECTOR(5), 
 	M590 MATRIX(4,6), 
 	A590 ARRAY(5) INTEGER, A591 ARRAY(5) VECTOR(4),
 	TST CHARACTER(10);
 I590 = 6;
 IF I590 = 6 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.00A', BB) ASSIGN(ERRORS);
 I590 = 5.4;
 IF I590 = 5 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.00B', BB) ASSIGN(ERRORS);
 I590 = '7.2';
 IF I590 = 7 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.00C', BB) ASSIGN(ERRORS);
 I590 = B591;
 IF I590 = 23 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.00D', BB) ASSIGN(ERRORS);
 
 X590 = 6;
 IF X590 = 6.0 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.01A', BB) ASSIGN(ERRORS);
 X590 = 5.4;
 IF X590 = 5.4 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.01B', BB) ASSIGN(ERRORS);
 X590 = '7.2';
 IF X590 = 7.2 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.01C', BB) ASSIGN(ERRORS);
 X590 = B591;
 IF X590 = 23.0 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.01D', BB) ASSIGN(ERRORS);
 
 C590 = 6;
 IF C590 = '6' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.02A', BB) ASSIGN(ERRORS);
 WRITE(6) 'Unfortunately, I had to hard-code the implementation-dependent';
 WRITE(6) 'arithmetical precision into test 9.02B below.';
 C590 = 5.4;
 IF C590 = ' 5.40000000000000E+00' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.02B', BB) ASSIGN(ERRORS);
 C590 = '7.2';
 IF C590 = '7.2' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.02C', BB) ASSIGN(ERRORS);
 C590 = B591;
 IF C590 = '10111' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.02D', BB) ASSIGN(ERRORS);
 
 B590 = 6;
 IF B590 = B596 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.03A', BB) ASSIGN(ERRORS);
 B590 = 5.4;
 IF B590 = B595 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.03B', BB) ASSIGN(ERRORS);
 B590 = '10111';
 IF B590 = B597 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.03V', BB) ASSIGN(ERRORS);
 B590 = B591;
 IF B590 = B597 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.03D', BB) ASSIGN(ERRORS);
 
 DECLARE M591 MATRIX(2,3), M592 MATRIX(2,6), M593 MATRIX(4, 3), 
 	BBB BOOLEAN, 
 	A592 ARRAY(2, 3) MATRIX(4,6), A593 ARRAY(2, 3) MATRIX(4, 6),
 	V591 VECTOR(6), V592 VECTOR(4), 
 	A594 ARRAY(3) SCALAR, A595 ARRAY(2) SCALAR;
 DO FOR TEMPORARY I = 1 TO 4;
 	DO FOR TEMPORARY J = 1 TO 6;
 		M590$(I,J) = 10 I + J;
 	END;
 END;
 M591 = M590$(2 TO 3, 3 TO 5);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 3;
 		IF M591$(I, J) ~= 10 (I + 1) + (J + 2) THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04A', BBB) ASSIGN(ERRORS);
 M592 = M590$(2 TO 3, *);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 6;
 		IF M592$(I, J) ~= 10 (I + 1) + J THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04B', BBB) ASSIGN(ERRORS);
 M593 = M590$(*, 3 TO 5);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 4;
 	DO FOR TEMPORARY J = 1 TO 3;
 		IF M593$(I, J) ~= 10 I + (J + 2) THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04C', BBB) ASSIGN(ERRORS);
 M592 = M590$(2 TO 3, 1 TO #);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 6;
 		IF M592$(I, J) ~= 10 (I + 1) + J THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04D', BBB) ASSIGN(ERRORS);

 M591 = M590$(2 AT 2, 3 AT 3);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 3;
 		IF M591$(I, J) ~= 10 (I + 1) + (J + 2) THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04E', BBB) ASSIGN(ERRORS);
 M592 = M590$(2 AT 2, *);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 6;
 		IF M592$(I, J) ~= 10 (I + 1) + J THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04F', BBB) ASSIGN(ERRORS);
 M593 = M590$(*, 3 AT 3);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 4;
 	DO FOR TEMPORARY J = 1 TO 3;
 		IF M593$(I, J) ~= 10 I + (J + 2) THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04G', BBB) ASSIGN(ERRORS);
 M592 = M590$(2 AT 2, 6 AT 1);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 6;
 		IF M592$(I, J) ~= 10 (I + 1) + J THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04H', BBB) ASSIGN(ERRORS);
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 3;
 		DO FOR TEMPORARY K = 1 TO 4;
 			DO FOR TEMPORARY L = 1 TO 6;
 				A592$(I,J;K,L) = 1000 I + 100 J + 10 K + L;
 			END;
 		END;
 	END;
 END;
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 3;
 		DO FOR TEMPORARY K = 1 TO 4;
 			DO FOR TEMPORARY L = 1 TO 6;
 				IF A592$(I,J;K,L) ~= 1000 I + 100 J + 10 K + L
 				THEN BBB = FALSE;
 			END;
 		END;
 	END;
 END;
 CALL PRINT_RESULT('9.04I', BBB) ASSIGN(ERRORS);
 V591 = A592$(1, 2; 3, *);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 6; 
 	IF V591$I ~= 1230 + I THEN BBB = FALSE;
 END;
 CALL PRINT_RESULT('9.04J', BBB) ASSIGN(ERRORS);
 V592 = A592$(2, 1; *, 4);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 4; 
 	IF V592$I ~= 2104 + 10 I THEN BBB = FALSE;
 END;
 CALL PRINT_RESULT('9.04K', BBB) ASSIGN(ERRORS);
 A594 = A592$(2, *; 2, 3);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 3; 
 	IF A594$I ~= 2023 + 100 I THEN BBB = FALSE;
 END;
 CALL PRINT_RESULT('9.04L', BBB) ASSIGN(ERRORS);
 A595 = A592$(*, 2; 1, 2);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2; 
 	IF A595$I ~= 0212 + 1000 I THEN BBB = FALSE;
 END;
 CALL PRINT_RESULT('9.04M', BBB) ASSIGN(ERRORS);
 A593 = A592;
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 3;
 		DO FOR TEMPORARY K = 1 TO 4;
 			DO FOR TEMPORARY L = 1 TO 6;
 				IF A593$(I,J;K,L) ~= 1000 I + 100 J + 10 K + L
 				THEN BBB = FALSE;
 			END;
 		END;
 	END;
 END;
 CALL PRINT_RESULT('9.04N', BBB) ASSIGN(ERRORS);
 A593$(1, 1; 2 TO 3, 3 TO 5) = A592$(2, 2; 1 TO 2, 2 TO 4);
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 3;
 		DO FOR TEMPORARY K = 1 TO 4;
 			DO FOR TEMPORARY L = 1 TO 6;
 				IF I = 1 AND J = 1 AND K >= 2 AND K <= 3
 					AND L >= 3 AND L <= 5 THEN 
 				DO;
	 				IF A593$(I,J;K,L) ~= 1000 (I + 1) + 
	 						     100 (J + 1) + 
	 						     10 (K - 1) + 
	 						     (L - 1)
	 				THEN BBB = FALSE;
 				END;
 				ELSE DO;
	 				IF A593$(I,J;K,L) ~= 
	 					1000 I + 100 J + 10 K + L
	 				THEN BBB = FALSE;
 				END;
 			END;
 		END;
 	END;
 END;
 CALL PRINT_RESULT('9.04O', BBB) ASSIGN(ERRORS);
 
 DECLARE A596I ARRAY(2,3) INTEGER, A596S ARRAY(2,3) SCALAR,
 	 A596V4 ARRAY(2,3) VECTOR(4);
 A596I = INTEGER$(2, 3)(11, 12, 13, 21, 22, 23);
 A596S = SCALAR$(2, 3)(110, 120, 130, 210, 220, 230);
 I = 111;
 A596V4 = SCALAR$(2, 3; 4)(I, 112, 113, 114,
 			   121, 122, 123, 124,
 			   131, 132, 133, 134,
 			   211, 212, 213, 214,
 			   221, 222, 223, 224,
 			   231, 232, 233, 234);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2; 
 DO FOR TEMPORARY J = 1 TO 3;
 DO FOR TEMPORARY K = 1 TO 4;
 	IF A596V4$(I, J; K) ~= 100 I + 10 J + K THEN BBB = FALSE;
 END; END; END;
 CALL PRINT_RESULT('9.04P', BBB) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
  /* Test equality with a tolerance. */
  REALLY_CLOSE_TO: FUNCTION(X, Y) BOOLEAN;
     DECLARE X SCALAR, Y SCALAR;
     DECLARE EPSILON SCALAR CONSTANT(1E-9);
     IF ABS(X - Y) < EPSILON THEN RETURN TRUE; ELSE RETURN FALSE;
  CLOSE REALLY_CLOSE_TO;
 
 /* Convert degrees to radians and vice-versa. */
 DECLARE PI CONSTANT(3.141592653589793);
 DECLARE DEGREES_PER_RADIAN CONSTANT(180 / PI);
 DEGREES_TO_RADIANS: FUNCTION(DEGREES) SCALAR;
    DECLARE SCALAR, DEGREES;
    RETURN DEGREES / DEGREES_PER_RADIAN;
 CLOSE DEGREES_TO_RADIANS;
 RADIANS_TO_DEGREES: FUNCTION(RADIANS) SCALAR;
    DECLARE SCALAR, RADIANS;
    RETURN RADIANS DEGREES_PER_RADIAN;
 CLOSE RADIANS_TO_DEGREES;
 
 WRITE(6) ;
 WRITE(6) 'Some RTL tests.';
 DECLARE COSINE_ANGLES VECTOR(17) CONSTANT(0, 30, 45, 60, 90, 120, 135, 150, 
 				180, 210, 225, 240, 270, 300, 315, 330, 360),
         COSINE_VALUES VECTOR(17) CONSTANT(1, SQRT(3)/2, SQRT(2)/2, 1/2, 0, 
         			-1/2, -SQRT(2)/2, -SQRT(3)/2, -1, 
         			-SQRT(3)/2, -SQRT(2)/2, -1/2, 0,
         			1/2, SQRT(2)/2, SQRT(3)/2, 1);
 BB = TRUE;
 DO FOR TEMPORARY I = 1 TO 17;
    IF NOT REALLY_CLOSE_TO(COS(DEGREES_TO_RADIANS(COSINE_ANGLES$I)), 
                           COSINE_VALUES$I)
    THEN DO; BB = FALSE; EXIT; END;
 END; 
 CALL PRINT_RESULT('COSINE', BB) ASSIGN(ERRORS);
 BB = TRUE;
 DO FOR TEMPORARY THETA = 0 TO 360;
     IF NOT REALLY_CLOSE_TO(SIN(DEGREES_TO_RADIANS(THETA)),
     			    COS(DEGREES_TO_RADIANS(THETA-90))) 
     THEN DO;
        BB = FALSE;
        EXIT;
     END;
 END;
 CALL PRINT_RESULT('SINE', BB) ASSIGN(ERRORS);

 /*--------------------------------------------------------------------------*/
 
  /* Several functions for checking if a matrix is the identity. */
  IS_IDENTITY2X2: FUNCTION(M) BOOLEAN;
     DECLARE M MATRIX(2,2);
     DO FOR TEMPORARY I = 1 TO 2; DO FOR TEMPORARY J = 1 TO 2;
        IF I = J THEN DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 1) THEN RETURN FALSE;
        END;
        ELSE DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 0) THEN RETURN FALSE;
        END;
     END; END;
     RETURN TRUE;
  CLOSE IS_IDENTITY2X2;
  
  IS_IDENTITY3X3: FUNCTION(M) BOOLEAN;
     DECLARE M MATRIX(3,3);
     DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
        IF I = J THEN DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 1) THEN DO;
     	   	/*WRITE(6) 'M =', M;*/
     	   	RETURN FALSE;
     	   END;
        END;
        ELSE DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 0) THEN DO;
     	      /*WRITE(6) 'M =', M;*/
     	      RETURN FALSE;
     	   END;
        END;
     END; END;
     RETURN TRUE;
  CLOSE IS_IDENTITY3X3;
  
  IS_IDENTITY4X4: FUNCTION(M) BOOLEAN;
     DECLARE M MATRIX(4,4);
     DO FOR TEMPORARY I = 1 TO 4; DO FOR TEMPORARY J = 1 TO 4;
        IF I = J THEN DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 1) THEN RETURN FALSE;
        END;
        ELSE DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 0) THEN RETURN FALSE;
        END;
     END; END;
     RETURN TRUE;
  CLOSE IS_IDENTITY4X4;
  
  IS_IDENTITY5X5: FUNCTION(M) BOOLEAN;
     DECLARE M MATRIX(5,5);
     DO FOR TEMPORARY I = 1 TO 5; DO FOR TEMPORARY J = 1 TO 5;
        IF I = J THEN DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 1) THEN RETURN FALSE;
        END;
        ELSE DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 0) THEN RETURN FALSE;
        END;
     END; END;
     RETURN TRUE;
  CLOSE IS_IDENTITY5X5;
  
  /* The following function encapsulates a lot of vector and matrix tests.
     It was originally a separate program (see DATATYPES-029.hal), but I 
     decided to integrated it into the validation tests, and thought it best
     to make it a self-contained procedure to avoid collisions between the 
     namespaces. */
  DATATYPES_029:
  PROCEDURE ASSIGN(ERRORS);
     DECLARE ERRORS INTEGER;
     DECLARE BB BOOLEAN;
     DECLARE S SCALAR INITIAL(5);
     DECLARE I INTEGER INITIAL(6);
     DECLARE V VECTOR INITIAL(10, 11, 12), VV VECTOR;
     DECLARE M MATRIX INITIAL(20, 21, 22, 23, 24, 25, 26, 27, 28), MM MATRIX;
     DECLARE VECTOR, X INITIAL(5, 6, 2), Y INITIAL(1, 1, 1);
     DECLARE DUMMY2 VECTOR(2), DUMMY3 VECTOR(3);
     
     DECLARE M2 MATRIX(2,2) INITIAL(0, 0.3, -0.1, 0.4);
     DECLARE DUMMY2X2 MATRIX(2,2), DUMMY3X3 MATRIX(3,3);
     DECLARE V1 VECTOR(3) INITIAL(1.0, -1.0, 1.0);
     DECLARE V2 VECTOR(2) INITIAL(0.5, 0.6);
     DECLARE DUMMY2X3 MATRIX(2,3), DUMMY3X2 MATRIX(3,2);
     DECLARE M1A MATRIX(2,3) INITIAL(1.0, 1.0, 2.0, 0.5, -0.5, 1.0);
     DECLARE M2A MATRIX(3,2) INITIAL(0.0, 0.5, 0.0, 1.0, 0.0, 1.0);
     DECLARE M3 MATRIX(3,2) INITIAL(0.5, 1.0, 0.0, 1.0, 0.2, 0.4);
     
     DECLARE A2A MATRIX(2,2) INITIAL(3, 7, 1, -4);
     DECLARE MATRIX(2,2), A2B INITIAL(0.5, 1.0, -0.5, 0.0), A2C;
     DECLARE A3A MATRIX(3,3) INITIAL(-2,2,-3,-1,1,3,2,0,-1);
     DECLARE A3I MATRIX(3,3);
     DECLARE A4A MATRIX(4,4) INITIAL(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16);
     DECLARE A4B MATRIX(4,4) INITIAL(1,2,3,4,8,5,6,7,9,12,10,11,13,14,16,15);
     DECLARE A4I MATRIX(4,4), A4C MATRIX(4,4);
     DECLARE A5A MATRIX(5,5) INITIAL(1,2,3,4,1,8,5,6,7,2,9,12,10,11,3,
     				     13,14,16,15,4,10,8,6,4,2);
     DECLARE A5I MATRIX(5,5);
     DECLARE A6A MATRIX(2,2) INITIAL(-1, 1.5, 1, -1);
     DECLARE A6B MATRIX(2,2);
     DECLARE A23A MATRIX(2,3) INITIAL(1.0, 0.0, 3.0, 2.0, 0.0, 4.0);
     DECLARE DUMMY4X4 MATRIX(4,4), DUMMY5X5 MATRIX(5,5);
     
     DECLARE TST CHARACTER(20);
    
  WRITE(6);
  WRITE(6) 'See "Programming in HAL/S", p. 2-9.';
  WRITE(6) 'Some vector and matrix arithmetic tests.';

  IF V$1 = 10 AND V$2 = 11 AND V$3 = 12 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR INITIALIZATION', BB) ASSIGN(ERRORS);
  
E	 -   -
M    S = V . V;
  IF S = 365 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('DOT PRODUCT', BB) ASSIGN(ERRORS);
  
E         -   -
M    VV = V * V;
  IF VV$1 = 0 AND VV$2 = 0 AND VV$3 = 0 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('CROSS PRODUCT', BB) ASSIGN(ERRORS);
  
  IF X$1 = 5 AND X$2 = 6 AND X$3 = 2 AND Y$1 = 1 AND Y$2 = 1 AND Y$3 = 1
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR INITIALIZATION 2', BB) ASSIGN(ERRORS);
  
  S = X.Y;
  IF S = 13 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('DOT PRODUCT 2', BB) ASSIGN(ERRORS);

  VV = X * Y;
  IF VV$1 = 4 AND VV$2 = -3 AND VV$3 = -1 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('CROSS PRODUCT 2', BB) ASSIGN(ERRORS);
  
  BB = TRUE;
  DO;
     TEMPORARY K INTEGER;
     K = 20;
     DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
        IF M$(I,J) ~= K THEN BB = FALSE;
        K = K + 1;
     END; END;
  END;
  CALL PRINT_RESULT('MATRIX INITIALIZATION', BB) ASSIGN(ERRORS);
  
  TST = 'VECTOR TIMES MATRIX: ';
E    -    - *
M    VV = V M;
  IF VV$1 = 765 AND VV$2 = 798 AND VV$3 = 831 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR TIMES MATRIX', BB) ASSIGN(ERRORS);  
  IF NOT BB THEN WRITE(6) 'VV =', VV;
  
E    *    - -
M    MM = V V;
  BB = TRUE;
  DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
     IF MM$(I,J) ~= (9 + I)(9 + J) THEN BB = FALSE;
  END; END;
  CALL PRINT_RESULT('VECTOR OUTER PRODUCT', BB) ASSIGN(ERRORS);
  
  S = 5;
E    *    * *
M    MM = M M;
  IF MM$(1,1) = 1455 AND MM$(1,2) = 1518 AND MM$(1,3) = 1581 AND
     MM$(2,1) = 1662 AND MM$(2,2) = 1734 AND MM$(2,3) = 1806 AND
     MM$(3,1) = 1869 AND MM$(3,2) = 1950 AND MM$(3,3) = 2031
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('MATRIX MULTIPLICATION', BB) ASSIGN(ERRORS);
  IF NOT BB THEN WRITE(6) 'MM =', MM;
  
E    -    -
M    VV = V S;
  IF VV$1 = 50 AND VV$2 = 55 AND VV$3 = 60 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR TIMES SCALAR', BB) ASSIGN(ERRORS);
  IF NOT BB THEN WRITE(6) 'VV =', VV;
  
  WRITE(6) ;
  WRITE(6) 'See "HAL/S Programmers Guide", pp. 7-7 THROUGH 7-10.';
  I = 10; 
  CALL PRINT_RESULT('SCALAR TIMES INTEGER', REALLY_CLOSE_TO(1.5E-2 I, 0.15)) ASSIGN(ERRORS);
  
  S = 1.5;
  DUMMY2X2 = S M2;
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), 0) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), 0.45) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), -0.15) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), 0.6)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('SCALAR TIMES MATRIX', BB) ASSIGN(ERRORS);
  IF NOT BB THEN WRITE(6) 'S =', S, ', M2 =', M2, ', DUMMY2X2 =', DUMMY2X2;
  
  DUMMY2X2 = M2 S;
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), 0) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), 0.45) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), -0.15) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), 0.6)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('MATRIX TIMES SCALAR', BB) ASSIGN(ERRORS);

  DUMMY3X2 = V1 V2;
  IF REALLY_CLOSE_TO(DUMMY3X2$(1,1), 0.5) AND REALLY_CLOSE_TO(DUMMY3X2$(1,2), 0.6) AND
     REALLY_CLOSE_TO(DUMMY3X2$(2,1), -0.5) AND REALLY_CLOSE_TO(DUMMY3X2$(2,2), -0.6) AND
     REALLY_CLOSE_TO(DUMMY3X2$(3,1), 0.5) AND REALLY_CLOSE_TO(DUMMY3X2$(3,2), 0.6)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR OUTER PRODUCT 2', BB) ASSIGN(ERRORS);

  DUMMY2X3 = V2 V1;
  IF REALLY_CLOSE_TO(DUMMY2X3$(1,1), 0.5) AND REALLY_CLOSE_TO(DUMMY2X3$(1,2), -0.5) AND
     REALLY_CLOSE_TO(DUMMY2X3$(1,3), 0.5) AND REALLY_CLOSE_TO(DUMMY2X3$(2,1), 0.6) AND
     REALLY_CLOSE_TO(DUMMY2X3$(2,2), -0.6) AND REALLY_CLOSE_TO(DUMMY2X3$(2,3), 0.6)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR OUTER PRODUCT 3', BB) ASSIGN(ERRORS);
  IF NOT BB THEN WRITE(6) 'V2 =', V2, ', V1 =', V1, ', DUMMY2X3 =', DUMMY2X3;

  DUMMY2X2 = M1A M2A;
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), 0.0) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), 3.5) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), 0) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), 0.75)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('MATRIX MULTIPLICATION 2', BB) ASSIGN(ERRORS);

  DUMMY3X3 = M2A M1A;
  IF REALLY_CLOSE_TO(DUMMY3X3$(1,1), 0.25) AND REALLY_CLOSE_TO(DUMMY3X3$(1,2), -0.25) AND
     REALLY_CLOSE_TO(DUMMY3X3$(1,3), 0.5) AND REALLY_CLOSE_TO(DUMMY3X3$(2,1), 0.5) AND
     REALLY_CLOSE_TO(DUMMY3X3$(2,2), -0.5) AND REALLY_CLOSE_TO(DUMMY3X3$(2,3), 1.0) AND
     REALLY_CLOSE_TO(DUMMY3X3$(3,1), 0.5) AND REALLY_CLOSE_TO(DUMMY3X3$(3,2), -0.5) AND
     REALLY_CLOSE_TO(DUMMY3X3$(3,3), 1.0)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('MATRIX MULTIPLICATION 3', BB) ASSIGN(ERRORS);
  
  DUMMY2 = V1 M3;
  IF REALLY_CLOSE_TO(DUMMY2$1, 0.7) AND REALLY_CLOSE_TO(DUMMY2$2, 0.4) 
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR TIMES MATRIX 2', BB) ASSIGN(ERRORS);
  
  DUMMY3 = M3 V2;
  IF REALLY_CLOSE_TO(DUMMY3$1, 0.85) AND REALLY_CLOSE_TO(DUMMY3$2, 0.6) AND 
     REALLY_CLOSE_TO(DUMMY3$3, 0.34)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('MATRIX TIMES VECTOR', BB) ASSIGN(ERRORS);
  
  WRITE(6);
  WRITE(6) 'Stuff related to matrix determinants.';
  IF REALLY_CLOSE_TO(DET(A2A), -19) THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X2 DETERMINANT', BB) ASSIGN(ERRORS);
  IF REALLY_CLOSE_TO(DET(A3A), 18) THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('3X3 DETERMINANT', BB) ASSIGN(ERRORS);
  IF REALLY_CLOSE_TO(DET(A4A), 0) THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('4X4 DETERMINANT', BB) ASSIGN(ERRORS);
  IF REALLY_CLOSE_TO(DET(A4B), -348) THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('4X4 DETERMINANT 2', BB) ASSIGN(ERRORS);
  IF REALLY_CLOSE_TO(DET(A5A), -240) THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('5X5 DETERMINANT', BB) ASSIGN(ERRORS);
  
  WRITE(6);
  WRITE(6) 'Stuff related to matrix inverses.';
  A6B = INVERSE(A6A);
  IF REALLY_CLOSE_TO(A6B$(1,1), 2.0) AND REALLY_CLOSE_TO(A6B$(1,2), 3.0) AND
     REALLY_CLOSE_TO(A6B$(2,1), 2.0) AND REALLY_CLOSE_TO(A6B$(2,2), 2.0)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X2 INVERSE', BB) ASSIGN(ERRORS);
  CALL PRINT_RESULT('2X2 MATRIX TIMES INVERSE', IS_IDENTITY2X2(A6A A6B)) ASSIGN(ERRORS);
  CALL PRINT_RESULT('2X2 MATRIX TIMES INVERSE 2', IS_IDENTITY2X2(A6B A6A)) ASSIGN(ERRORS);

  A3I = INVERSE(A3A);
  CALL PRINT_RESULT('3X3 MATRIX TIMES INVERSE', IS_IDENTITY3X3(A3A A3I)) ASSIGN(ERRORS);
  CALL PRINT_RESULT('3X3 MATRIX TIMES INVERSE 2', IS_IDENTITY3X3(A3I A3A)) ASSIGN(ERRORS);

  A4I = INVERSE(A4B);
  A4C = A4B**(-1);
  CALL PRINT_RESULT('4X4 MATRIX TIMES INVERSE', IS_IDENTITY4X4(A4B A4I)) ASSIGN(ERRORS);
  CALL PRINT_RESULT('4X4 MATRIX TIMES INVERSE 2', IS_IDENTITY4X4(A4I A4B)) ASSIGN(ERRORS);
  CALL PRINT_RESULT('4X4 MATRIX TIMES INVERSE 3', IS_IDENTITY4X4(A4C A4B)) ASSIGN(ERRORS);

  A5I = INVERSE(A5A);
  CALL PRINT_RESULT('5X5 MATRIX TIMES INVERSE', IS_IDENTITY5X5(A5A A5I)) ASSIGN(ERRORS);
  CALL PRINT_RESULT('5X5 MATRIX TIMES INVERSE 2', IS_IDENTITY5X5(A5I A5A)) ASSIGN(ERRORS);

  WRITE(6);
  WRITE(6) 'Stuff related to matrix "exponentiation".';
  DUMMY2X2 = A2B**2;
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), -.25) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), 0.5) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), -0.25) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), -0.5)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X2 MATRIX **2', BB) ASSIGN(ERRORS);
  DUMMY2X2 = A2B**(-1);
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), 0.0) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), -2.0) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), 1.0) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), 1.0)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X2 MATRIX **(-1)', BB) ASSIGN(ERRORS);
  DUMMY2X2 = A2B**0;
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), 1) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), 0) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), 0) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), 1)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X2 MATRIX **0', BB) ASSIGN(ERRORS);
  DUMMY2X2 = A2B**T;
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), 0.5) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), -0.5) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), 1.0) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), 0.0)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X2 MATRIX **T', BB) ASSIGN(ERRORS);
  DUMMY3X2 = A23A**T;
  IF REALLY_CLOSE_TO(DUMMY3X2$(1,1), 1) AND REALLY_CLOSE_TO(DUMMY3X2$(1,2), 2) AND
     REALLY_CLOSE_TO(DUMMY3X2$(2,1), 0) AND REALLY_CLOSE_TO(DUMMY3X2$(2,2), 0) AND
     REALLY_CLOSE_TO(DUMMY3X2$(3,1), 3) AND REALLY_CLOSE_TO(DUMMY3X2$(3,2), 4)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X3 MATRIX **T', BB) ASSIGN(ERRORS);
  
  CLOSE DATATYPES_029;
  CALL DATATYPES_029 ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
  INITIAL_AND_CONSTANT_032:
  PROCEDURE ASSIGN(ERRORS);
     DECLARE X SCALAR INITIAL(0);
     DECLARE MAX_SPEED SCALAR INITIAL(14000);
     DECLARE FEET_TO_MILES SCALAR CONSTANT(1 / 5280);
     DECLARE SEC_TO_HR CONSTANT(60 (60));
     DECLARE MAX_MPH INITIAL(14000 FEET_TO_MILES / SEC_TO_HR);
     DECLARE BB BOOLEAN;
     
     WRITE(6) ;
     WRITE(6) 'See "Programming in HAL/S" p. 2-12.';
     IF X = 0 THEN BB = TRUE; ELSE BB = FALSE;
     CALL PRINT_RESULT('SCALAR INITIAL', BB) ASSIGN(ERRORS);
     IF MAX_SPEED = 14000 THEN BB = TRUE; ELSE BB = FALSE;
     CALL PRINT_RESULT('SCALAR INITIAL 2', BB) ASSIGN(ERRORS);
     IF REALLY_CLOSE_TO(FEET_TO_MILES, 189.393939394E-6) 
     THEN BB = TRUE; ELSE BB = FALSE;
     CALL PRINT_RESULT('SCALAR INITIAL 3', BB) ASSIGN(ERRORS);
     IF SEC_TO_HR = 3600 THEN BB = TRUE; ELSE BB = FALSE;
     CALL PRINT_RESULT('SCALAR INITIAL 4', BB) ASSIGN(ERRORS);
     IF REALLY_CLOSE_TO(MAX_MPH, 736.531986532E-6)
     THEN BB = TRUE; ELSE BB = FALSE;
     CALL PRINT_RESULT('SCALAR INITIAL 5', BB) ASSIGN(ERRORS);
     
  CLOSE INITIAL_AND_CONSTANT_032;
  CALL INITIAL_AND_CONSTANT_032 ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
  WRITE(6) ;
  WRITE(6) 'See "Programming in HAL/S" pp. 3-9 and 3-10."'; 
  ROWS_047:
  PROCEDURE ASSIGN(ERRORS);
     DECLARE MM MATRIX INITIAL(11, 12, 13, 21, 22, 23, 31, 32, 33), 
     	     M MATRIX,
     	     TEMP VECTOR,
     	     C SCALAR INITIAL(2),
     	     I INTEGER INITIAL(1),
     	     J INTEGER INITIAL(2),
     	     BB BOOLEAN;
     		
C  MULTIPLY A ROW BY A (NONZERO) CONSTANT:

  M = MM;
E    -        -
M    M    = C MM   ;
S     I,*       I,*
  BB = TRUE;
  DO FOR TEMPORARY J = 1 TO 3;
     IF M$(1,J) ~= 2 (10 + J) THEN BB = FALSE;
  END;
  DO FOR TEMPORARY I = 2 TO 3; DO FOR TEMPORARY J = 1 TO 3;
     IF M$(I,J) ~= 10 I + J THEN BB = FALSE;
  END; END;
  CALL PRINT_RESULT('SCALAR TIMES MATRIX ROW', BB) ASSIGN(ERRORS);
     
C  ADD A CONSTANT MULTIPLE OF ROW J TO ROW I:

  M = MM;
E    -      -         -
M    M    = MM    + C MM   ;
S     I,*     I,*       J,*
  BB = TRUE;
  DO FOR TEMPORARY J = 1 TO 3;
     IF M$(1,J) ~= (10 + J) + 2 (20 + J) THEN BB = FALSE;
  END;
  DO FOR TEMPORARY I = 2 TO 3; DO FOR TEMPORARY J = 1 TO 3;
     IF M$(I,J) ~= 10 I + J THEN BB = FALSE;
  END; END;
  CALL PRINT_RESULT('LINEAR COMBO OF MATRIX ROWS', BB) ASSIGN(ERRORS);
    
C  EXCHANGE ROWS I AND J:
 
  M = MM;
E     -     -
M    TEMP = M   ;
S            I,*

E    -      -
M    M    = M   ;
S     I,*    J,*

E    -       -
M    M    = TEMP;
S     J,*
  BB = TRUE;
  DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
     TEMPORARY K INTEGER;
     IF I = 1 THEN K = 20;
     IF I = 2 THEN K = 10;
     IF I = 3 THEN K = 30;
     IF M$(I,J) ~= K + J THEN BB = FALSE;
  END; END;
  CALL PRINT_RESULT('SWAP MATRIX ROWS', BB) ASSIGN(ERRORS);
     
  CLOSE ROWS_047;
 CALL ROWS_047 ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/
 WRITE(6) ;
 WRITE(6) 'Some REPLACE-macro tests.';
 WRITE(6) 'See p. 3-14 of "Programming in HAL/S".';
 
 TABLE_052:
 PROCEDURE ASSIGN(ERRORS);
     REPLACE LOG2(X) BY "LOG(X)/LOG(2)";
     REPLACE CHECK(X, VALUE) BY "REALLY_CLOSE_TO(LOG2(X), VALUE)";
     
     CALL PRINT_RESULT('REPLACE 0.25', CHECK(0.25, -2)) ASSIGN(ERRORS);
     CALL PRINT_RESULT('REPLACE 0.5', CHECK(0.5, -1)) ASSIGN(ERRORS);
     CALL PRINT_RESULT('REPLACE 1', CHECK(1, 0)) ASSIGN(ERRORS);
     CALL PRINT_RESULT('REPLACE 2', CHECK(2, 1)) ASSIGN(ERRORS);
     CALL PRINT_RESULT('REPLACE 4', CHECK(4, 2)) ASSIGN(ERRORS);
     CALL PRINT_RESULT('REPLACE 8', CHECK(8, 3)) ASSIGN(ERRORS);
     CALL PRINT_RESULT('REPLACE 16', CHECK(16, 4)) ASSIGN(ERRORS);
 CLOSE TABLE_052;
 CALL TABLE_052 ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/
 WRITE(6) ;
 WRITE(6) 'Tests of discrete FOR-loop, with and without WHILE/UNTIL clause.';
 WRITE(6) 'See p. 5-6 of "Programming in HAL/S".';
 /*
 DECLARE SMALL_PRIMES ARRAY(26) INTEGER CONSTANT(2, 3, 5, 7, 11, 13, 17, 19, 23, 
 					         29, 31, 37, 41, 43, 47, 53, 59, 
 					         61, 67, 71, 73, 79, 83, 89, 97, 
 					         101);
 */
 DECLARE SMALL_PRIMES ARRAY(26) INTEGER;
 SMALL_PRIMES = INTEGER(2, 3, 5, 7, 11, 13, 17, 19, 23, 
 					         29, 31, 37, 41, 43, 47, 53, 59, 
 					         61, 67, 71, 73, 79, 83, 89, 97, 
 					         101);
 BB = TRUE;
 DO FOR TEMPORARY I = 2 TO 101;
    TEMPORARY IS_PRIME BOOLEAN, IS_IN_ARRAY BOOLEAN;
    IS_PRIME = TRUE;
    DO FOR TEMPORARY J = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47;
       IF I NOT = J AND REMAINDER(I, J) = 0 THEN DO;
          IS_PRIME = FALSE;
          EXIT;
       END;
    END;
    IS_IN_ARRAY = FALSE;
    DO FOR TEMPORARY J = 1 TO 26;
       IF I = SMALL_PRIMES$J THEN DO;
          IS_IN_ARRAY = TRUE;
          EXIT;
       END;
    END;
    IF IS_PRIME ~= IS_IN_ARRAY THEN DO;
       BB = FALSE;
       EXIT;
    END;
 END;
 CALL PRINT_RESULT('DISCRETE FOR', BB) ASSIGN(ERRORS);
 
 DECLARE II INTEGER, III INTEGER;
 III = 0;
 DO FOR II = 2, 6, 69, -5, 21, 62 WHILE II > 0; III = III + 1; END;
 IF II = -5 AND III = 3 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('DISCRETE FOR WHILE', BB) ASSIGN(ERRORS);
 III = 0;
 DO FOR II = 2, 6, 69, -5, 21, 62 UNTIL II < 0; III = III + 1; END;
 IF II = -5 AND III = 4 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('DISCRETE FOR UNTIL', BB) ASSIGN(ERRORS);
 III = 0;
 BB = TRUE;
 DO FOR II = 2, 3, 5, 7, 11, 13, 17; 
    III = III + 1; 
    IF II ~= SMALL_PRIMES$III THEN BB = FALSE;
 END;
 IF II ~= 17 THEN BB = FALSE;
 CALL PRINT_RESULT('DISCRETE FOR PRIMES', BB) ASSIGN(ERRORS);
 
 BB = TRUE;
 III = 1;
 DO FOR II = 1, 2 II, 2 II, 2 II, 2 II, 2 II, 2 II;
    IF II ~= III THEN BB = FALSE;
    III = 2 III;
 END;
 IF II NOT = 64 THEN BB = FALSE;
 CALL PRINT_RESULT('DISCRETE FOR EXPRESSIONS', BB) ASSIGN(ERRORS);
 
 DO FOR II = 1, 2 II, 2 II, 2 II, 2 II, 2 II, 2 II;
    IF II > 4 THEN EXIT;
 END;
 IF II = 8 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('DISCRETE FOR EXIT', BB) ASSIGN(ERRORS);
 
 BB = TRUE;
 III = 1;
 DO FOR II = 1, 2 II, 2 II, 2 II, 2 II, 2 II, 2 II;
    IF II < 32 THEN DO;
       IF II ~= III THEN BB = FALSE;
       III = 2 III;
       REPEAT;
    END; 
    EXIT;
 END;
 IF II NOT = 32 THEN BB = FALSE;
 CALL PRINT_RESULT('DISCRETE FOR REPEAT', BB) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/
 WRITE(6) ;
 WRITE(6) 'Some test cases for DO CASE statements.';
 DO FOR TEMPORARY I = 1 TO 10;
    TEMPORARY II INTEGER;
    II = 100;
    DO CASE I;
       II = 1;
       II = 2;
       II = 3;
       II = 4;
       II = 5;
    END;
    BB = TRUE;
    IF I <= 5 AND II ~= I THEN BB = FALSE;
    IF I > 5 AND II ~= 100 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('DO CASE NO ELSE', BB) ASSIGN(ERRORS);
 
 DO FOR TEMPORARY I = 1 TO 10;
    TEMPORARY II INTEGER;
    II = 100;
    DO CASE I;
       ELSE II = 99;
       II = 1;
       II = 2;
       II = 3;
       II = 4;
       II = 5;
    END;
    BB = TRUE;
    IF I <= 5 AND II ~= I THEN BB = FALSE;
    IF I > 5 AND II ~= 99 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('DO CASE ELSE', BB) ASSIGN(ERRORS);
 
 DO FOR TEMPORARY I = 1 TO 10;
    TEMPORARY II INTEGER;
    II = 100;
    DO CASE I;
       ELSE DO;
       	  TEMPORARY K INTEGER;
       	  K = 0;
          DO FOR TEMPORARY J = 1 TO 98; K = K + 1; END;
          II = K;
       END;
       II = 1;
       II = 2;
       II = 3;
       DO;
       	  TEMPORARY K INTEGER;
       	  K = 0;
          DO FOR TEMPORARY J = 1 TO 4; K = K + 1; END;
          II = K;
       END;
       II = 5;
    END;
    BB = TRUE;
    IF I <= 5 AND II ~= I THEN BB = FALSE;
    IF I > 5 AND II ~= 98 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('DO CASE BLOCKS', BB) ASSIGN(ERRORS);
 
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Not a pass/fail test. Informational execution-speed timing measurement.'; 
 DECLARE STIME, ETIME; 
 STIME = RUNTIME; 
 M = 100000; 
 I = 0; DO WHILE I < M; I = I + 1; END; 
 ETIME = RUNTIME; 
 WRITE(6) M, 'iterations,', ETIME-STIME, 'seconds, ', 
 	  ROUND(M/(ETIME-STIME)), 'iterations/second.'; 
 	
 /*--------------------------------------------------------------------------*/	
 WRITE(6); 
 WRITE(6) 'Total errors:', ERRORS;
 
