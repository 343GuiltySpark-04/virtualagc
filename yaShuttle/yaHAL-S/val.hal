 /* 
    License:    Declared to be in the Public Domain by its author,
    		Ron Burkey.
    Purpose:	Validation and regression testing of the "modern" HAL/S
    		compiler
    Filename:	val.hal
 */
 
 DECLARE ALLTESTS BOOLEAN INITIAL(TRUE);
 WRITE(6) 'Enter 0 to disable time-consuming tests, non-zero to enable.';
 READ(5) ALLTESTS;
 
 /*---------------------------------------------------------------------------- 
   Some functions for helping to automate tests of declarations.
 	
   The TESTXXXX functions are used for testing whether a DECLARE
   produced the correct result.  To use them, feed them the name
   of an identifier, in string form, along with its basic type
   ('INTEGER', 'SCALAR', 'VECTOR', 'MATRIX', 'BIT', 'CHARACTER'),
   along with the number of a field in the ARRAY(20) returned by
   the typeof() function, and the expected value for that 
   field in either character-string form (TESTCHAR), integer form
   (TESTINT), or scalar form (TESTSCALAR).  The TESTXXXX function
   checks the basic type and the extra field value, and returns
   either TRUE (on match) or FALSE (on failure).  Note that while
   the TESTINT function is pretty foolproof, the TESTSCALAR 
   function may fail because of roundoff error and the TESTCHAR
   function may fail if your notion of how typeof() has stringified
   the fields being tested isn't quite right.
 */
 
 TESTCHAR: FUNCTION(IDENTIFIER, TYPE, FIELD, VALUE) BOOLEAN;
 	DECLARE CHARACTER(32), TYPE, IDENTIFIER;
 	DECLARE CHARACTER(2048), VALUE;
 	DECLARE INTEGER, FIELD;
 	DECLARE TEST ARRAY(20) CHARACTER(256);
 	TEST = typeof(IDENTIFIER);
 	IF TEST$1 = TYPE AND TEST$FIELD = VALUE THEN RETURN TRUE;
 	RETURN FALSE;
 CLOSE TESTCHAR;
 
 TESTINT: FUNCTION(IDENTIFIER, TYPE, FIELD, VALUE) BOOLEAN;
 	DECLARE CHARACTER(32), TYPE, IDENTIFIER;
 	DECLARE INTEGER, FIELD, VALUE;
 	DECLARE TEST ARRAY(20) CHARACTER(256);
 	TEST = typeof(IDENTIFIER);
 	IF TEST$1 = TYPE AND INTEGER(TEST$FIELD) = VALUE THEN RETURN TRUE;
 	RETURN FALSE;
 CLOSE TESTINT;
 
 TESTSCALAR: FUNCTION(IDENTIFIER, TYPE, FIELD, VALUE) BOOLEAN;
 	DECLARE CHARACTER(32), IDENTIFIER, TYPE;
 	DECLARE INTEGER, FIELD;
 	DECLARE SCALAR, VALUE;
 	DECLARE TEST ARRAY(20) CHARACTER(256);
 	TEST = typeof(IDENTIFIER);
 	IF TEST$1 = TYPE AND SCALAR(TEST$FIELD) = VALUE THEN RETURN TRUE;
 	RETURN FALSE;
 CLOSE TESTSCALAR;
 
 /* The procedure PRINT_RESULT() is used to print the result ('success' or 
    'fail') of a test with a given character-string designation.  It also
    updates the global count of ERRORS, and should be CALL'd with 
    ASSIGN(ERRORS). */
 DECLARE ERRORS INTEGER;
 ERRORS = 0;
 PRINT_RESULT:
 PROCEDURE(DESIGNATION, IS_SUCCESS) ASSIGN(ERRORS);
 DECLARE DESIGNATION CHARACTER(64), IS_SUCCESS BOOLEAN, ERRORS INTEGER;
 	IF IS_SUCCESS THEN WRITE(6) DESIGNATION, ': success';
 	ELSE DO;
 		WRITE(6) DESIGNATION, ': fail';
 		ERRORS = ERRORS + 1;
 	END;
 CLOSE PRINT_RESULT;
 
 /* Automates comparison of an object to expected values that are in linear
    progression.  Given the starting value and increment for the linear
    progression and the unraveling of the object as a VECTOR,
    compares them and prints the result of the comparison. */
 CHECK_LINEAR: PROCEDURE(MSG, START, STEP, UNRAVELED) ASSIGN(ERRORS);
    DECLARE MSG CHARACTER(64), START SCALAR, STEP SCALAR, 
    	    UNRAVELED ARRAY(*) SCALAR, ERRORS INTEGER;
    DECLARE TOLERANCE SCALAR CONSTANT(1E-6), EXPECTED SCALAR, BB BOOLEAN;
    DECLARE WIDTH INTEGER;
    WIDTH = SIZE(UNRAVELED);
    BB = TRUE;
    EXPECTED = START;
    DO FOR TEMPORARY I = 1 TO WIDTH;
       IF ABS(EXPECTED - UNRAVELED$I) > TOLERANCE THEN BB = FALSE;
       EXPECTED = EXPECTED + STEP;
    END;
    CALL PRINT_RESULT(MSG, BB) ASSIGN(ERRORS);
 CLOSE CHECK_LINEAR;
 
 /*--------------------------------------------------------------------------*/ 
 
 WRITE(6) ;
 WRITE(6) 'Each test has a designation, such as "4.56B" or "DOT PRODUCT", for';
 WRITE(6) 'cross-referencing failures back to the associated HAL/S source code';
 WRITE(6) 'for the test procedures.';
 WRITE(6) ;
 
 WRITE(6) 'Various tests of DECLARE.';
 DECLARE SCALAR, T, X INITIAL(2.0), Y CONSTANT(3.0), Z DOUBLE;
 CALL PRINT_RESULT('1.00A', TESTCHAR('T', 'SCALAR', 16, '')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.00B', TESTSCALAR('X', 'SCALAR', 5, 2.0)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.00C', TESTSCALAR('Y', 'SCALAR', 4, 3.0)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.00D', TESTCHAR('Z', 'SCALAR', 6, 'DOUBLE')) ASSIGN(ERRORS);
 	
 DECLARE A, B DOUBLE, C INITIAL(4.0), D SCALAR CONSTANT(2 Y - 12);
 CALL PRINT_RESULT('1.01A', TESTCHAR('A', 'SCALAR', 6, '')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.01B', TESTCHAR('B', 'SCALAR', 6, 'DOUBLE')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.01C', TESTSCALAR('C', 'SCALAR', 5, 4.0)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.01D', TESTSCALAR('D', 'SCALAR', 4, -6.0)) ASSIGN(ERRORS);
 	
 DECLARE INTEGER, I, J CONSTANT(4 D + 2), K INITIAL(J + D);
 CALL PRINT_RESULT('1.02A', TESTCHAR('I', 'INTEGER', 4, '')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.02B', TESTINT('J', 'INTEGER', 4, -22)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.02C', TESTINT('K', 'INTEGER', 5, -28)) ASSIGN(ERRORS);
 
 DECLARE L INTEGER DOUBLE, M INTEGER;
 CALL PRINT_RESULT('1.03A', TESTCHAR('L', 'INTEGER', 6, 'DOUBLE')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.03B', TESTCHAR('M', 'INTEGER', 6, '')) ASSIGN(ERRORS);
 
 DECLARE CHARACTER(20), C1, C2 INITIAL('abc'), C3 CONSTANT('def'),
 	C4 CONSTANT(C3 CAT 'ghi');
 CALL PRINT_RESULT('1.04A', TESTINT('C1', 'CHARACTER', 2, 20)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.04B', TESTCHAR('C2', 'CHARACTER', 5, 'abc')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.04C', TESTCHAR('C3', 'CHARACTER', 4, 'def')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.04D', TESTCHAR('C4', 'CHARACTER', 4, 'defghi')) ASSIGN(ERRORS);
 	
 DECLARE C5 CHARACTER(30), C6 CHARACTER(20) INITIAL('sam ' CAT C3);
 CALL PRINT_RESULT('1.05A', TESTINT('C5', 'CHARACTER', 2, 30)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.05B', TESTCHAR('C6', 'CHARACTER', 5, 'sam def')) ASSIGN(ERRORS);
 	
 DECLARE BOOLEAN, B1, B2 CONSTANT(TRUE), B3 INITIAL(NOT B2);
 CALL PRINT_RESULT('1.06A', TESTINT('B1', 'BIT', 2, 1)) ASSIGN(ERRORS);
 DECLARE BB BOOLEAN;
 IF B2 AND TESTINT('B2', 'BIT', 2, 1) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('1.06B', BB) ASSIGN(ERRORS);
 IF NOT B3 AND TESTINT('B3', 'BIT', 2, 1) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('1.06C', BB) ASSIGN(ERRORS);
 	
 DECLARE B4 BOOLEAN, B5 BOOLEAN CONSTANT(NOT B2 AND B2), 
 	 B6 BOOLEAN INITIAL(B2 OR ~B2); 
 CALL PRINT_RESULT('1.07A', TESTINT('B4', 'BIT', 2, 1)) ASSIGN(ERRORS);
 IF NOT B5 AND TESTCHAR('B5', 'BIT', 4, '0, 1') THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('1.07B', BB) ASSIGN(ERRORS);
 IF B6 AND TESTCHAR('B6', 'BIT', 5, '1, 1') THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('1.07C', BB) ASSIGN(ERRORS);
 
 DECLARE CV1 CONSTANT(2); 
 DECLARE VN1 VECTOR(5); 
 DECLARE VN1A VECTOR(CV1 + 3); 
 CALL PRINT_RESULT('1.08A', TESTSCALAR('CV1', 'SCALAR', 4, 2.0)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.08B', TESTINT('VN1', 'VECTOR', 2, 5)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.08C', TESTINT('VN1A', 'VECTOR', 2, 5)) ASSIGN(ERRORS);
 
 DECLARE VN2 VECTOR(10) INITIAL(2.47); 
 DECLARE VN2A VECTOR(10) INITIAL(CV1 + 0.47); 
 DECLARE VN3 VECTOR(20) INITIAL(1, 2, 3, 4, 5, *); 
 CALL PRINT_RESULT('1.08D', TESTCHAR('VN2', 'VECTOR', 5, 
 		'2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.08E', TESTCHAR('VN2A', 'VECTOR', 5, 
 		'2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47, 2.47')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.08F', TESTCHAR('VN3', 'VECTOR', 5,
 	'1.0, 2.0, 3.0, 4.0, 5.0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None')) ASSIGN(ERRORS);
 	
 DECLARE VN3A VECTOR(3 CV1) INITIAL(1, CV1, 3, 4, 1 + CV1 2, *); 
 DECLARE VN4 VECTOR(15) CONSTANT(12); 
 DECLARE VN4A VECTOR(15) CONSTANT(12, CV1 + 11, 2 CV1 +10, *); 
 CALL PRINT_RESULT('1.08G', TESTCHAR('VN3A', 'VECTOR', 5,
 		'1.0, 2.0, 3.0, 4.0, 5.0, None')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.08H', TESTCHAR('VN4', 'VECTOR', 4,
 	'12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('1.08I', TESTCHAR('VN4A', 'VECTOR', 4,
 	'12.0, 13.0, 14.0, None, None, None, None, None, None, None, None, None, None, None, None')) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Some tests of expressions and arithmetic.';
 I = 1.4;
 A = 2;
 B = 12.6E2B-1 A + 6 ( I A**3 - 21 ) / 4.2;
 IF I = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.00A', BB) ASSIGN(ERRORS);
 IF A = 2.0 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.00B', BB) ASSIGN(ERRORS);
 IF ABS(B - 1241.428571) <= 0.0000005 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.00C', BB) ASSIGN(ERRORS);
 IF TRUE THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.00D', BB) ASSIGN(ERRORS);
 IF FALSE THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.00E', BB) ASSIGN(ERRORS);
 IF NOT FALSE THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.00F', BB) ASSIGN(ERRORS);
 IF NOT TRUE THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.00G', BB) ASSIGN(ERRORS);
 
 I = 5; 
 IF I < 10 THEN BB = TRUE; ELSE BB = FALSE; 
 CALL PRINT_RESULT('2.01A', BB) ASSIGN(ERRORS);
 IF I < 5 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01B', BB) ASSIGN(ERRORS); 
 IF I < 2 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01C', BB) ASSIGN(ERRORS); 
 IF I <= 10 THEN BB = TRUE; ELSE BB = FALSE; 
 CALL PRINT_RESULT('2.01D', BB) ASSIGN(ERRORS);
 IF I <= 5 THEN BB = TRUE; ELSE BB = FALSE; 
 CALL PRINT_RESULT('2.01E', BB) ASSIGN(ERRORS);
 IF I <= 2 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01F', BB) ASSIGN(ERRORS); 
 IF I > 2 THEN BB = TRUE; ELSE BB = FALSE; 
 CALL PRINT_RESULT('2.01G', BB) ASSIGN(ERRORS);
 IF I > 5 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01H', BB) ASSIGN(ERRORS); 
 IF I > 10 THEN BB = FALSE; ELSE BB = TRUE; 
 CALL PRINT_RESULT('2.01I', BB) ASSIGN(ERRORS);
 IF I >= 2 THEN BB = TRUE; ELSE BB = FALSE; 
 CALL PRINT_RESULT('2.01J', BB) ASSIGN(ERRORS);
 IF I >= 5 THEN BB = TRUE; ELSE BB = FALSE; 
 CALL PRINT_RESULT('2.01K', BB) ASSIGN(ERRORS);
 IF I >= 10 THEN BB = FALSE; ELSE BB = TRUE; 
 CALL PRINT_RESULT('2.01L', BB) ASSIGN(ERRORS);
 IF I = 2 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01M', BB) ASSIGN(ERRORS); 
 IF I = 5 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.01N', BB) ASSIGN(ERRORS); 
 IF I = 10 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01O', BB) ASSIGN(ERRORS); 
 IF I ~= 2 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.01P', BB) ASSIGN(ERRORS); 
 IF I ~= 5 THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.01Q', BB) ASSIGN(ERRORS); 
 IF I ~= 10 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.01R', BB) ASSIGN(ERRORS); 

 IF 'ABC' = 'A' || 'BC' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.02A', BB) ASSIGN(ERRORS); 
 IF 'AB' || 'C' = 'ABC' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('2.02B', BB) ASSIGN(ERRORS); 
 IF 'ABC' = 'AB' THEN BB = FALSE; ELSE BB = TRUE;
 CALL PRINT_RESULT('2.02C', BB) ASSIGN(ERRORS); 
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Some tests of simple subscripting.';
 DO FOR TEMPORARY I = 1 TO 10; VN2$I = 1; END;
 IF ROUND(VN2$1) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00A', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$2) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00B', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$3) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00C', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$4) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00D', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$5) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00E', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$6) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00F', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$7) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00G', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$8) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00H', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$9) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00I', BB) ASSIGN(ERRORS);
 IF ROUND(VN2$10) = 1 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.00J', BB) ASSIGN(ERRORS);
 
 I = 0; DO WHILE I < 10; I = I + 1; VN2$I = I; END;
 IF 1 = ROUND(VN2$1 + 0) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01A', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(-1 + VN2$2) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01B', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$3 / 3) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01C', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(0.25 VN2$4) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01D', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$5 0.2) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01E', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$6 - 5) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01F', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$7 - 6) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01G', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$8 - 7) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01H', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$9 - 8) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01I', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(VN2$10 - 9) THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.01J', BB) ASSIGN(ERRORS);
 	
 DO FOR TEMPORARY I = 1 TO 10; VN2$I = 1; END;
 K = 0; DO FOR TEMPORARY I = 1 TO 10; IF VN2$I = 1 THEN K = K + 1; END;
 IF K = 10 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.02', BB) ASSIGN(ERRORS);
 B1=TRUE; I=0; 
 DO WHILE B1; 
 	I=I+1; 
 	IF I>=10 THEN B1=FALSE; 
 	VN2$I = I; 
 END; 	
 K = 0; DO FOR TEMPORARY I = 1 TO 10; IF VN2$I = I THEN K = K + 1; END;
 IF K = 10 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.03', BB) ASSIGN(ERRORS);
 
 B1 = TRUE; DO WHILE FALSE; B1 = FALSE; END;
 CALL PRINT_RESULT('3.04', B1) ASSIGN(ERRORS);
 B1 = FALSE; DO UNTIL TRUE; B1 = TRUE; END;
 CALL PRINT_RESULT('3.05', B1) ASSIGN(ERRORS);
 
 DO FOR TEMPORARY I = 1 TO 10; VN2$I = 1; END;
 I=0; DO UNTIL I >= 10; I=I+1; VN2$I = I; END; 
 K = 0; DO FOR TEMPORARY I = 1 TO 10; IF VN2$I = I THEN K = K + 1; END;
 IF K = 10 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('3.06', BB) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Various tests of DO WHILE, DO UNTIL, DO FOR.';
 IF ALLTESTS THEN DO;
 
 WRITE(6) 'The following timing tests take about 3 seconds each ...';
 TEMPORARY SCALAR, START, THISSTART, THISTIME, STOP;
 TEMPORARY INTEGER, DELTA, RUNS CONSTANT(3);
 
 START = RUNTIME; 
 THISSTART = START;
 I = 1; DO WHILE I <= RUNS; 
 	THISTIME = RUNTIME;
 	DO WHILE THISTIME - THISSTART < 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	I = I + 1; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.00', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 I = 1; DO WHILE I <= RUNS; 
 	DO UNTIL THISTIME - THISSTART >= 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	I = I + 1; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.01', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 I = 1; DO UNTIL I > RUNS; 
 	THISTIME = RUNTIME;
 	DO WHILE THISTIME < THISSTART + 1.0; 
 		THISTIME = RUNTIME ;
 	END; 
 	I = I + 1; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.02', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 I=1; DO UNTIL I > RUNS; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME;
 	END; 
 	I = I + 1; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.03', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 DO FOR TEMPORARY I = 1 TO RUNS; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.04', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 DO FOR TEMPORARY I = 1 TO 2 RUNS BY 2; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.05', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 DO FOR TEMPORARY I = RUNS TO 1 BY -1; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.06', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 DO FOR TEMPORARY I = 1 TO 100 UNTIL I >= RUNS; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.07', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 DO FOR TEMPORARY I = 1 TO 100 WHILE I <= RUNS; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = RUNS THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.08', B1) ASSIGN(ERRORS);
 
 WRITE(6) 'The following timing tests take about 15 seconds each ...';
 START = RUNTIME; 
 THISSTART = START;
 DO FOR A = 1.4 TO 26.3 BY 1.7; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = 15 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.09', B1) ASSIGN(ERRORS);
 
 START = RUNTIME; 
 THISSTART = START;
 DO FOR A = 25.2 TO 0.0 BY -1.7; 
 	DO UNTIL THISTIME >= THISSTART + 1.0; 
 		THISTIME = RUNTIME; 
 	END; 
 	THISSTART = THISTIME; 
 END; 
 STOP = RUNTIME;
 DELTA = ROUND(STOP - START);
 IF DELTA = 15 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('4.10', B1) ASSIGN(ERRORS);
 
 END; ELSE WRITE(6) 'Skipping 4.xx tests.';
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Various simple tests of FUNCTION and PROCEDURE.';
 /* Function that averages 3 floats. */ 
 AVG3: 
 FUNCTION(X, Y, Z) SCALAR; 
 	DECLARE SCALAR, X, Y, Z, T; 
 
 	/* Function that adds 3 floats. */
 	ADD3: 
 	FUNCTION(X, Y, Z) SCALAR; 
 		DECLARE X, Y, Z; 
 		DECLARE ADD2 FUNCTION SCALAR; 
 		RETURN ADD2(X, ADD2(Y, Z)); 
 		
 		/* Function that adds 2 floats. */
 		ADD2: 
 		FUNCTION(X, Y) SCALAR; 
 			DECLARE X, Y; 
 			RETURN X + Y; 
 		CLOSE; 
 		
 	CLOSE ADD3; 
 
	T = ADD3(X, Y, Z); 
 	RETURN T/3; 
 CLOSE AVG3; 
 IF ABS(AVG3(4, 5, 7) - 5.33333) <= 0.000005 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('5.00', B1) ASSIGN(ERRORS);
 
 /* A "projection" function that picks out just one
    parameter from among three, using W as an index. */
 PROJECTION3: 
 FUNCTION(W, X, Y, Z); 
 	DECLARE X, Y, Z; 
 	DECLARE W INTEGER; 
 	IF W = 1 THEN RETURN X; 
 	IF W = 2 THEN RETURN Y; 
 	IF W = 3 THEN RETURN Z; 
 	RETURN 0; 
 CLOSE PROJECTION3; 
 IF PROJECTION3(1, 100, 200, 300) = 100.0 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('5.01A', B1) ASSIGN(ERRORS);
 IF PROJECTION3(2, 100, 200, 300) = 200.0 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('5.01B', B1) ASSIGN(ERRORS);
 IF PROJECTION3(3, 100, 200, 300) = 300.0 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('5.01C', B1) ASSIGN(ERRORS);
 
 DECLARE X1 SCALAR INITIAL(0), Y1 SCALAR INITIAL(1), Y2, Z1 SCALAR INITIAL(2); 
 P: 
 PROCEDURE(X) ASSIGN(Y); 
	 DECLARE X, Y; 
	 Y=X; 
 CLOSE; 
 CALL P(39) ASSIGN(Z1); 
 IF Y1 = 1.0 AND Z1 = 39.0 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('5.02', B1) ASSIGN(ERRORS);
 
 P2: 
 PROCEDURE(A, B, C) ASSIGN(D, E, F); 
	 DECLARE A, B, C, D, E, F; 
	 D = A; 
	 E = B; 
	 F = C; 
 CLOSE P2; 
 CALL P2(123, 245, 789) ASSIGN(X1, Y2, Z1); 
 IF X1 = 123.0 AND Y2 = 245.0 AND Z1 = 789.0 THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('5.03', B1) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Some tests of "shaping" functions.';
 DECLARE VC100 VECTOR(5) CONSTANT(1, 1#, 3, *); 
 CALL PRINT_RESULT('6.00', TESTCHAR('VC100', 'VECTOR', 4, '1.0, None, 3.0, None, None')) ASSIGN(ERRORS);
 DECLARE VC101 VECTOR(20) CONSTANT(VC100, 2#(2#(1,2,3), 4), 24); 
 CALL PRINT_RESULT('6.01', TESTCHAR('VC101', 'VECTOR', 4, 
 	'1.0, None, 3.0, None, None, 1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 4.0, 1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 4.0, 24.0')) ASSIGN(ERRORS);
 DECLARE VC102 VECTOR(5) CONSTANT(1, 1#2, 3, 4, 5); 
 CALL PRINT_RESULT('6.02', TESTCHAR('VC102', 'VECTOR', 4, '1.0, 2.0, 3.0, 4.0, 5.0')) ASSIGN(ERRORS);
 DECLARE VC103 VECTOR(5) CONSTANT(VC102); 
 CALL PRINT_RESULT('6.03', TESTCHAR('VC103', 'VECTOR', 4, '1.0, 2.0, 3.0, 4.0, 5.0')) ASSIGN(ERRORS);
 DECLARE VC104 VECTOR(20) CONSTANT(VC102, 2#(2#(1,2,3), 4), 24); 
 CALL PRINT_RESULT('6.04', TESTCHAR('VC104', 'VECTOR', 4, 
 	'1.0, 2.0, 3.0, 4.0, 5.0, 1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 4.0, 1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 4.0, 24.0')) ASSIGN(ERRORS);
 DECLARE VC105 VECTOR(10) CONSTANT(1, 2, VC102, 3, 4, 5); 
 CALL PRINT_RESULT('6.05', TESTCHAR('VC105', 'VECTOR', 4,
 	'1.0, 2.0, 1.0, 2.0, 3.0, 4.0, 5.0, 3.0, 4.0, 5.0')) ASSIGN(ERRORS);
 DECLARE A100 ARRAY(20) INTEGER; 
 CALL PRINT_RESULT('6.06', TESTINT('A100', 'INTEGER', 16, 20)) ASSIGN(ERRORS);
 DECLARE B100 ARRAY(20) SCALAR; 
 CALL PRINT_RESULT('6.07', TESTINT('B100', 'SCALAR', 16, 20)) ASSIGN(ERRORS);
 A100 = INTEGER(2#VC100, 10#5); 
 IF 1 = ROUND(A100$1/VC100$1) AND ROUND(A100$3/VC100$3) = 1 AND 
 	1 = ROUND(A100$6/VC100$1) AND ROUND(A100$8/VC100$3) = 1 AND
 	1 = ROUND(A100$11/5) AND ROUND(A100$12/5) = 1 AND
 	1 = ROUND(A100$13/5) AND ROUND(A100$14/5) = 1 AND
 	1 = ROUND(A100$15/5) AND ROUND(A100$16/5) = 1 AND
 	1 = ROUND(A100$17/5) AND ROUND(A100$18/5) = 1 AND 
 	1 = ROUND(A100$19/5) AND ROUND(A100$20/5) = 1 
 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('6.08A', BB) ASSIGN(ERRORS);
 DECLARE MYTYPE ARRAY(20) CHARACTER(2048);
 MYTYPE = typeofv(INTEGER(2#VC100, 10#5));
 IF MYTYPE$1 = 'INTEGER' AND MYTYPE$16 = '20' THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('6.08B', B1) ASSIGN(ERRORS);
 B100 = SCALAR(3#VC100, 5#6); 
 IF 1 = ROUND(B100$1/VC100$1) AND 1 = ROUND(B100$3/VC100$3) AND
 	1 = ROUND(B100$6/VC100$1) AND 1 = ROUND(B100$8/VC100$3) AND
 	1 = ROUND(B100$11/VC100$1) AND 1 = ROUND(B100$13/VC100$3) AND
 	1 = ROUND(B100$16/6) AND 1 = ROUND(B100$17/6) AND
 	1 = ROUND(B100$18/6) AND 1 = ROUND(B100$19/6) AND
 	1 = ROUND(B100$20/6) THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('6.09A', B1) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR(3#VC100, 5#6));
 IF MYTYPE$1 = 'SCALAR' AND MYTYPE$16 = '20' THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('6.09B', B1) ASSIGN(ERRORS);
 I = 27; K = 52;
 DECLARE A201 ARRAY(10) INTEGER; 
 BB = TRUE; 
 DO FOR TEMPORARY I = 1 TO 10; 
 	A201 = INTEGER(1, 2, 3, 4, 2 I, 6, 7, 8, 9, 10); 
 	DO FOR TEMPORARY K = 1 TO 10;
 		IF K = 5 AND A201$K ~= 2 I THEN BB = FALSE;
 		ELSE IF K ~= 5 AND A201$K ~= K THEN BB = FALSE; 
 	END;
 END; 
 CALL PRINT_RESULT('6.09C', BB) ASSIGN(ERRORS);
 IF 1 = ROUND(I / 27) AND 1 = ROUND(K / 52) THEN B1 = TRUE; ELSE B1 = FALSE;
 CALL PRINT_RESULT('6.09D', B1) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Some tests of repitition factors (#).';
 DECLARE B300 BIT(6);
 CALL PRINT_RESULT('7.00A', TESTINT('B300', 'BIT', 2, 6)) ASSIGN(ERRORS);
 MYTYPE = typeofv(34);
 IF MYTYPE$1 = 'INTEGER' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00B', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(34.2);
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00C', BB) ASSIGN(ERRORS);
 B300 = 34.2;
 IF INTEGER(B300) = 34 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00D', BB) ASSIGN(ERRORS);
 B300 = 98;
 IF INTEGER(B300) = 34 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00E', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER(B300));
 IF MYTYPE$1 = 'INTEGER' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00F', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER('34'));
 IF MYTYPE$1 = 'INTEGER' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00G', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER('34.2'));
 IF MYTYPE$1 = 'INTEGER' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00H', BB) ASSIGN(ERRORS);
 
 MYTYPE = typeofv(34.0);
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.01A', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(34.0);
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.01B', BB) ASSIGN(ERRORS);
 B300 = 98;
 MYTYPE = typeofv(SCALAR(B300));
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.01C', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR('34'));
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.00D', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR('34.2'));
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.01E', BB) ASSIGN(ERRORS);
 
 DECLARE VECTOR, V300 CONSTANT(1.0, 2.0, 3.0), V301, V302; 
 DECLARE MATRIX, M300 CONSTANT(1, 2, 3, 4, 5, 6, 7, 8, 9), M301, M302; 
 DECLARE ARRAY(3), A300; 
 DECLARE A301 ARRAY(9) SCALAR, A302 ARRAY(3) SCALAR; 
 CALL PRINT_RESULT('7.02A', TESTCHAR('V300', 'VECTOR', 4, '1.0, 2.0, 3.0')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02B', TESTINT('V301', 'VECTOR', 2, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02C', TESTINT('V302', 'VECTOR', 2, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02D', TESTCHAR('M300', 'MATRIX', 4, 
 				'1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0')) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02E', TESTINT('M301', 'MATRIX', 2, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02F', TESTINT('M301', 'MATRIX', 3, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02G', TESTINT('M302', 'MATRIX', 2, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02H', TESTINT('M302', 'MATRIX', 3, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02I', TESTINT('A300', 'SCALAR', 16, 3)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('7.02J', TESTINT('A301', 'SCALAR', 16, 9)) ASSIGN(ERRORS);
 
 IF V300$1 = 1.0 AND V300$2 = 2.0 AND V300$3 = 3.0 THEN BB = TRUE; 
 ELSE BB = FALSE;
 CALL PRINT_RESULT('7.02K', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER(V300));
 IF MYTYPE$1 = 'VECTOR' AND MYTYPE$2 = '3' AND MYTYPE$3 = '' THEN BB = TRUE;
 ELSE BB = FALSE;
 CALL PRINT_RESULT('7.02L', BB) ASSIGN(ERRORS);
 V301 = INTEGER(V300); 
 MYTYPE = typeofv(V301$1);
 IF MYTYPE$1 = 'SCALAR' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.02M', BB) ASSIGN(ERRORS);
 IF V301$1 = 1 AND V301$2 = 2 AND V301$3 = 3 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.02N', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER(1#V300));
 IF MYTYPE$1 = 'INTEGER' AND MYTYPE$16 = '3' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.02O', BB) ASSIGN(ERRORS);
 A300 = INTEGER(1#V300); 
 IF A300$1 = 1 AND V300$2 = 2 AND V300$3 = 3 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('7.02P', BB) ASSIGN(ERRORS);
 
 BB = TRUE; K = 1;
 DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
 	IF M300$(I,J) ~= K THEN BB = FALSE;
 	K = K + 1;
 END; END;
 CALL PRINT_RESULT('7.03A', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER(M300));
 M301 = INTEGER(M300);
 BB = TRUE; IF MYTYPE$1 ~= 'MATRIX' THEN BB = FALSE;
 CALL PRINT_RESULT('7.03B', BB) ASSIGN(ERRORS);
 BB = TRUE; K = 1;
 DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
 	IF M301$(I,J) ~= K THEN BB = FALSE;
 	K = K + 1;
 END; END;
 CALL PRINT_RESULT('7.03C', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(INTEGER(1#M300));
 BB = TRUE; 
 IF MYTYPE$1 ~= 'INTEGER' OR MYTYPE$16 ~= '9'THEN BB = FALSE;
 CALL PRINT_RESULT('7.03D', BB) ASSIGN(ERRORS);
 A301 = INTEGER(1#M300); 
 BB = TRUE; DO FOR TEMPORARY I = 1 TO 9; IF A301$I ~= I THEN BB = FALSE; END;
 CALL PRINT_RESULT('7.03E', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR(V301));
 BB = TRUE; IF MYTYPE$1 ~= 'VECTOR' THEN BB = FALSE;
 CALL PRINT_RESULT('7.03F', BB) ASSIGN(ERRORS);
 V302 = SCALAR(V301);
 BB = TRUE; DO FOR TEMPORARY K = 1 TO 3; IF V302$K ~= K THEN BB = FALSE; END;
 CALL PRINT_RESULT('7.03G', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR(1#V301));
 BB = TRUE; IF MYTYPE$1 ~= 'SCALAR' OR MYTYPE$16 ~= '3' THEN BB = FALSE;
 CALL PRINT_RESULT('7.03H', BB) ASSIGN(ERRORS);
 A300 = SCALAR(1#V301); 
 BB = TRUE; DO FOR TEMPORARY K = 1 TO 3; IF A300$K ~= K THEN BB = FALSE; END;
 CALL PRINT_RESULT('7.03I', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR(M301));
 BB = TRUE; 
 IF MYTYPE$1 ~= 'MATRIX' OR MYTYPE$2 ~= '3' OR MYTYPE$3 ~= '3' THEN BB = FALSE;
 CALL PRINT_RESULT('7.03J', BB) ASSIGN(ERRORS);
 M302 = SCALAR(M301);
 BB = TRUE; K = 1;
 DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
 	IF M302$(I,J) ~= K THEN BB = FALSE;
 	K = K + 1;
 END; END;
 CALL PRINT_RESULT('7.03K', BB) ASSIGN(ERRORS);
 MYTYPE = typeofv(SCALAR(1#M301));
 BB = TRUE; 
 IF MYTYPE$1 ~= 'SCALAR' OR MYTYPE$16 ~= '9' THEN BB = FALSE;
 CALL PRINT_RESULT('7.03L', BB) ASSIGN(ERRORS);
 A301 = SCALAR(1#M301);
 BB = TRUE; DO FOR TEMPORARY K = 1 TO 9; IF A301$K ~= K THEN BB = FALSE; END;
 CALL PRINT_RESULT('7.03M', BB) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Some tests of initialized vs uninitialized values and "shaping" functions.';
 DECLARE V400 VECTOR(10), V401 VECTOR(10), V402 VECTOR(10); 
 DECLARE MATRIX, M400, M400U, M401, M402; 
 CALL PRINT_RESULT('8.00A', NOT initialized(V400)) ASSIGN(ERRORS);
 V400$1=100; 
 V400$3=200; 
 V400$5=300; 
 BB = TRUE;
 DO FOR TEMPORARY I = 1 TO 10;
 	IF I = 1 OR I = 3 OR I = 5 THEN 
 		DO; IF V400$I ~= ROUND(50 (I + 1)) THEN BB = FALSE; END;
 	ELSE IF initialized(V400$I) THEN BB = FALSE;
 END; 
 CALL PRINT_RESULT('8.00B', BB) ASSIGN(ERRORS);
 DO FOR TEMPORARY I = 1 TO 10; V401$I = 49 I; END;
 CALL PRINT_RESULT('8.00C', initialized(V401)) ASSIGN(ERRORS);
 CALL PRINT_RESULT('8.00D', NOT initialized(M400U)) ASSIGN(ERRORS);
 BB = TRUE;
 DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
 	IF NOT initialized(M300$(I,J)) THEN BB = FALSE;
 END; END;
 CALL PRINT_RESULT('8.00E', BB) ASSIGN(ERRORS);
 
 MYREVERSE:
 PROCEDURE(V) ASSIGN(W); 
 	DECLARE VECTOR(10), V, W; 
 	DO FOR TEMPORARY I = 1 TO 10; 
 		W$I = V$(11-I); 
 	END; 
 CLOSE MYREVERSE; 
 CALL MYREVERSE(V401) ASSIGN(V402); 
 BB = TRUE;
 DO FOR TEMPORARY I = 1 TO 10;
 	IF V402$I ~= 49 (11 - I) THEN BB = FALSE; 
 END; 
 CALL PRINT_RESULT('8.01A', BB) ASSIGN(ERRORS);
 
 DO FOR TEMPORARY I = 1 TO 3; 
 	DO FOR TEMPORARY J = 1 TO 3; 
 		M400$(I,J) = 10 I + J; 
 	END; 
 END; 
 DECLARE M400T MATRIX CONSTANT(11, 12, 13, 21, 22, 23, 31, 32, 33);
 DECLARE M401T MATRIX CONSTANT(11, 21, 31, 12, 22, 32, 13, 23, 33);
 BB = TRUE;
 DO FOR TEMPORARY I = 1 TO 3;
 	DO FOR TEMPORARY J = 1 TO 3;
 		IF M400$(I,J) ~= M400T$(I,J) THEN BB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('8.01B', BB) ASSIGN(ERRORS);
 
 MYTRANSPOSE:
 PROCEDURE(M) ASSIGN(MT); 
 	DECLARE MATRIX, M, MT; 
 	DO FOR TEMPORARY I = 1 TO 3; 
 		DO FOR TEMPORARY J = 1 TO 3; 
 			MT$(I, J) = M$(J, I); 
 		END; 
 	END; 
 CLOSE MYTRANSPOSE; 
 CALL MYTRANSPOSE(M400) ASSIGN(M401); 
 BB = TRUE;
 DO FOR TEMPORARY I = 1 TO 3;
 	DO FOR TEMPORARY J = 1 TO 3;
 		IF M401$(I,J) ~= M401T$(I,J) THEN BB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('8.01C', BB) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 WRITE(6) 'Some tests of automatic datatype conversions.';
 DECLARE I590 INTEGER, X590 SCALAR, 
 	B590 BIT(4), B591 BIT(5) INITIAL(23), 
 	B595 BIT(4) INITIAL(5), B596 BIT(4) INITIAL(6), B597 BIT(4) INITIAL(7),
 	C590 CHARACTER(25),
 	V590 VECTOR(5), 
 	M590 MATRIX(4,6), 
 	A590 ARRAY(5) INTEGER, A591 ARRAY(5) VECTOR(4),
 	TST CHARACTER(10);
 I590 = 6;
 IF I590 = 6 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.00A', BB) ASSIGN(ERRORS);
 I590 = 5.4;
 IF I590 = 5 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.00B', BB) ASSIGN(ERRORS);
 I590 = '7.2';
 IF I590 = 7 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.00C', BB) ASSIGN(ERRORS);
 I590 = B591;
 IF I590 = 23 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.00D', BB) ASSIGN(ERRORS);
 
 X590 = 6;
 IF X590 = 6.0 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.01A', BB) ASSIGN(ERRORS);
 X590 = 5.4;
 IF X590 = 5.4 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.01B', BB) ASSIGN(ERRORS);
 X590 = '7.2';
 IF X590 = 7.2 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.01C', BB) ASSIGN(ERRORS);
 X590 = B591;
 IF X590 = 23.0 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.01D', BB) ASSIGN(ERRORS);
 
 C590 = 6;
 IF C590 = '6' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.02A', BB) ASSIGN(ERRORS);
 WRITE(6) 'Unfortunately, I had to hard-code the implementation-dependent';
 WRITE(6) 'arithmetical precision into test 9.02B below.';
 C590 = 5.4;
 IF C590 = ' 5.40000000000000E+00' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.02B', BB) ASSIGN(ERRORS);
 C590 = '7.2';
 IF C590 = '7.2' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.02C', BB) ASSIGN(ERRORS);
 C590 = B591;
 IF C590 = '10111' THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.02D', BB) ASSIGN(ERRORS);
 
 B590 = 6;
 IF B590 = B596 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.03A', BB) ASSIGN(ERRORS);
 B590 = 5.4;
 IF B590 = B595 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.03B', BB) ASSIGN(ERRORS);
 B590 = '10111';
 IF B590 = B597 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.03V', BB) ASSIGN(ERRORS);
 B590 = B591;
 IF B590 = B597 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('9.03D', BB) ASSIGN(ERRORS);
 
 DECLARE M591 MATRIX(2,3), M592 MATRIX(2,6), M593 MATRIX(4, 3), 
 	BBB BOOLEAN, 
 	A592 ARRAY(2, 3) MATRIX(4,6), A593 ARRAY(2, 3) MATRIX(4, 6),
 	V591 VECTOR(6), V592 VECTOR(4), 
 	A594 ARRAY(3) SCALAR, A595 ARRAY(2) SCALAR;
 DO FOR TEMPORARY I = 1 TO 4;
 	DO FOR TEMPORARY J = 1 TO 6;
 		M590$(I,J) = 10 I + J;
 	END;
 END;
 M591 = M590$(2 TO 3, 3 TO 5);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 3;
 		IF M591$(I, J) ~= 10 (I + 1) + (J + 2) THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04A', BBB) ASSIGN(ERRORS);
 M592 = M590$(2 TO 3, *);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 6;
 		IF M592$(I, J) ~= 10 (I + 1) + J THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04B', BBB) ASSIGN(ERRORS);
 M593 = M590$(*, 3 TO 5);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 4;
 	DO FOR TEMPORARY J = 1 TO 3;
 		IF M593$(I, J) ~= 10 I + (J + 2) THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04C', BBB) ASSIGN(ERRORS);
 M592 = M590$(2 TO 3, 1 TO #);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 6;
 		IF M592$(I, J) ~= 10 (I + 1) + J THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04D', BBB) ASSIGN(ERRORS);

 M591 = M590$(2 AT 2, 3 AT 3);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 3;
 		IF M591$(I, J) ~= 10 (I + 1) + (J + 2) THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04E', BBB) ASSIGN(ERRORS);
 M592 = M590$(2 AT 2, *);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 6;
 		IF M592$(I, J) ~= 10 (I + 1) + J THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04F', BBB) ASSIGN(ERRORS);
 M593 = M590$(*, 3 AT 3);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 4;
 	DO FOR TEMPORARY J = 1 TO 3;
 		IF M593$(I, J) ~= 10 I + (J + 2) THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04G', BBB) ASSIGN(ERRORS);
 M592 = M590$(2 AT 2, 6 AT 1);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 6;
 		IF M592$(I, J) ~= 10 (I + 1) + J THEN BBB = FALSE;
 	END;
 END;
 CALL PRINT_RESULT('9.04H', BBB) ASSIGN(ERRORS);
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 3;
 		DO FOR TEMPORARY K = 1 TO 4;
 			DO FOR TEMPORARY L = 1 TO 6;
 				A592$(I,J;K,L) = 1000 I + 100 J + 10 K + L;
 			END;
 		END;
 	END;
 END;
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 3;
 		DO FOR TEMPORARY K = 1 TO 4;
 			DO FOR TEMPORARY L = 1 TO 6;
 				IF A592$(I,J;K,L) ~= 1000 I + 100 J + 10 K + L
 				THEN BBB = FALSE;
 			END;
 		END;
 	END;
 END;
 CALL PRINT_RESULT('9.04I', BBB) ASSIGN(ERRORS);
 V591 = A592$(1, 2; 3, *);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 6; 
 	IF V591$I ~= 1230 + I THEN BBB = FALSE;
 END;
 CALL PRINT_RESULT('9.04J', BBB) ASSIGN(ERRORS);
 V592 = A592$(2, 1; *, 4);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 4; 
 	IF V592$I ~= 2104 + 10 I THEN BBB = FALSE;
 END;
 CALL PRINT_RESULT('9.04K', BBB) ASSIGN(ERRORS);
 A594 = A592$(2, *; 2, 3);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 3; 
 	IF A594$I ~= 2023 + 100 I THEN BBB = FALSE;
 END;
 CALL PRINT_RESULT('9.04L', BBB) ASSIGN(ERRORS);
 A595 = A592$(*, 2; 1, 2);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2; 
 	IF A595$I ~= 0212 + 1000 I THEN BBB = FALSE;
 END;
 CALL PRINT_RESULT('9.04M', BBB) ASSIGN(ERRORS);
 A593 = A592;
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 3;
 		DO FOR TEMPORARY K = 1 TO 4;
 			DO FOR TEMPORARY L = 1 TO 6;
 				IF A593$(I,J;K,L) ~= 1000 I + 100 J + 10 K + L
 				THEN BBB = FALSE;
 			END;
 		END;
 	END;
 END;
 CALL PRINT_RESULT('9.04N', BBB) ASSIGN(ERRORS);
 A593$(1, 1; 2 TO 3, 3 TO 5) = A592$(2, 2; 1 TO 2, 2 TO 4);
 DO FOR TEMPORARY I = 1 TO 2;
 	DO FOR TEMPORARY J = 1 TO 3;
 		DO FOR TEMPORARY K = 1 TO 4;
 			DO FOR TEMPORARY L = 1 TO 6;
 				IF I = 1 AND J = 1 AND K >= 2 AND K <= 3
 					AND L >= 3 AND L <= 5 THEN 
 				DO;
	 				IF A593$(I,J;K,L) ~= 1000 (I + 1) + 
	 						     100 (J + 1) + 
	 						     10 (K - 1) + 
	 						     (L - 1)
	 				THEN BBB = FALSE;
 				END;
 				ELSE DO;
	 				IF A593$(I,J;K,L) ~= 
	 					1000 I + 100 J + 10 K + L
	 				THEN BBB = FALSE;
 				END;
 			END;
 		END;
 	END;
 END;
 CALL PRINT_RESULT('9.04O', BBB) ASSIGN(ERRORS);
 
 DECLARE A596I ARRAY(2,3) INTEGER, A596S ARRAY(2,3) SCALAR,
 	 A596V4 ARRAY(2,3) VECTOR(4);
 A596I = INTEGER$(2, 3)(11, 12, 13, 21, 22, 23);
 A596S = SCALAR$(2, 3)(110, 120, 130, 210, 220, 230);
 I = 111;
 A596V4 = SCALAR$(2, 3; 4)(I, 112, 113, 114,
 			   121, 122, 123, 124,
 			   131, 132, 133, 134,
 			   211, 212, 213, 214,
 			   221, 222, 223, 224,
 			   231, 232, 233, 234);
 BBB = TRUE;
 DO FOR TEMPORARY I = 1 TO 2; 
 DO FOR TEMPORARY J = 1 TO 3;
 DO FOR TEMPORARY K = 1 TO 4;
 	IF A596V4$(I, J; K) ~= 100 I + 10 J + K THEN BBB = FALSE;
 END; END; END;
 CALL PRINT_RESULT('9.04P', BBB) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
  /* Test equality with a tolerance. */
  REALLY_CLOSE_TO: FUNCTION(X, Y) BOOLEAN;
     DECLARE X SCALAR, Y SCALAR;
     DECLARE EPSILON SCALAR CONSTANT(1E-9);
     IF ABS(X - Y) < EPSILON THEN RETURN TRUE; ELSE RETURN FALSE;
  CLOSE REALLY_CLOSE_TO;
 
 /* Convert degrees to radians and vice-versa. */
 DECLARE PI CONSTANT(3.141592653589793);
 DECLARE DEGREES_PER_RADIAN CONSTANT(180 / PI);
 DEGREES_TO_RADIANS: FUNCTION(DEGREES) SCALAR;
    DECLARE SCALAR, DEGREES;
    RETURN DEGREES / DEGREES_PER_RADIAN;
 CLOSE DEGREES_TO_RADIANS;
 RADIANS_TO_DEGREES: FUNCTION(RADIANS) SCALAR;
    DECLARE SCALAR, RADIANS;
    RETURN RADIANS DEGREES_PER_RADIAN;
 CLOSE RADIANS_TO_DEGREES;
 
 WRITE(6) ;
 WRITE(6) 'Some unarrayed RTL tests.';
 DECLARE COSINE_ANGLES VECTOR(17) CONSTANT(0, 30, 45, 60, 90, 120, 135, 150, 
 				180, 210, 225, 240, 270, 300, 315, 330, 360),
         COSINE_VALUES VECTOR(17) CONSTANT(1, SQRT(3)/2, SQRT(2)/2, 1/2, 0, 
         			-1/2, -SQRT(2)/2, -SQRT(3)/2, -1, 
         			-SQRT(3)/2, -SQRT(2)/2, -1/2, 0,
         			1/2, SQRT(2)/2, SQRT(3)/2, 1);
 IF ABS(-5.2) = 5.2 AND ABS(0) = 0 AND ABS(153) = 153 THEN BB = TRUE;
 ELSE BB = FALSE;
 CALL PRINT_RESULT('ABS', BB) ASSIGN(ERRORS);
 IF CEILING(-5.2) = -5 AND CEILING(-3.9) = -3 AND CEILING(0.0) = 0
    AND CEILING(1.1) = 2 AND CEILING(5.9) = 6 THEN BB = TRUE;
 ELSE BB = FALSE;
 CALL PRINT_RESULT('CEILING', BB) ASSIGN(ERRORS);
 WRITE(6) '... more such tests to be implemented later.';
 
 BB = TRUE;
 DO FOR TEMPORARY I = 1 TO 17;
    IF NOT REALLY_CLOSE_TO(COS(DEGREES_TO_RADIANS(COSINE_ANGLES$I)), 
                           COSINE_VALUES$I)
    THEN DO; BB = FALSE; EXIT; END;
 END; 
 CALL PRINT_RESULT('COSINE', BB) ASSIGN(ERRORS);
 BB = TRUE;
 DO FOR TEMPORARY THETA = 0 TO 360;
     IF NOT REALLY_CLOSE_TO(SIN(DEGREES_TO_RADIANS(THETA)),
     			    COS(DEGREES_TO_RADIANS(THETA-90))) 
     THEN DO;
        BB = FALSE;
        EXIT;
     END;
 END;
 CALL PRINT_RESULT('SINE', BB) ASSIGN(ERRORS);

 /*--------------------------------------------------------------------------*/
 
  /* Several functions for checking if a matrix is the identity. */
  IS_IDENTITY2X2: FUNCTION(M) BOOLEAN;
     DECLARE M MATRIX(2,2);
     DO FOR TEMPORARY I = 1 TO 2; DO FOR TEMPORARY J = 1 TO 2;
        IF I = J THEN DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 1) THEN RETURN FALSE;
        END;
        ELSE DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 0) THEN RETURN FALSE;
        END;
     END; END;
     RETURN TRUE;
  CLOSE IS_IDENTITY2X2;
  
  IS_IDENTITY3X3: FUNCTION(M) BOOLEAN;
     DECLARE M MATRIX(3,3);
     DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
        IF I = J THEN DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 1) THEN DO;
     	   	/*WRITE(6) 'M =', M;*/
     	   	RETURN FALSE;
     	   END;
        END;
        ELSE DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 0) THEN DO;
     	      /*WRITE(6) 'M =', M;*/
     	      RETURN FALSE;
     	   END;
        END;
     END; END;
     RETURN TRUE;
  CLOSE IS_IDENTITY3X3;
  
  IS_IDENTITY4X4: FUNCTION(M) BOOLEAN;
     DECLARE M MATRIX(4,4);
     DO FOR TEMPORARY I = 1 TO 4; DO FOR TEMPORARY J = 1 TO 4;
        IF I = J THEN DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 1) THEN RETURN FALSE;
        END;
        ELSE DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 0) THEN RETURN FALSE;
        END;
     END; END;
     RETURN TRUE;
  CLOSE IS_IDENTITY4X4;
  
  IS_IDENTITY5X5: FUNCTION(M) BOOLEAN;
     DECLARE M MATRIX(5,5);
     DO FOR TEMPORARY I = 1 TO 5; DO FOR TEMPORARY J = 1 TO 5;
        IF I = J THEN DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 1) THEN RETURN FALSE;
        END;
        ELSE DO;
     	   IF NOT REALLY_CLOSE_TO(M$(I,J), 0) THEN RETURN FALSE;
        END;
     END; END;
     RETURN TRUE;
  CLOSE IS_IDENTITY5X5;
  
  /* The following function encapsulates a lot of vector and matrix tests.
     It was originally a separate program (see DATATYPES-029.hal), but I 
     decided to integrated it into the validation tests, and thought it best
     to make it a self-contained procedure to avoid collisions between the 
     namespaces. */
  DATATYPES_029:
  PROCEDURE ASSIGN(ERRORS);
     DECLARE ERRORS INTEGER;
     DECLARE BB BOOLEAN;
     DECLARE S SCALAR INITIAL(5);
     DECLARE I INTEGER INITIAL(6);
     DECLARE V VECTOR INITIAL(10, 11, 12), VV VECTOR;
     DECLARE M MATRIX INITIAL(20, 21, 22, 23, 24, 25, 26, 27, 28), MM MATRIX;
     DECLARE VECTOR, X INITIAL(5, 6, 2), Y INITIAL(1, 1, 1);
     DECLARE DUMMY2 VECTOR(2), DUMMY3 VECTOR(3);
     
     DECLARE M2 MATRIX(2,2) INITIAL(0, 0.3, -0.1, 0.4);
     DECLARE DUMMY2X2 MATRIX(2,2), DUMMY3X3 MATRIX(3,3);
     DECLARE V1 VECTOR(3) INITIAL(1.0, -1.0, 1.0);
     DECLARE V2 VECTOR(2) INITIAL(0.5, 0.6);
     DECLARE DUMMY2X3 MATRIX(2,3), DUMMY3X2 MATRIX(3,2);
     DECLARE M1A MATRIX(2,3) INITIAL(1.0, 1.0, 2.0, 0.5, -0.5, 1.0);
     DECLARE M2A MATRIX(3,2) INITIAL(0.0, 0.5, 0.0, 1.0, 0.0, 1.0);
     DECLARE M3 MATRIX(3,2) INITIAL(0.5, 1.0, 0.0, 1.0, 0.2, 0.4);
     
     DECLARE A2A MATRIX(2,2) INITIAL(3, 7, 1, -4);
     DECLARE MATRIX(2,2), A2B INITIAL(0.5, 1.0, -0.5, 0.0), A2C;
     DECLARE A3A MATRIX(3,3) INITIAL(-2,2,-3,-1,1,3,2,0,-1);
     DECLARE A3I MATRIX(3,3);
     DECLARE A4A MATRIX(4,4) INITIAL(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16);
     DECLARE A4B MATRIX(4,4) INITIAL(1,2,3,4,8,5,6,7,9,12,10,11,13,14,16,15);
     DECLARE A4I MATRIX(4,4), A4C MATRIX(4,4);
     DECLARE A5A MATRIX(5,5) INITIAL(1,2,3,4,1,8,5,6,7,2,9,12,10,11,3,
     				     13,14,16,15,4,10,8,6,4,2);
     DECLARE A5I MATRIX(5,5);
     DECLARE A6A MATRIX(2,2) INITIAL(-1, 1.5, 1, -1);
     DECLARE A6B MATRIX(2,2);
     DECLARE A23A MATRIX(2,3) INITIAL(1.0, 0.0, 3.0, 2.0, 0.0, 4.0);
     DECLARE DUMMY4X4 MATRIX(4,4), DUMMY5X5 MATRIX(5,5);
     
     DECLARE TST CHARACTER(20);
    
  WRITE(6);
  WRITE(6) 'See "Programming in HAL/S", p. 2-9.';
  WRITE(6) 'Some vector and matrix arithmetic tests.';

  IF V$1 = 10 AND V$2 = 11 AND V$3 = 12 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR INITIALIZATION', BB) ASSIGN(ERRORS);
  
E	 -   -
M    S = V . V;
  IF S = 365 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('DOT PRODUCT', BB) ASSIGN(ERRORS);
  
E         -   -
M    VV = V * V;
  IF VV$1 = 0 AND VV$2 = 0 AND VV$3 = 0 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('CROSS PRODUCT', BB) ASSIGN(ERRORS);
  
  IF X$1 = 5 AND X$2 = 6 AND X$3 = 2 AND Y$1 = 1 AND Y$2 = 1 AND Y$3 = 1
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR INITIALIZATION 2', BB) ASSIGN(ERRORS);
  
  S = X.Y;
  IF S = 13 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('DOT PRODUCT 2', BB) ASSIGN(ERRORS);

  VV = X * Y;
  IF VV$1 = 4 AND VV$2 = -3 AND VV$3 = -1 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('CROSS PRODUCT 2', BB) ASSIGN(ERRORS);
  
  BB = TRUE;
  DO;
     TEMPORARY K INTEGER;
     K = 20;
     DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
        IF M$(I,J) ~= K THEN BB = FALSE;
        K = K + 1;
     END; END;
  END;
  CALL PRINT_RESULT('MATRIX INITIALIZATION', BB) ASSIGN(ERRORS);
  
  TST = 'VECTOR TIMES MATRIX: ';
E    -    - *
M    VV = V M;
  IF VV$1 = 765 AND VV$2 = 798 AND VV$3 = 831 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR TIMES MATRIX', BB) ASSIGN(ERRORS);  
  IF NOT BB THEN WRITE(6) 'VV =', VV;
  
E    *    - -
M    MM = V V;
  BB = TRUE;
  DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
     IF MM$(I,J) ~= (9 + I)(9 + J) THEN BB = FALSE;
  END; END;
  CALL PRINT_RESULT('VECTOR OUTER PRODUCT', BB) ASSIGN(ERRORS);
  
  S = 5;
E    *    * *
M    MM = M M;
  IF MM$(1,1) = 1455 AND MM$(1,2) = 1518 AND MM$(1,3) = 1581 AND
     MM$(2,1) = 1662 AND MM$(2,2) = 1734 AND MM$(2,3) = 1806 AND
     MM$(3,1) = 1869 AND MM$(3,2) = 1950 AND MM$(3,3) = 2031
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('MATRIX MULTIPLICATION', BB) ASSIGN(ERRORS);
  IF NOT BB THEN WRITE(6) 'MM =', MM;
  
E    -    -
M    VV = V S;
  IF VV$1 = 50 AND VV$2 = 55 AND VV$3 = 60 THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR TIMES SCALAR', BB) ASSIGN(ERRORS);
  IF NOT BB THEN WRITE(6) 'VV =', VV;
  
  WRITE(6) ;
  WRITE(6) 'See "HAL/S Programmers Guide", pp. 7-7 THROUGH 7-10.';
  I = 10; 
  CALL PRINT_RESULT('SCALAR TIMES INTEGER', REALLY_CLOSE_TO(1.5E-2 I, 0.15)) ASSIGN(ERRORS);
  
  S = 1.5;
  DUMMY2X2 = S M2;
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), 0) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), 0.45) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), -0.15) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), 0.6)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('SCALAR TIMES MATRIX', BB) ASSIGN(ERRORS);
  IF NOT BB THEN WRITE(6) 'S =', S, ', M2 =', M2, ', DUMMY2X2 =', DUMMY2X2;
  
  DUMMY2X2 = M2 S;
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), 0) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), 0.45) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), -0.15) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), 0.6)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('MATRIX TIMES SCALAR', BB) ASSIGN(ERRORS);

  DUMMY3X2 = V1 V2;
  IF REALLY_CLOSE_TO(DUMMY3X2$(1,1), 0.5) AND REALLY_CLOSE_TO(DUMMY3X2$(1,2), 0.6) AND
     REALLY_CLOSE_TO(DUMMY3X2$(2,1), -0.5) AND REALLY_CLOSE_TO(DUMMY3X2$(2,2), -0.6) AND
     REALLY_CLOSE_TO(DUMMY3X2$(3,1), 0.5) AND REALLY_CLOSE_TO(DUMMY3X2$(3,2), 0.6)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR OUTER PRODUCT 2', BB) ASSIGN(ERRORS);

  DUMMY2X3 = V2 V1;
  IF REALLY_CLOSE_TO(DUMMY2X3$(1,1), 0.5) AND REALLY_CLOSE_TO(DUMMY2X3$(1,2), -0.5) AND
     REALLY_CLOSE_TO(DUMMY2X3$(1,3), 0.5) AND REALLY_CLOSE_TO(DUMMY2X3$(2,1), 0.6) AND
     REALLY_CLOSE_TO(DUMMY2X3$(2,2), -0.6) AND REALLY_CLOSE_TO(DUMMY2X3$(2,3), 0.6)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR OUTER PRODUCT 3', BB) ASSIGN(ERRORS);
  IF NOT BB THEN WRITE(6) 'V2 =', V2, ', V1 =', V1, ', DUMMY2X3 =', DUMMY2X3;

  DUMMY2X2 = M1A M2A;
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), 0.0) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), 3.5) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), 0) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), 0.75)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('MATRIX MULTIPLICATION 2', BB) ASSIGN(ERRORS);

  DUMMY3X3 = M2A M1A;
  IF REALLY_CLOSE_TO(DUMMY3X3$(1,1), 0.25) AND REALLY_CLOSE_TO(DUMMY3X3$(1,2), -0.25) AND
     REALLY_CLOSE_TO(DUMMY3X3$(1,3), 0.5) AND REALLY_CLOSE_TO(DUMMY3X3$(2,1), 0.5) AND
     REALLY_CLOSE_TO(DUMMY3X3$(2,2), -0.5) AND REALLY_CLOSE_TO(DUMMY3X3$(2,3), 1.0) AND
     REALLY_CLOSE_TO(DUMMY3X3$(3,1), 0.5) AND REALLY_CLOSE_TO(DUMMY3X3$(3,2), -0.5) AND
     REALLY_CLOSE_TO(DUMMY3X3$(3,3), 1.0)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('MATRIX MULTIPLICATION 3', BB) ASSIGN(ERRORS);
  
  DUMMY2 = V1 M3;
  IF REALLY_CLOSE_TO(DUMMY2$1, 0.7) AND REALLY_CLOSE_TO(DUMMY2$2, 0.4) 
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('VECTOR TIMES MATRIX 2', BB) ASSIGN(ERRORS);
  
  DUMMY3 = M3 V2;
  IF REALLY_CLOSE_TO(DUMMY3$1, 0.85) AND REALLY_CLOSE_TO(DUMMY3$2, 0.6) AND 
     REALLY_CLOSE_TO(DUMMY3$3, 0.34)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('MATRIX TIMES VECTOR', BB) ASSIGN(ERRORS);
  
  WRITE(6);
  WRITE(6) 'Stuff related to matrix determinants.';
  IF REALLY_CLOSE_TO(DET(A2A), -19) THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X2 DETERMINANT', BB) ASSIGN(ERRORS);
  IF REALLY_CLOSE_TO(DET(A3A), 18) THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('3X3 DETERMINANT', BB) ASSIGN(ERRORS);
  IF REALLY_CLOSE_TO(DET(A4A), 0) THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('4X4 DETERMINANT', BB) ASSIGN(ERRORS);
  IF REALLY_CLOSE_TO(DET(A4B), -348) THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('4X4 DETERMINANT 2', BB) ASSIGN(ERRORS);
  IF REALLY_CLOSE_TO(DET(A5A), -240) THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('5X5 DETERMINANT', BB) ASSIGN(ERRORS);
  
  WRITE(6);
  WRITE(6) 'Stuff related to matrix inverses.';
  A6B = INVERSE(A6A);
  IF REALLY_CLOSE_TO(A6B$(1,1), 2.0) AND REALLY_CLOSE_TO(A6B$(1,2), 3.0) AND
     REALLY_CLOSE_TO(A6B$(2,1), 2.0) AND REALLY_CLOSE_TO(A6B$(2,2), 2.0)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X2 INVERSE', BB) ASSIGN(ERRORS);
  CALL PRINT_RESULT('2X2 MATRIX TIMES INVERSE', IS_IDENTITY2X2(A6A A6B)) ASSIGN(ERRORS);
  CALL PRINT_RESULT('2X2 MATRIX TIMES INVERSE 2', IS_IDENTITY2X2(A6B A6A)) ASSIGN(ERRORS);

  A3I = INVERSE(A3A);
  CALL PRINT_RESULT('3X3 MATRIX TIMES INVERSE', IS_IDENTITY3X3(A3A A3I)) ASSIGN(ERRORS);
  CALL PRINT_RESULT('3X3 MATRIX TIMES INVERSE 2', IS_IDENTITY3X3(A3I A3A)) ASSIGN(ERRORS);

  A4I = INVERSE(A4B);
  A4C = A4B**(-1);
  CALL PRINT_RESULT('4X4 MATRIX TIMES INVERSE', IS_IDENTITY4X4(A4B A4I)) ASSIGN(ERRORS);
  CALL PRINT_RESULT('4X4 MATRIX TIMES INVERSE 2', IS_IDENTITY4X4(A4I A4B)) ASSIGN(ERRORS);
  CALL PRINT_RESULT('4X4 MATRIX TIMES INVERSE 3', IS_IDENTITY4X4(A4C A4B)) ASSIGN(ERRORS);

  A5I = INVERSE(A5A);
  CALL PRINT_RESULT('5X5 MATRIX TIMES INVERSE', IS_IDENTITY5X5(A5A A5I)) ASSIGN(ERRORS);
  CALL PRINT_RESULT('5X5 MATRIX TIMES INVERSE 2', IS_IDENTITY5X5(A5I A5A)) ASSIGN(ERRORS);

  WRITE(6);
  WRITE(6) 'Stuff related to matrix "exponentiation".';
  DUMMY2X2 = A2B**2;
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), -.25) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), 0.5) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), -0.25) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), -0.5)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X2 MATRIX **2', BB) ASSIGN(ERRORS);
  DUMMY2X2 = A2B**(-1);
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), 0.0) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), -2.0) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), 1.0) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), 1.0)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X2 MATRIX **(-1)', BB) ASSIGN(ERRORS);
  DUMMY2X2 = A2B**0;
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), 1) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), 0) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), 0) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), 1)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X2 MATRIX **0', BB) ASSIGN(ERRORS);
  DUMMY2X2 = A2B**T;
  IF REALLY_CLOSE_TO(DUMMY2X2$(1,1), 0.5) AND REALLY_CLOSE_TO(DUMMY2X2$(1,2), -0.5) AND
     REALLY_CLOSE_TO(DUMMY2X2$(2,1), 1.0) AND REALLY_CLOSE_TO(DUMMY2X2$(2,2), 0.0)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X2 MATRIX **T', BB) ASSIGN(ERRORS);
  DUMMY3X2 = A23A**T;
  IF REALLY_CLOSE_TO(DUMMY3X2$(1,1), 1) AND REALLY_CLOSE_TO(DUMMY3X2$(1,2), 2) AND
     REALLY_CLOSE_TO(DUMMY3X2$(2,1), 0) AND REALLY_CLOSE_TO(DUMMY3X2$(2,2), 0) AND
     REALLY_CLOSE_TO(DUMMY3X2$(3,1), 3) AND REALLY_CLOSE_TO(DUMMY3X2$(3,2), 4)
  THEN BB = TRUE; ELSE BB = FALSE;
  CALL PRINT_RESULT('2X3 MATRIX **T', BB) ASSIGN(ERRORS);
  
  CLOSE DATATYPES_029;
  CALL DATATYPES_029 ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
  INITIAL_AND_CONSTANT_032:
  PROCEDURE ASSIGN(ERRORS);
     DECLARE X SCALAR INITIAL(0);
     DECLARE MAX_SPEED SCALAR INITIAL(14000);
     DECLARE FEET_TO_MILES SCALAR CONSTANT(1 / 5280);
     DECLARE SEC_TO_HR CONSTANT(60 (60));
     DECLARE MAX_MPH INITIAL(14000 FEET_TO_MILES / SEC_TO_HR);
     DECLARE BB BOOLEAN;
     
     WRITE(6) ;
     WRITE(6) 'See "Programming in HAL/S" p. 2-12.';
     IF X = 0 THEN BB = TRUE; ELSE BB = FALSE;
     CALL PRINT_RESULT('SCALAR INITIAL', BB) ASSIGN(ERRORS);
     IF MAX_SPEED = 14000 THEN BB = TRUE; ELSE BB = FALSE;
     CALL PRINT_RESULT('SCALAR INITIAL 2', BB) ASSIGN(ERRORS);
     IF REALLY_CLOSE_TO(FEET_TO_MILES, 189.393939394E-6) 
     THEN BB = TRUE; ELSE BB = FALSE;
     CALL PRINT_RESULT('SCALAR INITIAL 3', BB) ASSIGN(ERRORS);
     IF SEC_TO_HR = 3600 THEN BB = TRUE; ELSE BB = FALSE;
     CALL PRINT_RESULT('SCALAR INITIAL 4', BB) ASSIGN(ERRORS);
     IF REALLY_CLOSE_TO(MAX_MPH, 736.531986532E-6)
     THEN BB = TRUE; ELSE BB = FALSE;
     CALL PRINT_RESULT('SCALAR INITIAL 5', BB) ASSIGN(ERRORS);
     
  CLOSE INITIAL_AND_CONSTANT_032;
  CALL INITIAL_AND_CONSTANT_032 ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
  WRITE(6) ;
  WRITE(6) 'See "Programming in HAL/S" pp. 3-9 and 3-10."'; 
  ROWS_047:
  PROCEDURE ASSIGN(ERRORS);
     DECLARE MM MATRIX INITIAL(11, 12, 13, 21, 22, 23, 31, 32, 33), 
     	     M MATRIX,
     	     TEMP VECTOR,
     	     C SCALAR INITIAL(2),
     	     I INTEGER INITIAL(1),
     	     J INTEGER INITIAL(2),
     	     BB BOOLEAN;
     		
C  MULTIPLY A ROW BY A (NONZERO) CONSTANT:

  M = MM;
E    -        -
M    M    = C MM   ;
S     I,*       I,*
  BB = TRUE;
  DO FOR TEMPORARY J = 1 TO 3;
     IF M$(1,J) ~= 2 (10 + J) THEN BB = FALSE;
  END;
  DO FOR TEMPORARY I = 2 TO 3; DO FOR TEMPORARY J = 1 TO 3;
     IF M$(I,J) ~= 10 I + J THEN BB = FALSE;
  END; END;
  CALL PRINT_RESULT('SCALAR TIMES MATRIX ROW', BB) ASSIGN(ERRORS);
     
C  ADD A CONSTANT MULTIPLE OF ROW J TO ROW I:

  M = MM;
E    -      -         -
M    M    = MM    + C MM   ;
S     I,*     I,*       J,*
  BB = TRUE;
  DO FOR TEMPORARY J = 1 TO 3;
     IF M$(1,J) ~= (10 + J) + 2 (20 + J) THEN BB = FALSE;
  END;
  DO FOR TEMPORARY I = 2 TO 3; DO FOR TEMPORARY J = 1 TO 3;
     IF M$(I,J) ~= 10 I + J THEN BB = FALSE;
  END; END;
  CALL PRINT_RESULT('LINEAR COMBO OF MATRIX ROWS', BB) ASSIGN(ERRORS);
    
C  EXCHANGE ROWS I AND J:
 
  M = MM;
E     -     -
M    TEMP = M   ;
S            I,*

E    -      -
M    M    = M   ;
S     I,*    J,*

E    -       -
M    M    = TEMP;
S     J,*
  BB = TRUE;
  DO FOR TEMPORARY I = 1 TO 3; DO FOR TEMPORARY J = 1 TO 3;
     TEMPORARY K INTEGER;
     IF I = 1 THEN K = 20;
     IF I = 2 THEN K = 10;
     IF I = 3 THEN K = 30;
     IF M$(I,J) ~= K + J THEN BB = FALSE;
  END; END;
  CALL PRINT_RESULT('SWAP MATRIX ROWS', BB) ASSIGN(ERRORS);
     
  CLOSE ROWS_047;
 CALL ROWS_047 ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/
 WRITE(6) ;
 WRITE(6) 'Some REPLACE-macro tests.';
 WRITE(6) 'See p. 3-14 of "Programming in HAL/S".';
 
 TABLE_052:
 PROCEDURE ASSIGN(ERRORS);
     REPLACE LOG2(X) BY "LOG(X)/LOG(2)";
     REPLACE CHECK(X, VALUE) BY "REALLY_CLOSE_TO(LOG2(X), VALUE)";
     
     CALL PRINT_RESULT('REPLACE 0.25', CHECK(0.25, -2)) ASSIGN(ERRORS);
     CALL PRINT_RESULT('REPLACE 0.5', CHECK(0.5, -1)) ASSIGN(ERRORS);
     CALL PRINT_RESULT('REPLACE 1', CHECK(1, 0)) ASSIGN(ERRORS);
     CALL PRINT_RESULT('REPLACE 2', CHECK(2, 1)) ASSIGN(ERRORS);
     CALL PRINT_RESULT('REPLACE 4', CHECK(4, 2)) ASSIGN(ERRORS);
     CALL PRINT_RESULT('REPLACE 8', CHECK(8, 3)) ASSIGN(ERRORS);
     CALL PRINT_RESULT('REPLACE 16', CHECK(16, 4)) ASSIGN(ERRORS);
 CLOSE TABLE_052;
 CALL TABLE_052 ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/
 WRITE(6) ;
 WRITE(6) 'Tests of discrete FOR-loop, with and without WHILE/UNTIL clause.';
 WRITE(6) 'See p. 5-6 of "Programming in HAL/S".';
 /*
 DECLARE SMALL_PRIMES ARRAY(26) INTEGER CONSTANT(2, 3, 5, 7, 11, 13, 17, 19, 23, 
 					         29, 31, 37, 41, 43, 47, 53, 59, 
 					         61, 67, 71, 73, 79, 83, 89, 97, 
 					         101);
 */
 DECLARE SMALL_PRIMES ARRAY(26) INTEGER;
 SMALL_PRIMES = INTEGER(2, 3, 5, 7, 11, 13, 17, 19, 23, 
 					         29, 31, 37, 41, 43, 47, 53, 59, 
 					         61, 67, 71, 73, 79, 83, 89, 97, 
 					         101);
 BB = TRUE;
 DO FOR TEMPORARY I = 2 TO 101;
    TEMPORARY IS_PRIME BOOLEAN, IS_IN_ARRAY BOOLEAN;
    IS_PRIME = TRUE;
    DO FOR TEMPORARY J = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47;
       IF I NOT = J AND REMAINDER(I, J) = 0 THEN DO;
          IS_PRIME = FALSE;
          EXIT;
       END;
    END;
    IS_IN_ARRAY = FALSE;
    DO FOR TEMPORARY J = 1 TO 26;
       IF I = SMALL_PRIMES$J THEN DO;
          IS_IN_ARRAY = TRUE;
          EXIT;
       END;
    END;
    IF IS_PRIME ~= IS_IN_ARRAY THEN DO;
       BB = FALSE;
       EXIT;
    END;
 END;
 CALL PRINT_RESULT('DISCRETE FOR', BB) ASSIGN(ERRORS);
 
 DECLARE II INTEGER, III INTEGER;
 III = 0;
 DO FOR II = 2, 6, 69, -5, 21, 62 WHILE II > 0; III = III + 1; END;
 IF II = -5 AND III = 3 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('DISCRETE FOR WHILE', BB) ASSIGN(ERRORS);
 III = 0;
 DO FOR II = 2, 6, 69, -5, 21, 62 UNTIL II < 0; III = III + 1; END;
 IF II = -5 AND III = 4 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('DISCRETE FOR UNTIL', BB) ASSIGN(ERRORS);
 III = 0;
 BB = TRUE;
 DO FOR II = 2, 3, 5, 7, 11, 13, 17; 
    III = III + 1; 
    IF II ~= SMALL_PRIMES$III THEN BB = FALSE;
 END;
 IF II ~= 17 THEN BB = FALSE;
 CALL PRINT_RESULT('DISCRETE FOR PRIMES', BB) ASSIGN(ERRORS);
 
 BB = TRUE;
 III = 1;
 DO FOR II = 1, 2 II, 2 II, 2 II, 2 II, 2 II, 2 II;
    IF II ~= III THEN BB = FALSE;
    III = 2 III;
 END;
 IF II NOT = 64 THEN BB = FALSE;
 CALL PRINT_RESULT('DISCRETE FOR EXPRESSIONS', BB) ASSIGN(ERRORS);
 
 DO FOR II = 1, 2 II, 2 II, 2 II, 2 II, 2 II, 2 II;
    IF II > 4 THEN EXIT;
 END;
 IF II = 8 THEN BB = TRUE; ELSE BB = FALSE;
 CALL PRINT_RESULT('DISCRETE FOR EXIT', BB) ASSIGN(ERRORS);
 
 BB = TRUE;
 III = 1;
 DO FOR II = 1, 2 II, 2 II, 2 II, 2 II, 2 II, 2 II;
    IF II < 32 THEN DO;
       IF II ~= III THEN BB = FALSE;
       III = 2 III;
       REPEAT;
    END; 
    EXIT;
 END;
 IF II NOT = 32 THEN BB = FALSE;
 CALL PRINT_RESULT('DISCRETE FOR REPEAT', BB) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/
 WRITE(6) ;
 WRITE(6) 'Some test cases for DO CASE statements.';
 DO FOR TEMPORARY I = 1 TO 10;
    TEMPORARY II INTEGER;
    II = 100;
    DO CASE I;
       II = 1;
       II = 2;
       II = 3;
       II = 4;
       II = 5;
    END;
    BB = TRUE;
    IF I <= 5 AND II ~= I THEN BB = FALSE;
    IF I > 5 AND II ~= 100 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('DO CASE NO ELSE', BB) ASSIGN(ERRORS);
 
 DO FOR TEMPORARY I = 1 TO 10;
    TEMPORARY II INTEGER;
    II = 100;
    DO CASE I;
       ELSE II = 99;
       II = 1;
       II = 2;
       II = 3;
       II = 4;
       II = 5;
    END;
    BB = TRUE;
    IF I <= 5 AND II ~= I THEN BB = FALSE;
    IF I > 5 AND II ~= 99 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('DO CASE ELSE', BB) ASSIGN(ERRORS);
 
 DO FOR TEMPORARY I = 1 TO 10;
    TEMPORARY II INTEGER;
    II = 100;
    DO CASE I;
       ELSE DO;
       	  TEMPORARY K INTEGER;
       	  K = 0;
          DO FOR TEMPORARY J = 1 TO 98; K = K + 1; END;
          II = K;
       END;
       II = 1;
       II = 2;
       II = 3;
       DO;
       	  TEMPORARY K INTEGER;
       	  K = 0;
          DO FOR TEMPORARY J = 1 TO 4; K = K + 1; END;
          II = K;
       END;
       II = 5;
    END;
    BB = TRUE;
    IF I <= 5 AND II ~= I THEN BB = FALSE;
    IF I > 5 AND II ~= 98 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('DO CASE BLOCKS', BB) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/
 WRITE(6) ;
 WRITE(6) 'Some tests of REPEAT inside of loops.';
 DECLARE REPEAT_EXPECTED VECTOR(55) 
 	   		CONSTANT(1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5,
 				 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 7,
 				 1, 2, 3, 4, 5, 6, 7, 8,
 				 1, 2, 3, 4, 5, 6, 7, 8, 9,
 				 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
 BB = TRUE;
 DO;
    TEMPORARY K INTEGER;
    K = 0;
    REPEAT_LABEL1: 
    DO FOR TEMPORARY I = 1 TO 10;
       DO FOR TEMPORARY J = 1 TO 10;
          IF J > I THEN REPEAT REPEAT_LABEL1;
          K = K + 1;
          IF J ~= REPEAT_EXPECTED$K THEN BB = FALSE;
          /*WRITE(6) I, J;*/
       END;
    END;
    IF K ~= 55 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('NESTED DO FOR REPEAT', BB) ASSIGN(ERRORS);
 
 BB = TRUE;
 DO;
    TEMPORARY K INTEGER;
    K = 0;
    REPEAT_LABEL1: 
    DO FOR TEMPORARY I = 1 TO 10 WHILE I < 100;
       DO FOR TEMPORARY J = 1 TO 10;
          IF J > I THEN REPEAT REPEAT_LABEL1;
          K = K + 1;
          IF J ~= REPEAT_EXPECTED$K THEN BB = FALSE;
          /*WRITE(6) I, J;*/
       END;
    END;
    IF K ~= 55 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('NESTED DO FOR WHILE REPEAT', BB) ASSIGN(ERRORS);
 
 BB = TRUE;
 DO;
    TEMPORARY K INTEGER;
    K = 0;
    REPEAT_LABEL1: 
    DO FOR TEMPORARY I = 1 TO 10 UNTIL I > 100;
       DO FOR TEMPORARY J = 1 TO 10;
          IF J > I THEN REPEAT REPEAT_LABEL1;
          K = K + 1;
          IF J ~= REPEAT_EXPECTED$K THEN BB = FALSE;
          /*WRITE(6) I, J;*/
       END;
    END;
    IF K ~= 55 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('NESTED DO FOR UNTIL REPEAT', BB) ASSIGN(ERRORS);
 
 BB = TRUE;
 DO;
    TEMPORARY K INTEGER;
    K = 0;
    REPEAT_LABEL1: 
    DO FOR TEMPORARY I = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10;
       DO FOR TEMPORARY J = 1 TO 10;
          IF J > I THEN REPEAT REPEAT_LABEL1;
          K = K + 1;
          IF J ~= REPEAT_EXPECTED$K THEN BB = FALSE;
          /*WRITE(6) I, J;*/
       END;
    END;
    IF K ~= 55 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('NESTED DO FOR DISCRETE REPEAT', BB) ASSIGN(ERRORS);
 
 BB = TRUE;
 DO;
    TEMPORARY K INTEGER;
    K = 0;
    REPEAT_LABEL1: 
    DO FOR TEMPORARY I = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 WHILE I < 100;
       DO FOR TEMPORARY J = 1 TO 10;
          IF J > I THEN REPEAT REPEAT_LABEL1;
          K = K + 1;
          IF J ~= REPEAT_EXPECTED$K THEN BB = FALSE;
          /*WRITE(6) I, J;*/
       END;
    END;
    IF K ~= 55 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('NESTED DO FOR DISCRETE WHILE REPEAT', BB) ASSIGN(ERRORS);
 
 BB = TRUE;
 DO;
    TEMPORARY K INTEGER;
    K = 0;
    REPEAT_LABEL1: 
    DO FOR TEMPORARY I = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 UNTIL I > 100;
       DO FOR TEMPORARY J = 1 TO 10;
          IF J > I THEN REPEAT REPEAT_LABEL1;
          K = K + 1;
          IF J ~= REPEAT_EXPECTED$K THEN BB = FALSE;
          /*WRITE(6) I, J;*/
       END;
    END;
    IF K ~= 55 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('NESTED DO FOR DISCRETE UNTIL REPEAT', BB) ASSIGN(ERRORS);
 
 BB = TRUE;
 DO;
    TEMPORARY K INTEGER, I INTEGER;
    K = 0;
    I = 0;
    REPEAT_LABEL1: 
    DO WHILE I < 10;
       I = I + 1;
       DO FOR TEMPORARY J = 1 TO 10;
          IF J > I THEN REPEAT REPEAT_LABEL1;
          K = K + 1;
          IF J ~= REPEAT_EXPECTED$K THEN BB = FALSE;
          /*WRITE(6) I, J;*/
       END;
    END;
    IF K ~= 55 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('NESTED DO WHILE REPEAT', BB) ASSIGN(ERRORS);
 
 BB = TRUE;
 DO;
    TEMPORARY K INTEGER, I INTEGER;
    K = 0;
    I = 0;
    REPEAT_LABEL1: 
    DO UNTIL I = 10;
       I = I + 1;
       DO FOR TEMPORARY J = 1 TO 10;
          IF J > I THEN REPEAT REPEAT_LABEL1;
          K = K + 1;
          IF J ~= REPEAT_EXPECTED$K THEN BB = FALSE;
          /*WRITE(6) I, J;*/
       END;
    END;
    IF K ~= 55 THEN BB = FALSE;
 END;
 CALL PRINT_RESULT('NESTED DO UNTIL REPEAT', BB) ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/
 WRITE(6) ;
 WRITE(6) 'Some tests of the "=" and "NOT =" relational operators.';
 TEST_EQUALS: PROCEDURE ASSIGN(ERRORS);
    DECLARE INTEGER, I1 INITIAL(1), I2 INITIAL(2);
    DECLARE SCALAR, S1 INITIAL(1.0), S2 INITIAL(2.0);
    DECLARE BIT(5), B1 INITIAL(27);
    DECLARE BIT(7), B2 INITIAL(27);
    DECLARE BIT(7), B3 INITIAL(28);
    DECLARE C1 CHARACTER(20) INITIAL('HELLO'), C2 CHARACTER(15) INITIAL('HELLO');
    DECLARE C3 CHARACTER(20) INITIAL('PUMPERNICKEL');
    DECLARE V1 VECTOR(3) INITIAL(1,2,3), V2 VECTOR(4) INITIAL(1,2,3,4);
    DECLARE M1 MATRIX(3,2) INITIAL(1,2,3,4,5,6), M2 MATRIX(3,2) INITIAL(2,1,3,4,5,6);
    DECLARE AI1 ARRAY(5) INTEGER INITIAL(1,2,3,4,5), 
    	    AI2 ARRAY(5) INTEGER INITIAL(2,1,3,4,5),
    	    AI3 ARRAY(3,2) INTEGER INITIAL(1,2,3,4,5,6), 
    	    AI4 ARRAY(3,2) INTEGER INITIAL(2,1,3,4,5,6),
    	    AS1 ARRAY(5) SCALAR INITIAL(1,2,3,4,5), 
    	    AS2 ARRAY(5) SCALAR INITIAL(2,1,3,4,5),
    	    AS3 ARRAY(3,2) SCALAR INITIAL(1,2,3,4,5,6), 
    	    AS4 ARRAY(3,2) SCALAR INITIAL(2,1,3,4,5,6),
    	    AC1 ARRAY(5) CHARACTER(32) INITIAL(1,2,3,4,5), 
    	    AC2 ARRAY(5) CHARACTER(32) INITIAL(2,1,3,4,5),
    	    AC3 ARRAY(3,2) CHARACTER(32) INITIAL(1,2,3,4,5,6), 
    	    AC4 ARRAY(3,2) CHARACTER(32) INITIAL(2,1,3,4,5,6),
    	    AB1 ARRAY(5) BIT(4) INITIAL(1,2,3,4,5), 
    	    AB2 ARRAY(5) BIT(5) INITIAL(2,1,3,4,5),
    	    AB3 ARRAY(3,2) BIT(6) INITIAL(1,2,3,4,5,6), 
    	    AB4 ARRAY(3,2) BIT(7) INITIAL(2,1,3,4,5,6),
    	    AV1 ARRAY(5) VECTOR(2) INITIAL(1,2,3,4,5,6,7,8,9,10), 
    	    AV2 ARRAY(5) VECTOR(2) INITIAL(2,1,3,4,5,6,7,8,9,10),
    	    AV3 ARRAY(3,2) VECTOR(2) INITIAL(1,2,3,4,5,6,7,8,9,10,11,12), 
    	    AV4 ARRAY(3,2) VECTOR(2) INITIAL(2,1,3,4,5,6,7,8,9,10,11,12),
    	    AM1 ARRAY(5) MATRIX(2,2) INITIAL(1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10), 
    	    AM2 ARRAY(5) MATRIX(2,2) INITIAL(2,1,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10),
    	    AM3 ARRAY(3,2) MATRIX(2,2) INITIAL(1,2,3,4,5,6,7,8,9,10,11,12,1,2,3,4,5,6,7,8,9,10,11,12), 
    	    AM4 ARRAY(3,2) MATRIX(2,2) INITIAL(2,1,3,4,5,6,7,8,9,10,11,12,1,2,3,4,5,6,7,8,9,10,11,12)
    	    ;
    DECLARE BB BOOLEAN;
    IF I1 = I1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('INTEGER EQUALITY 1', BB) ASSIGN(ERRORS);
    IF I1 = I2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('INTEGER EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF I1 NOT = I1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('INTEGER INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF I1 NOT = I2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('INTEGER INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF S1 = S1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('SCALAR EQUALITY 1', BB) ASSIGN(ERRORS);
    IF S1 = S2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('SCALAR EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF S1 NOT = S1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('SCALAR INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF S1 NOT = S2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('SCALAR INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF I1 = S1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('INTEGER:SCALAR EQUALITY 1', BB) ASSIGN(ERRORS);
    IF I1 = S2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('INTEGER:SCALAR EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF I1 NOT = S1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('INTEGER:SCALAR INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF I1 NOT = S2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('INTEGER:SCALAR INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF C1 = C1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('STRING EQUALITY 1', BB) ASSIGN(ERRORS);
    IF C1 = C2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('STRING EQUALITY 2', BB) ASSIGN(ERRORS);
    IF C1 = C3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('STRING EQUALITY 3', NOT BB) ASSIGN(ERRORS);
    IF C1 NOT = C1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('STRING INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF C1 NOT = C2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('STRING INEQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF C1 NOT = C3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('STRING INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF B1 = B1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('BIT EQUALITY 1', BB) ASSIGN(ERRORS);
    IF B1 = B2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('BIT EQUALITY 2', BB) ASSIGN(ERRORS);
    IF B1 = B3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('BIT EQUALITY 3', NOT BB) ASSIGN(ERRORS);
    IF B1 NOT = B1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('BIT INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF B1 NOT = B2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('BIT INEQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF B1 NOT = B3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('BIT INEQUALITY 3', BB) ASSIGN(ERRORS);
    IF V1 = V1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('VECTOR EQUALITY 1', BB) ASSIGN(ERRORS);
    IF V1 = V2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('VECTOR EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF V1 NOT = V1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('VECTOR INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF V1 NOT = V2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('VECTOR INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF M1 = M1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('MATRIX EQUALITY 1', BB) ASSIGN(ERRORS);
    IF M1 = M2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('MATRIX EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF M1 NOT = M1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('MATRIX INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF M1 NOT = M2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('MATRIX INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF AI1 = AI1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D INTEGER EQUALITY 1', BB) ASSIGN(ERRORS);
    IF AI1 = AI2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D INTEGER EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF AI1 NOT = AI1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D INTEGER INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF AI1 NOT = AI2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D INTEGER INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF AS1 = AS1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D SCALAR EQUALITY 1', BB) ASSIGN(ERRORS);
    IF AS1 = AS2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D SCALAR EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF AS1 NOT = AS1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D SCALAR INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF AS1 NOT = AS2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D SCALAR INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF AI3 = AI3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D INTEGER EQUALITY 1', BB) ASSIGN(ERRORS);
    IF AI3 = AI4 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D INTEGER EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF AI3 NOT = AI4 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D INTEGER INEQUALITY 1', BB) ASSIGN(ERRORS);
    IF AI3 NOT = AI4 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D INTEGER INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF AS3 = AS3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D SCALAR EQUALITY 1', BB) ASSIGN(ERRORS);
    IF AS3 = AS4 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D SCALAR EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF AS3 NOT = AS3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D SCALAR INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF AS3 NOT = AS4 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D SCALAR INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF AI3 = AS3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D INTEGER:SCALAR EQUALITY 1', BB) ASSIGN(ERRORS);
    IF AI3 = AS4 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D INTEGER:SCALAR EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF AI3 NOT = AS3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D INTEGER:SCALAR INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF AI3 NOT = AS4 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D INTEGER:SCALAR INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF AB1 = AB1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D BIT EQUALITY 1', BB) ASSIGN(ERRORS);
    IF AB1 = AB2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D BIT EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF AB1 NOT = AB1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D BIT INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF AB1 NOT = AB2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D BIT INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF AB3 = AB3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D BIT EQUALITY 1', BB) ASSIGN(ERRORS);
    IF AB3 = AB4 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D BIT EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF AB3 NOT = AB3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D BIT INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF AB3 NOT = AB4 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D BIT INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF AV1 = AV1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D VECTOR EQUALITY 1', BB) ASSIGN(ERRORS);
    IF AV1 = AV2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D VECTOR EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF AV1 NOT = AV1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D VECTOR INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF AV1 NOT = AV2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D VECTOR INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF AV3 = AV3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D VECTOR EQUALITY 1', BB) ASSIGN(ERRORS);
    IF AV3 = AV4 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D VECTOR EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF AV3 NOT = AV3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D VECTOR INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF AV3 NOT = AV4 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D VECTOR INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF AM1 = AM1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D MATRIX EQUALITY 1', BB) ASSIGN(ERRORS);
    IF AM1 = AM2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D MATRIX EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF AM1 NOT = AM1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D MATRIX INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF AM1 NOT = AM2 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 1D MATRIX INEQUALITY 2', BB) ASSIGN(ERRORS);
    IF AM3 = AM3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D MATRIX EQUALITY 1', BB) ASSIGN(ERRORS);
    IF AM3 = AM4 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D MATRIX EQUALITY 2', NOT BB) ASSIGN(ERRORS);
    IF AM3 NOT = AM3 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D MATRIX INEQUALITY 1', NOT BB) ASSIGN(ERRORS);
    IF AM3 NOT = AM4 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('ARRAY 2D MATRIX INEQUALITY 2', BB) ASSIGN(ERRORS);
 CLOSE TEST_EQUALS;
 CALL TEST_EQUALS ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/
 WRITE(6);
 WRITE(6) 'Test unary minus on composite datatypes.';
 TEST_UNARY_MINUS: PROCEDURE ASSIGN(ERRORS);
    DECLARE ERRORS INTEGER;
    DECLARE INTEGER, I INITIAL(5), II;
    DECLARE SCALAR, S INITIAL(6), SS;
    DECLARE VECTOR, V INITIAL(7,8,9), VV;
    DECLARE MATRIX, M INITIAL(10,11,12,13,14,15,16,17,18), MM;
    DECLARE ARRAY(3) INTEGER, AI INITIAL(20,21,22), AII;
    DECLARE ARRAY(3) SCALAR, AS INITIAL(23,24,25), ASS;
    DECLARE ARRAY(2) VECTOR, AV INITIAL(31,32,33,34,35,36), AVV;
    DECLARE ARRAY(2) MATRIX(2,2), AM INITIAL(41,42,43,44,45,46,47,48), AMM;
    DECLARE ARRAY(2,2) VECTOR(2), A2V INITIAL(51,52,53,54,55,56,57,58), A2VV;
    DECLARE BOOLEAN, BB;
    II = -I;
    IF II = -5 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('Unary minus INTEGER', BB) ASSIGN(ERRORS);
    SS = -S;
    IF SS = -6 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('Unary minus SCALAR', BB) ASSIGN(ERRORS);
    VV = -V;
    CALL CHECK_LINEAR('Unary minus VECTOR', -7, -1, SCALAR(1#VV)) ASSIGN(ERRORS);
    MM = -M;
    CALL CHECK_LINEAR('Unary minus MATRIX', -10, -1, SCALAR(1#MM)) ASSIGN(ERRORS);
    AII = -AI;
    CALL CHECK_LINEAR('Unary minus 1D ARRAY INTEGER', -20, -1, SCALAR(1#AII)) ASSIGN(ERRORS);
    ASS = -AS;
    CALL CHECK_LINEAR('Unary minus 1D ARRAY SCALAR', -23, -1, SCALAR(1#ASS)) ASSIGN(ERRORS);
    AVV = -AV;
    CALL CHECK_LINEAR('Unary minus 1D ARRAY VECTOR', -31, -1, SCALAR(1#AVV)) ASSIGN(ERRORS);
    AMM = -AM;
    CALL CHECK_LINEAR('Unary minus 1D ARRAY MATRIX', -41, -1, SCALAR(1#AMM)) ASSIGN(ERRORS);
    A2VV = -A2V;
    CALL CHECK_LINEAR('Unary minus 2D ARRAY VECTOR', -51, -1, SCALAR(1#A2VV)) ASSIGN(ERRORS);
 CLOSE TEST_UNARY_MINUS;
 CALL TEST_UNARY_MINUS ASSIGN(ERRORS);
    
 /*--------------------------------------------------------------------------*/
 
 ARRAYED_ARITHMETIC: PROCEDURE ASSIGN(ERRORS);
    DECLARE BOOLEAN, BB;
    DECLARE INTEGER, ERRORS, I, J;
    DECLARE VECTOR, ZEROVECTOR CONSTANT(0,0,0);
    DECLARE ARRAY(2,3) INTEGER, AI1, AI2, AI3;
    DECLARE ARRAY(2,3) SCALAR, AS1, AS2, AS3;
    DECLARE ARRAY(2,3) VECTOR, AV1, AV2, AV3;
    DECLARE ARRAY(2,3) MATRIX, AM1, AM2, AM3;
    
    /* The stuff that follows is all for setting up various data objects
       declared above with "random" data. */
    
    RANDOM_VECTOR: FUNCTION VECTOR;
       DECLARE V VECTOR, I INTEGER;
       DO FOR I = 1 TO 3; V$I = RANDOM; END;
       RETURN V;
    CLOSE RANDOM_VECTOR;
    
    RANDOM_MATRIX: FUNCTION MATRIX;
       DECLARE M MATRIX, I INTEGER;
       DO FOR I = 1 TO 3; 
          M$(I,*) = RANDOM_VECTOR; 
       END;
       RETURN M;
    CLOSE RANDOM_MATRIX;
    
    DO FOR I = 1 TO 2; 
       DO FOR J = 1 TO 3; 
          DO UNTIL AI1$(I,J) ~= 0; AI1$(I,J) = 100 RANDOM; END; 
          DO UNTIL AI2$(I,J) ~= 0; AI2$(I,J) = 100 RANDOM; END;
          DO UNTIL AS1$(I,J) ~= 0; AS1$(I,J) = 100 RANDOM; END;
          DO UNTIL AS2$(I,J) ~= 0; AS2$(I,J) = 100 RANDOM; END;
          DO UNTIL AV1$(I,J) ~= ZEROVECTOR; AV1$(I,J) = RANDOM_VECTOR; END;
          DO UNTIL AV2$(I,J) ~= ZEROVECTOR; AV2$(I,J) = RANDOM_VECTOR; END;
          DO UNTIL ABS(DET(AM1$(I,J))) > 0.1; AM1$(I,J) = RANDOM_MATRIX; END;
          DO UNTIL ABS(DET(AM2$(I,J))) > 0.1; AM2$(I,J) = RANDOM_MATRIX; END;
       END; 
    END;
    
    WRITE(6) ;
    WRITE(6) 'Some tests of arrayed arithmetic.';
    
    AI3 = AI1 + AI2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AI3$(I,J) ~= AI1$(I,J) + AI2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed addition of INTEGER', BB) ASSIGN(ERRORS);
    AS3 = AI1 + AS2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AS3$(I,J) ~= AI1$(I,J) + AS2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed addition of INTEGER to SCALAR', BB) ASSIGN(ERRORS);
    AS3 = AS1 + AI2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AS3$(I,J) ~= AS1$(I,J) + AI2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed addition of SCALAR to INTEGER', BB) ASSIGN(ERRORS);
    AS3 = AS1 + AS2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AS3$(I,J) ~= AS1$(I,J) + AS2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed addition of SCALAR', BB) ASSIGN(ERRORS);
    AV3 = AV1 + AV2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AV1$(I,J) + AV2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed addition of VECTOR', BB) ASSIGN(ERRORS);
    AM3 = AM1 + AM2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AM3$(I,J) ~= AM1$(I,J) + AM2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed addition of MATRIX', BB) ASSIGN(ERRORS);

    AI3 = AI1 - AI2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AI3$(I,J) ~= AI1$(I,J) - AI2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed subtraction of INTEGER', BB) ASSIGN(ERRORS);
    AS3 = AI1 - AS2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AS3$(I,J) ~= AI1$(I,J) - AS2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed subtraction of SCALAR from INTEGER', BB) ASSIGN(ERRORS);
    AS3 = AS1 - AI2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AS3$(I,J) ~= AS1$(I,J) - AI2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed subtraction of INTEGER from SCALAR', BB) ASSIGN(ERRORS);
    AS3 = AS1 - AS2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AS3$(I,J) ~= AS1$(I,J) - AS2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed subtraction of SCALAR', BB) ASSIGN(ERRORS);
    AV3 = AV1 - AV2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AV1$(I,J) - AV2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed subtraction of VECTOR', BB) ASSIGN(ERRORS);
    AM3 = AM1 - AM2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AM3$(I,J) ~= AM1$(I,J) - AM2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed subtraction of MATRIX', BB) ASSIGN(ERRORS);

    AI3 = AI1 / AI2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AI3$(I,J) ~= ROUND(AI1$(I,J) / AI2$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed division of INTEGER', BB) ASSIGN(ERRORS);
    AS3 = AI1 / AS2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AS3$(I,J) ~= AI1$(I,J) / AS2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed division of SCALAR by INTEGER', BB) ASSIGN(ERRORS);
    AS3 = AS1 / AI2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AS3$(I,J) ~= AS1$(I,J) / AI2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed division of INTEGER by SCALAR', BB) ASSIGN(ERRORS);
    AS3 = AS1 / AS2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AS3$(I,J) ~= AS1$(I,J) / AS2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed division of SCALAR', BB) ASSIGN(ERRORS);
    AV3 = AV1 / AI2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AV1$(I,J) / AI2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed division of VECTOR by INTEGER', BB) ASSIGN(ERRORS);
    AV3 = AV1 / AS2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AV1$(I,J) / AS2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed division of VECTOR by SCALAR', BB) ASSIGN(ERRORS);
    AM3 = AM1 / AI2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AM3$(I,J) ~= AM1$(I,J) / AI2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed division of MATRIX by INTEGER', BB) ASSIGN(ERRORS);
    AM3 = AM1 / AS2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AM3$(I,J) ~= AM1$(I,J) / AS2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed division of MATRIX by SCALAR', BB) ASSIGN(ERRORS);

    AS3 = AV1 . AV2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AS3$(I,J) ~= AV1$(I,J) . AV2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed dot product', BB) ASSIGN(ERRORS);

    AV3 = AV1 * AV2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AV1$(I,J) * AV2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed cross product', BB) ASSIGN(ERRORS);
    
    AI3 = AI1 AI2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AI3$(I,J) ~= AI1$(I,J) AI2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of INTEGER', BB) ASSIGN(ERRORS);
    AS3 = AI1 AS2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AS3$(I,J) ~= AI1$(I,J) AS2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of INTEGER by SCALAR', BB) ASSIGN(ERRORS);
    AS3 = AS1 AI2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AS3$(I,J) ~= AS1$(I,J) AI2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of SCALAR by INTEGER', BB) ASSIGN(ERRORS);
    AS3 = AS1 AS2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AS3$(I,J) ~= AS1$(I,J) AS2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of SCALAR', BB) ASSIGN(ERRORS);
    AV3 = AI1 AV2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AI1$(I,J) AV2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of INTEGER by VECTOR', BB) ASSIGN(ERRORS);
    AV3 = AS1 AV2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AS1$(I,J) AV2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of SCALAR by VECTOR', BB) ASSIGN(ERRORS);
    AV3 = AV1 AI2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AV1$(I,J) AI2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of VECTOR by INTEGER', BB) ASSIGN(ERRORS);
    AV3 = AV1 AS2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AV1$(I,J) AS2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of VECTOR by SCALAR', BB) ASSIGN(ERRORS);
    AM3 = AI1 AM2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AM3$(I,J) ~= AI1$(I,J) AM2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of INTEGER by MATRIX', BB) ASSIGN(ERRORS);
    AM3 = AS1 AM2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AM3$(I,J) ~= AS1$(I,J) AM2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of SCALAR by MATRIX', BB) ASSIGN(ERRORS);
    AM3 = AM1 AI2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AM3$(I,J) ~= AM1$(I,J) AI2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of MATRIX by INTEGER', BB) ASSIGN(ERRORS);
    AM3 = AM1 AS2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AM3$(I,J) ~= AM1$(I,J) AS2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of MATRIX by SCALAR', BB) ASSIGN(ERRORS);
    AV3 = AI1 AV2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AI1$(I,J) AV2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of INTEGER by VECTOR', BB) ASSIGN(ERRORS);
    AV3 = AS1 AV2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AS1$(I,J) AV2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of SCALAR by VECTOR', BB) ASSIGN(ERRORS);
    AV3 = AV1 AI2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AV1$(I,J) AI2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed multiplication of VECTOR by INTEGER', BB) ASSIGN(ERRORS);
    AM3 = AV1 AV2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AM3$(I,J) ~= AV1$(I,J) AV2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed outer product of VECTOR', BB) ASSIGN(ERRORS);
    AM3 = AM1 AM2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AM3$(I,J) ~= AM1$(I,J) AM2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed MATRIX multiplication', BB) ASSIGN(ERRORS);
    AV3 = AV1 AM2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AV1$(I,J) AM2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed VECTOR times MATRIX', BB) ASSIGN(ERRORS);
    AV3 = AM1 AV2;
    BB = TRUE;
    DO FOR I = 1 TO 2; DO FOR J = 1 TO 3; 
       IF AV3$(I,J) ~= AM1$(I,J) AV2$(I,J) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed MATRIX times VECTOR', BB) ASSIGN(ERRORS);
    
 CLOSE ARRAYED_ARITHMETIC;
 CALL ARRAYED_ARITHMETIC ASSIGN(ERRORS);

 /*--------------------------------------------------------------------------*/
 NF_TEST: PROCEDURE ASSIGN(ERRORS);
    DECLARE ERRORS INTEGER;
    DECLARE 	E FUNCTION INTEGER, F FUNCTION SCALAR, 
    		G FUNCTION VECTOR, H FUNCTION MATRIX, 
    		C FUNCTION CHARACTER(10), B FUNCTION BIT(5),
    		I INTEGER, S SCALAR, V VECTOR, M MATRIX,
    		A CHARACTER(10), D BIT(5);
    DECLARE 	MM MATRIX INITIAL(1, 2, 3, 4, 5, 6, 7, 8, 9),
    		VV VECTOR INITIAL(4, 5, 6),
    		SS SCALAR INITIAL(77),
    		II INTEGER INITIAL(89),
    		AA CHARACTER(10) INITIAL('HELLO'),
    		DD BIT(5) INITIAL(26),
    		BB BOOLEAN;
 
    WRITE(6);
    WRITE(6) 'No-argument FUNCTION tests.';
    IF II = E THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('No-argument INTEGER function test', BB) ASSIGN(ERRORS);
    IF SS = F THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('No-argument SCALAR function test', BB) ASSIGN(ERRORS);
    IF VV = G THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('No-argument VECTOR function test', BB) ASSIGN(ERRORS);
    IF MM = H THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('No-argument MATRIX function test', BB) ASSIGN(ERRORS);
    /*
    IF AA = C THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('No-argument CHARACTER function test', BB) ASSIGN(ERRORS);
    IF DD = B THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('No-argument BIT function test', BB) ASSIGN(ERRORS);
    */

    E: FUNCTION INTEGER; RETURN ROUND(F+12); CLOSE E;
    F: FUNCTION SCALAR; RETURN G . G; CLOSE F;
    G: FUNCTION VECTOR; DECLARE MM MATRIX; MM = H; RETURN MM$(2,*); CLOSE G;
    H: FUNCTION MATRIX; 
       DECLARE MM MATRIX CONSTANT(1, 2, 3, 4, 5, 6, 7, 8, 9);
       RETURN MM;
    CLOSE H;
    C: FUNCTION CHARACTER(10); RETURN 'HELLO'; CLOSE C;
    B: FUNCTION BIT(5); RETURN 26; CLOSE B;
 CLOSE NF_TEST;
 CALL NF_TEST ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/
 ARRAY_FUNCTIONS: PROCEDURE ASSIGN(ERRORS);
    DECLARE ERRORS INTEGER;
    DECLARE A ARRAY(6) INITIAL(1, 2, 3, 4, 5, 6);
    DECLARE BB;
    WRITE(6) ;
    WRITE(6) 'Array functions.';
    IF MIN(A) = 1 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('Array function MIN', BB) ASSIGN(ERRORS);
    IF MAX(A) = 6 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('Array function MAX', BB) ASSIGN(ERRORS);
    IF SUM(A) = 21 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('Array function SUM', BB) ASSIGN(ERRORS);
    IF PROD(A) = 720 THEN BB = TRUE; ELSE BB = FALSE;
    CALL PRINT_RESULT('Array function PROD', BB) ASSIGN(ERRORS);
 CLOSE ARRAY_FUNCTIONS;
 CALL ARRAY_FUNCTIONS ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/
 ARRAYED_RTL: PROCEDURE ASSIGN(ERRORS);
    DECLARE ERRORS INTEGER;
    DECLARE ARRAY(3,2), A, A1, A2, A3, B2, AB BOOLEAN;
    DECLARE BB BOOLEAN, I INTEGER, J INTEGER;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
    	A1$(I,J) = 20 (RANDOM - 0.5);
    	DO UNTIL ROUND(A2$(I,J)) ~= 0; A2$(I,J) = 20 (RANDOM - 0.5); END;
    	B2$(I,J) = 100 (RANDOM + 1);
    	A3$(I,J) = 20 (RANDOM - 0.5);
    END; END;
    WRITE(6) ;
    WRITE(6) 'Arrayed RTL functions.';
    A = ABS(A1);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF A$(I,J) ~= ABS(A1$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed ABS', BB) ASSIGN(ERRORS);
    A = CEILING(A1);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF A$(I,J) ~= CEILING(A1$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed CEILING', BB) ASSIGN(ERRORS);
    A = DIV(A1, A2);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF A$(I,J) ~= DIV(A1$(I,J), A2$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed DIV', BB) ASSIGN(ERRORS);
    A = FLOOR(A1);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF A$(I,J) ~= FLOOR(A1$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed FLOOR', BB) ASSIGN(ERRORS);
    A = MIDVAL(A1, A2, A3);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF A$(I,J) ~= MIDVAL(A1$(I,J), A2$(I,J), A3$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed MIDVAL', BB) ASSIGN(ERRORS);
    A = MOD(A1, A2);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF A$(I,J) ~= MOD(A1$(I,J), A2$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed MOD', BB) ASSIGN(ERRORS);
    AB = ODD(A1);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF AB$(I,J) ~= ODD(A1$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed ODD', BB) ASSIGN(ERRORS);
    A = REMAINDER(A1, A2);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF A$(I,J) ~= REMAINDER(A1$(I,J), A2$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed REMAINDER', BB) ASSIGN(ERRORS);
    A = ROUND(A1);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF A$(I,J) ~= ROUND(A1$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed ROUND', BB) ASSIGN(ERRORS);
    A = SIGN(A1);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF A$(I,J) ~= SIGN(A1$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed SIGN', BB) ASSIGN(ERRORS);
    A = SIGNUM(A1);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF A$(I,J) ~= SIGNUM(A1$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed SIGNUM', BB) ASSIGN(ERRORS);
    A = TRUNCATE(A1);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF A$(I,J) ~= TRUNCATE(A1$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed TRUNCATE', BB) ASSIGN(ERRORS);
    A = ARCCOS(A1/10);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF A$(I,J) ~= ARCCOS(A1$(I,J)/10) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed ARCCOS', BB) ASSIGN(ERRORS);
    A = ARCCOSH(B2);
    BB = TRUE;
    DO FOR I = 1 TO 3; DO FOR J = 1 TO 2;
       IF A$(I,J) ~= ARCCOSH(B2$(I,J)) THEN BB = FALSE;
    END; END;
    CALL PRINT_RESULT('Arrayed ARCCOSH', BB) ASSIGN(ERRORS);
    WRITE(6) 'More RTL functions could be tested for arrayness, but since';
    WRITE(6) 'they''re all implemented using the same framework, and since';
    WRITE(6) 'we''ve already tested single-argument, double-argument, and';
    WRITE(6) 'triple-argument functions, it seems kind of pointless to';
    WRITE(6) 'continue doing so.  More of these tests can be implemented';
    WRITE(6) 'later if the need arises.';
    
 CLOSE ARRAYED_RTL;
 CALL ARRAYED_RTL ASSIGN(ERRORS);
 
 /*--------------------------------------------------------------------------*/	
 WRITE(6) ;
 IF ALLTESTS THEN DO;
    TEMPORARY STIME, ETIME; 
    WRITE(6) 'Not a pass/fail test. Informational execution-speed timing measurement.'; 
    STIME = RUNTIME; 
    M = 100000; 
    I = 0; DO WHILE I < M; I = I + 1; END; 
    ETIME = RUNTIME; 
    WRITE(6) M, 'iterations,', ETIME-STIME, 'seconds, ', 
 	  ROUND(M/(ETIME-STIME)), 'iterations/second.'; 
 END;
 ELSE WRITE(6) 'Skipping informational test(s).';
 	
 /*--------------------------------------------------------------------------*/	
 WRITE(6); 
 WRITE(6) 'Total errors:', ERRORS;
 
